152Igloo:Soundly LinkingCompositional Refinementand
Separation Logic forDistributed System Verification
CHRISTOPH SPRENGER, TOBIAS KLENZE, MARCO EILERS, FELIX A. WOLF, PETER
MÃœLLER, MARTIN CLOCHARD, and DAVID BASIN, ETH Zurich,Switzerland
Lighthouse projects like CompCert, seL4, IronFleet, and DeepSpec have demonstrated that full system verifi-
cation is feasible by establishing a refinement between an abstract system specification and an executable
implementation.Existingapproacheshoweverimposesevererestrictionsontheabstractsystemspecifications
duetotheirlimitedexpressivenessorversatility,orontheexecutablecodeduetotheiruseofsuboptimalcode
extraction or inexpressive program logics. We propose a novel methodology that combines the compositional
refinementofevent-basedmodelsofdistributedsystemswiththeverificationoffull-fledgedprogramcode
using expressive separation logics, which support features of realistic programming languages like heap data
structures and concurrency. Our main technical contribution is a formal framework that soundly relates
event-based system models to program specifications in separation logics. This enables protocol development
tools to soundly interoperate with program verifiers to establish a refinement between the model and the
code. We formalized our framework, Igloo, in Isabelle/HOL. We report on three case studies, a leader election
protocol,areplicationprotocol,andasecurityprotocol,forwhichwerefineformalrequirementsintoprogram
specifications that we implement inJava andPythonandprove correctusing the VeriFast andNaginitools.
CCS Concepts: â€¢Theory of computation â†’Logic and verification ;Higher order logic ;Separation
logic;â€¢Computersystemsorganization â†’Dependableandfault-tolerantsystemsandnetworks ;â€¢
Securityandprivacy â†’Logicand verification ; â€¢Computingmethodologies â†’Distributed algorithms .
AdditionalKeyWordsandPhrases:end-to-endverification,distributedsystems,compositionalrefinement,
higher-order logic, separation logic, toolinteroperability,leader election, fault-tolerance,security protocols.
ACM ReferenceFormat:
Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David
Basin. 2020. Igloo: Soundly Linking Compositional Refinementand SeparationLogic for Distributed System
Verification. Proc. ACM Program. Lang. 4, OOPSLA, Article 152 (November 2020), 31pages.https://doi.org/10.
1145/3428220
1 INTRODUCTION
The full verification of entire software systems, formally relating abstract specifications to exe-
cutablecode,isoneofthegrandchallengesofcomputerscience[ Hoare2003 ].Seminalprojects
such as seL4 [ Klein et al .2009], CompCert [ Leroy 2006 ], IronFleet [ Hawblitzel et al .2015], and
DeepSpec [ Pierce 2016 ] have achieved this goal by formally establishing a refinement relation
between a systemspecification and an executable implementation.
Despite this progress, substantial challenges still lay ahead. We posit that techniques for the
verification of entiresystems shouldsatisfy four major requirements:
Authorsâ€™ address: Christoph Sprenger, sprenger@inf.ethz.ch; Tobias Klenze, tobias.klenze@inf.ethz.ch; Marco Eilers, marco.
eilers@inf.ethz.ch; Felix A. Wolf, felix.wolf@inf.ethz.ch; Peter MÃ¼ller, peter.mueller@inf.ethz.ch; Martin Clochard, martin.
clochard@inf.ethz.ch; DavidBasin, basin@inf.ethz.ch, Department ofComputerScience,ETH Zurich, Switzerland.
Â© 2020Copyrightheld by the owner/author(s).
2475-1421/2020/11-ART152
https://doi.org/10.1145/3428220
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.
Thiswork is licensed underaCreativeCommons Attribution 4.0 InternationalLicense.152:2 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
(1)End-to-end guarantees : Verification techniques should provide system-wide correctness guar-
antees,relatingglobal propertiesto verifiedimplementationsof thesystemcomponents.
(2)Versatility :Verificationtechniquesshouldbeapplicabletoawiderangeofsystems.Inthe
important domain of distributed systems, versatility requires (i) the ability to model different
kindsofenvironmentsinwhichthesystemoperates,capturing,forinstance,differentnetwork
properties, fault models, or attacker models, (ii) support for different flavors of systems,
comprising different types of components (such as clients and servers) and allowing an
unbounded number of instances per component type, and (iii) support for heterogeneous
implementations,forinstance,tosupportthecommoncasethatclientsaresequential,servers
areconcurrent,and eachof themisimplementedin a differentlanguage.
(3)Expressiveness :Verificationtechniquesshouldsupportexpressivelanguagesandlogics.In
particular, high-level system models and proofs often benefit from the expressiveness of
richformalismssuchashigher-orderlogic,whereascode-levelverificationneedstotarget
efficiently-executable and maintainableimplementations,often in multiple languages.
(4)Toolinteroperability :Whileitis possibleto support the previousthreerequirements within
one generic verification tool, it is advantageous to employ specialized tools, for instance, to
obtain a high degree of automation and to leverage existing tools, infrastructure, and expert
knowledge.Thisgivesrisetotheadditionalrequirementofsoundinteroperabilityofdifferent
verificationtools,whichisalong-standingchallengeinverification.Moreover,integrating
toolsshouldideallynotrequireanymodificationstothetools,eventhoughtheymaysupport
differentlogics and programminglanguages.
Despite enablingfullverification, existing techniques donot meet all of theserequirements.
Some existing approaches [ Koh et al.2019] use specifications of individual system components
(such as a server), but do not explain how to formally connect them to a global model of the entire
system.Aglobalmodelisnecessarytoprovesystem-wideproperties,especiallyindecentralized
systems.Others[ OortwijnandHuisman2019 ]donotconsiderthepreservationofglobalmodel
propertiesdowntotheimplementation.Hence,theseapproachesdonotmeetourfirstrequirement.
Most existing approaches do not match our versatility requirements. Some target particular
types of systems [ Klein et al .2009;Lesani et al .2016;Rahli et al .2018] or make fixed environment
assumptions [ Koh et al.2019;Sergey et al .2018]. Moreover, in several works, different component
typeswithunboundednumbersofinstancesareeithernotsupportedoritisunclearwhethertheyare
genericallysupported[ Hawblitzeletal .2015;Kohetal.2019].Finally,manyapproaches[ Hawblitzel
et al.2015;Lesani et al .2016;Rahli et al .2018;Sergey et al .2018;Wilcox et al .2015] prescribe a
fixedprogramminglanguage and, thus,donot supportheterogeneous implementations.
Most previous work does not satisfy our expressiveness requirement. Some of them [ Hawblitzel
etal.2015,2014]limittheformalismusedformodeldevelopmenttofirst-orderlogic,toleverage
SMT solvers, which complicates the formalization of common properties such as graph properties.
Others restrict the executable implementation [ Leroy 2006 ;Lesani et al .2016;Liu et al.2020;Rahli
et al.2018;Sergey et al .2018;Wilcox et al .2015;Woos et al .2016] and extract executable code
directly from formal models. This guarantees the implementationâ€™s correctness, but has several
drawbacks. In particular, the extracted code is purely functional or rewriting-based, with sub-
optimal performance, and any manual code optimizations invalidate the correctness argument and
may compromise the intended behavior. Moreover, code extraction complicates the interaction
withexistingsystemcomponentsandlibraries.Otherapproachesreasonaboutmanually-written
implementations, but do not employ a modern verification logic [ Klein et al .2009], restricting the
implementation, for instance, to sequential code, and precluding the use of existing state-of-the-art
program verification tools, potentially resulting in low proof automation and non-modular proofs.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:3
Finally,mostexistingapproachesrequiretheuseofasingletool,typicallyaninteractivetheorem
prover. This may prevent experts in both protocol and program verification from using the highly
automated tools they are familiar with and from building on their existing infrastructure. An
exception is Oortwijn and Huisman [2019], who combine the Viper verifier [ MÃ¼ller et al .2016]
withthemCRL2 model checker[ Cranen et al. 2013 ] to reason aboutmessagepassing programs.
This Work. We propose a novel approach that combines the top-down compositional refinement of
abstract, event-based system models [ Abadi and Lamport 1991 ;Abrial 2010 ;Lynch and Vaandrager
1995]withthebottom-upverificationoffull-fledgedprogramcodeusingseparationlogic[ Reynolds
2002]. Our approach satisfies all four of our requirements. It offers the full expressive power of
higher-order logic and the foundational guarantees of interactive theorem provers for developing
formal models, as well as the expressiveness and tool support provided by modern program logics.
Thecoreofourapproachisaformalframeworkthatsoundlyrelatesevent-basedsystemmodelsto
programspecificationsinseparationlogic,suchthatsuccessfulverificationestablishesarefinement
between the model and the code. The program specifications decouple models and code, allowing
ustosupportmultiple programminglanguagesandverificationtools.Thisis,forinstance,useful
to develop multiple library implementations of a protocol. Moreover, this decoupling enables a
separation of concerns where we can use specialized tools for model refinement and for code
verification, tailoredto theproblem and theprogramminglanguage at hand.
Wefocusonthedevelopmentof distributed systems,consistingofanarbitrarynumberofcompo-
nents (of possibly different types such as clients and servers) that interact by exchanging messages
via an arbitrary,potentially faulty or adversarial environment. Such systems exhibitcomplex con-
current behaviors. In this setting, a componentâ€™s program specification prescribes its state changes
as well as its I/O behavior and is called an I/O specification . We employ an existing encoding of I/O
specifications into a separation logic, which supports both of these aspects [ Penninckx et al .2015].
Thisencodingisapplicabletoanylogicofferingstandardseparationlogicfeatures,andcanthusbe
used to verify components with mutable heap datastructures, concurrency, and other features of
realisticprogramminglanguagesthatenableefficient implementations.
Abstract system model
Protocol modelStepwise reï¬nement
Interface modelStepwise reï¬nement
Component 
model
Environment 
modelDecomposition
Component 
model
I/O 
speciï¬cationTranslation
I/O 
speciï¬cation
Component 
codeCode veriï¬cation
Component 
codeStep 1
Step 2
Step 3
Step 4
Step 5
Step 6
Fig. 1. The main steps of our approach.Approach. Our methodology consists of six main
steps, illustrated in Figure 1. All steps come
with formal guarantees to soundly link the ab-
stractmodelswiththecode.Thefirstfivesteps
are formalized in Isabelle/HOL [ Nipkow et al .
2002].Step 1requires formalizing an initial ab-
stract model of the entire system and proving de-
siredtraceproperties.Thismodelandsubsequent
models are expressed as event systems (i.e., la-
beled transition systems) in a generic refinement
frameworkthatweimplementedinIsabelle/HOL.
Step 2develops a protocol model, which con-
tains the components of the distributed system
tobedevelopedaswellasassumptionsaboutthe
communicationnetwork. This environment may,
for instance, include a fault model or an attacker
model, which can be used to prove properties
aboutfault-tolerantorsecuresystems.Sofar,this
is standard development by refinement, but Steps 3-5 are specific to our approach. Step3prepares
themodelforasubsequentdecompositionandrefinestheinterfacesofthecomponentsandthe
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:4 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
environment to match the interfaces of the I/O libraries to be used in the implementations. Step 4
decomposesthe, sofarmonolithic,modelintomodelsoftheindividualsystemcomponents(e.g.,
clientsandservers)andtheenvironment. Step5translateseachcomponentâ€™seventsystemintoan
I/O specification, which formalizes its valid I/O behaviors. We express thisspecification asanen-
codingintostandardseparationlogicassertionsthatcandescribesequencesofcallstoI/Olibraries,
e.g., for sending and receiving messages [ Penninckx et al .2015]. Each such call corresponds to one
eventofthecomponentâ€™seventsystem.Finally, Step6isstandardcodeverificationofthedifferent
system components,albeitwith I/Ospecifications.Thisstepcanbe performed usingan embedding
ofaseparationlogicintoaninteractive theoremprover(to obtainfoundationalguarantees)orby
using separate dedicated program verifiers (to increase automation). For the latter, any existing
verifiersupportingstandardseparationlogicfeaturescanbeusedwithoutrequiringchangestothe
tool,provideditsatisfiesour verifierassumption .ThisassumptionstatesthatprovingaHoaretriple
involving the I/O specification in the tool implies that the programâ€™s I/O behavior refines the one
definedbytheI/Ospecification.Crucially,ourapproachsupportsmodularreasoninginthatthe
verificationofacomponentâ€™scodedoesnotinvolvereasoningaboutthesystemâ€™sglobalproperties,
othercomponents,ortheenvironment.Moreover,wecanemploydifferentcodeverifierstosupport
heterogeneousimplementations,wheredifferentcomponentsarewrittenindifferentlanguages,
and some aresequential, whileothersuse localconcurrencyforimprovedperformance.
Our approach ensures that the resulting distributed systemâ€™s implementation does not abort due
toruntimeerrorsandsatisfies,byvirtueofcompositionalrefinement,therequirementsspecified
andprovedfortheformalmodels.Theseguaranteesassumethattherealenvironment,includingthe
I/O libraries and the lower software and hardware layers, conforms to our environment model, the
components are correctly instantiated, and the verification tools used are sound. As our approach
Å‚gluesÅ¾together modelsand code throughtheirI/O behavior, wehavedubbeditÅ‚IglooÅ¾.
Contributions. Ourwork makesthefollowing contributions:
(1)Methodology: Wepresentanovelmethodologyforthesoundend-to-endverificationofdis-
tributedsystemsthatcombinestherefinementofexpressiveglobalsystemspecificationswith
programverificationbasedonexpressiveseparationlogics.Thiscombinationsupportsthever-
ification of system-wide properties and handles heap data structures, concurrency, and other
language features required for efficient code. Our methodology enables the sound interoper-
ability of interactive theorem provers with existing code verifiers for different programming
languages,and theverifiedinteroperability of theresultingcomponent implementations.
(2)Theory:Weestablishanovel,formallinkbetweeneventsystemmodelsandI/Ospecifications
forprogramsexpressedinseparationlogicsbyrelatingbothofthemtoaprocesscalculus.
Thislinkbetweenthesedisparateformalizationsiscentraltoourmethodologyâ€™ssoundness.It
isalsointerestinginitsownrightsinceitshowshowtoformallyintegratethetracesemantics
of eventsystems and processes with thepermissionsmanipulatedbyseparation logics.
(3)Casestudies: Wedemonstratethefeasibilityofourapproachbydevelopingformalmodels
for a leader election protocol, a replication protocol, and a security protocol, deriving I/O
specifications for their components, and verifying independent implementations in Java and
Python,usingtheVeriFast[ Jacobset al.2011 ]andNagini[ EilersandMÃ¼ller2018 ]verifiers.
Some of thesecomponentsâ€™performanceisoptimizedusing locallyconcurrentexecution.
(4)Formalization: AllourdefinitionsandresultsareformalizedandproveninIsabelle/HOL.This
includes the refinement frameworkand its soundness, the formalization of I/O specifications,
the soundness proof that formally links event systems, processes, and I/O specifications, and
Steps1Å›5ofourcasestudies.Thisfoundationalapproachyieldsstrongsoundnessguarantees.
Ourframework, Igloo, and our casestudies areavailable online [ Sprenger et al. 2020b ].
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:5
Table 1.Summaryof notation.
1,B,N{â€¢},{true,false},naturals
ğ´Ã—ğµcartesianproduct
(|ğ‘¥âˆˆğ´,ğ‘¦âˆˆğµ|)recordswithfields ğ‘¥andğ‘¦
ğ´âŠğµdisjointunion (sum)
ğ´âŠ¥ =ğ´âŠ{âŠ¥}
ğ´â†’ğµ,ğ´â‡€ğµtotalandpartialfunctions
P(ğ´)powerset
ğ´âˆ—finitesequences
ğ´#multisets, =ğ´â†’Nâˆª{âˆ}(|ğ‘¥=ğ‘,ğ‘¦=ğ‘|)concrete record
ğ‘¥(ğ‘Ÿ),ğ‘Ÿ(|ğ‘¥:=ğ‘£|)recordfield ğ‘¥,update
ğ‘“(ğ‘¥â†¦â†’ğ‘£),ğ‘“âˆ’1function update,inverse
ğœ–,ğ‘ğ‘ğ‘orâŸ¨ğ‘,ğ‘,ğ‘âŸ©empty,concrete sequence
ğ‘¥Â·ğ‘¦ concatenation
len(ğ‘¥),ğ‘¥(ğ‘–)length,ğ‘–-th value
{ğ‘,ğ‘,ğ‘,ğ‘}#concrete multiset
ğ‘€+#ğ‘€â€²multisetsum
âˆ…#,ğ‘âˆˆ#ğ‘€{}#,ğ‘€(ğ‘)>0
2 PRELIMINARIES
Although we formalize our development in Isabelle/HOL, we use standard mathematical notation
wherepossibleto enhancereadability. Table 1summarizes our notation.
2.1 EventSystems,Refinement,and ParallelComposition
2.1.1 Event Systems. Anevent system is a labeled transition system E=(ğ‘†,ğ¸,âˆ’ â†’), whereğ‘†is a set
of states, ğ¸is a set of events, and âˆ’ â†’ âŠ†ğ‘†Ã—ğ¸Ã—ğ‘†is the transition relation. We also write ğ‘ ğ‘’âˆ’ â†’ğ‘ â€²
for(ğ‘ ,ğ‘’,ğ‘ â€²) âˆˆ âˆ’ â†’.Weextendthetransitionrelationstofinitesequencesofevents ğœbyinductively
defining, for all ğ‘ ,ğ‘ â€²,ğ‘ â€²â€²âˆˆğ‘†,ğ‘ ğœ–âˆ’ â†’ğ‘ andğ‘ ğœÂ·âŸ¨ğ‘’âŸ©âˆ’ âˆ’âˆ’âˆ’ â†’ğ‘ â€²â€², whenever ğ‘ ğœâˆ’ â†’ğ‘ â€²andğ‘ â€²ğ‘’âˆ’ â†’ğ‘ â€²â€². Given a set of
initial states ğ¼âŠ†ğ‘†, atraceof an event system Estarting in ğ¼is a finite sequence ğœsuch that ğ‘ ğœâˆ’ â†’ğ‘ â€²
forsomeinitialstate ğ‘ âˆˆğ¼andreachablestate ğ‘ â€².Wedenoteby traces(E,ğ¼)thesetofalltracesof E
startingin ğ¼.Forsingletonsets ğ¼={ğ‘ },wealsowrite traces(E,ğ‘ ),omittingbrackets.Wecallaset
of tracesğ‘ƒoverğ¸atraceproperty and write E,ğ¼|=ğ‘ƒiftraces(E,ğ¼) âŠ†ğ‘ƒ.
Forconcretespecifications,weoftenuse guardedeventsystems oftheform G=(ğ‘†,ğ¸,ğº,ğ‘ˆ)where
ğºandğ‘ˆdenote the ğ¸-indexed families of guardsğºğ‘’:ğ‘†â†’Bandupdatefunctions ğ‘ˆğ‘’:ğ‘†â†’ğ‘†.
The associated transition relation is âˆ’ â†’={(ğ‘ ,ğ‘’,ğ‘ â€²) |ğºğ‘’(ğ‘ ) âˆ§ğ‘ â€²=ğ‘ˆğ‘’(ğ‘ )}. Ifğ‘†=(|Â¯ğ‘¥âˆˆÂ¯ğ‘‡|)is a
record, we use the notation e:ğºe(Â¯ğ‘¥)âŠ²Â¯ğ‘¥:=ğ‘ˆğ‘’(Â¯ğ‘¥)to specify events. For example, the event
dec(ğ‘):ğ‘§>ğ‘âŠ²ğ‘§:=ğ‘§âˆ’ğ‘decreases ğ‘§bytheparameter ğ‘providedthattheguard ğ‘§>ğ‘holds.
2.1.2 Refinement. Giventwoeventsystems, Eğ‘–=(ğ‘†ğ‘–,ğ¸ğ‘–,âˆ’ â†’ğ‘–)andsetsofinitialstates ğ¼ğ‘–âŠ†ğ‘†ğ‘–for
ğ‘–âˆˆ {1,2}, we say that (E2,ğ¼2)refines(E1,ğ¼1)modulo a mediator function ğœ‹:ğ¸2â†’ğ¸1, written
(E2,ğ¼2) âŠ‘ğœ‹(E1,ğ¼1), ifthereisa simulation relation ğ‘…âŠ†ğ‘†2Ã—ğ‘†1such that
(1) foreach ğ‘ 2âˆˆğ¼2thereexistssome ğ‘ 1âˆˆğ¼1such that (ğ‘ 2,ğ‘ 1) âˆˆğ‘…, and
(2)for allğ‘ 1âˆˆğ‘†1,ğ‘ 2,ğ‘ â€²
2âˆˆğ‘†2andğ‘’2âˆˆğ¸2such that (ğ‘ 2,ğ‘ 1) âˆˆğ‘…andğ‘ 2ğ‘’2âˆ’ â†’2ğ‘ â€²
2there exists some
ğ‘ â€²
1âˆˆğ‘†1such that ğ‘ 1ğœ‹(ğ‘’2)âˆ’ âˆ’âˆ’âˆ’ â†’1ğ‘ â€²
1and(ğ‘ â€²
2,ğ‘ â€²
1) âˆˆğ‘….
This is standard forward simulation [ Lynch and Vaandrager 1995 ], augmented withthe mediator
function ğœ‹, which allows us to vary the events in a refinement. We assume that all models Ein
our developments include a special stuttering event skipâˆˆğ¸, defined by ğ‘ skipâˆ’ âˆ’âˆ’ â†’ğ‘ ; consequently,
the trace properties traces(E,ğ¼)are closed under the addition and removal of skipto traces. Events
thatareaddedina refinement stepoften refine skip.
Weproveastandardsoundnesstheoremstatingthatrefinementimpliestraceinclusion.This
traceinclusioninturnpreservestraceproperties(modulothemediator ğœ‹).Here,ğœ‹isappliedto
eachelementofeachtraceand ğœ‹âˆ’1(ğ‘ƒ1)consistsofalltracesthatmapelement-wisetoatracein ğ‘ƒ1.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:6 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
Theorem2.1. (E2,ğ¼2) âŠ‘ğœ‹(E1,ğ¼1)impliesğœ‹(traces(E2,ğ¼2)) âŠ†traces(E1,ğ¼1).
Lemma 2.2. SupposeE1,ğ¼1|=ğ‘ƒ1andğœ‹(traces(E2,ğ¼2)) âŠ†traces(E1,ğ¼1).ThenE2,ğ¼2|=ğœ‹âˆ’1(ğ‘ƒ1).
Forcomplexormulti-levelrefinements,itmaybeadvisabletoreformulatetheintendedprop-
ertyğ‘ƒ1at theconcretelevel as ğ‘ƒ2and provethat ğœ‹âˆ’1(ğ‘ƒ1) âŠ†ğ‘ƒ2, which implies E2,ğ¼2|=ğ‘ƒ2.
2.1.3 ParallelComposition. Giventwoeventsystems, Eğ‘–=(ğ‘†ğ‘–,ğ¸ğ‘–,â†’ğ‘–)forğ‘–âˆˆ {1,2},asetofevents
ğ¸, and a partial function ğœ’:ğ¸1Ã—ğ¸2â‡€ğ¸, we define their parallel composition E1âˆ¥ğœ’E2=(ğ‘†,ğ¸,â†’),
whereğ‘†=ğ‘†1Ã—ğ‘†2and(ğ‘ 1,ğ‘ 2)ğ‘’âˆ’ â†’ (ğ‘ â€²
1,ğ‘ â€²
2)iff there exist ğ‘’1âˆˆğ¸1andğ‘’2âˆˆğ¸2such that ğœ’(ğ‘’1,ğ‘’2)=ğ‘’,
ğ‘ 1ğ‘’1âˆ’ â†’ğ‘ â€²
1, andğ‘ 2ğ‘’2âˆ’ â†’ğ‘ â€²
2. We define the interleaving composition E1/interleaveE2=E1âˆ¥ğœ’ğ¼E2, where
ğ¸=ğ¸1âŠğ¸2andğœ’ğ¼(ğ‘’1,skip)=ğ‘’1,ğœ’ğ¼(skip,ğ‘’2)=ğ‘’2, andğœ’ğ¼(ğ‘’1,ğ‘’2)=âŠ¥ifskipâˆ‰{ğ‘’1,ğ‘’2}.
Wecanalsodefineacompositiononsetsoftraces.Fortwotraceproperties ğ‘‡1andğ‘‡2overevents
ğ¸1andğ¸2, a set of events ğ¸, and a partial function ğœ’:ğ¸1Ã—ğ¸2â‡€ğ¸, we define ğœâˆˆğ‘‡1âˆ¥ğœ’ğ‘‡2iff there
existğœ1âˆˆğ‘‡1andğœ2âˆˆğ‘‡2such that len(ğœ1)=len(ğœ2)=ğ‘™ğ‘’ğ‘›(ğœ)and, for0â‰¤ğ‘–<len(ğœ), we have
ğœ’(ğœ1(ğ‘–),ğœ2(ğ‘–))=ğœ(ğ‘–). We can then prove the following composition theorem (Theorem 2.3), which
enablescompositionalrefinement(Corollary 2.4),wherewecanrefineindividualcomponentswhile
preservingtraceinclusionforthecomposedsystem.Similarresultsexistedpreviously(see,e.g.,
[Silvaand Butler 2010 ]), but wehavegeneralizedthemand formalizedthemin Isabelle/HOL.
Theorem2.3(Compositiontheorem). traces(E1âˆ¥ğœ’E2,ğ¼1Ã—ğ¼2)=traces(E1,ğ¼1) âˆ¥ğœ’traces(E2,ğ¼2).
Corollary2.4(Compositionalrefinement). Supposetraces(Eâ€²
ğ‘–,ğ¼â€²
ğ‘–) âŠ†traces(Eğ‘–,ğ¼ğ‘–)forğ‘–âˆˆ {1,2}.
Then traces (Eâ€²
1âˆ¥ğœ’Eâ€²
2,ğ¼â€²
1Ã—ğ¼â€²
2) âŠ†traces(E1âˆ¥ğœ’E2,ğ¼1Ã—ğ¼2).
2.2 I/O Specifications forSeparation Logic
To satisfy the versatility and expressiveness requirements stated in the introduction, we use a
verificationtechniquethatworkswith anyseparationlogicthatoffersafewstandardfeatures.This
approach supports a wide range of programming languages, program logics, and verification tools.
Webuildontheworkby Penninckxetal .[2015],whichemploysstandardseparationlogicto
verify possibly non-terminating reactive programs that interact with their environment through a
setofI/OoperationscorrespondingtoI/Olibraryfunctions.Theyintroduceanexpressiveassertion
language for specifying a programâ€™s allowed I/O behavior, including sequential, non-deterministic,
andconcurrentI/Obehavior.Thislanguagecanbeencodedintoanyseparationlogicwithstandard
featuressuchasabstractpredicates[ ParkinsonandBierman2005 ].Consequently,ourapproach
inherits the virtues of these logics, for instance, local reasoning and support for language features
such as mutable heap data structures and concurrency (including fine-grained and weak-memory
concurrency).Inparticular,ourapproachleveragesexistingprogramverificationtoolsforseparation
logic, such as VeriFast [ Jacobs et al .2011] (for Java and C), Nagini [ Eilers and MÃ¼ller 2018 ] (for
Python), and GRASShopper[ Piskac et al. 2013 ], and benefits from theautomation they offer.
Syntax.We assume a given set of (basic) I/O operations ğ‘ğ‘–ğ‘œâˆˆBiosand countably infinite sets of
valuesğ‘£,ğ‘¤âˆˆValuesand places ğ‘¡,ğ‘¡â€²âˆˆPlaces. The setof chunksisdefinedby
Chunks::=bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡â€²) |token(ğ‘¡),
wherebioâˆˆBios,ğ‘¡,ğ‘¡â€²âˆˆPlaces,andğ‘£,ğ‘¤âˆˆValues. Wecallachunkoftheform bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡â€²)anI/O
permission toinvoketheoperation ğ‘ğ‘–ğ‘œwithoutput ğ‘£,whosesourceandtargetplacesare ğ‘¡andğ‘¡â€²,
respectively,andwhich predictsreceivingtheinputvalue ğ‘¤.Notethatinputandoutputarefromthe
perspectiveofthecallingsystemcomponent,nottheenvironment:forexample, send(ğ‘¡1,12,0,ğ‘¡2)
models a permission to send the value 12(output) and a prediction that the obtained result will
be0(input). A chunk of the form token(ğ‘¡)is called a tokenat placeğ‘¡. Intuitively, the places and
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:7
I/Opermissions form the nodes and edges of a multigraph. Allowed I/O behaviors are obtained by
pushing tokensalongtheseedges,which consumesthecorresponding I/O permissions.
The language of assertions, intended to describe multisets of chunks representing possibly
non-terminating behavior, isco-inductivelydefined(indicatedbythesubscript ğœˆ)by
ğœ™::=ğœˆğ‘|ğ‘|ğœ™1â˜…ğœ™2| âˆƒğ‘£. ğœ™| âˆƒğ‘¡.ğœ™,
whereğ‘âˆˆB,ğ‘âˆˆChunks,ğœ™1â˜…ğœ™2istheseparatingconjunction,andthetwoexistentialquantifiersare
onvalues ğ‘£âˆˆValuesandplaces ğ‘¡âˆˆPlaces,respectively.Inseparationlogic,chunkscanbemodeled
using abstract predicates; all other assertions are standard. In our Isabelle/HOL formalization, we
use a shallow embedding of assertions. Disjunction is encoded using existential quantification.
We borrow other constructs such as the conditional Å‚ ifğ‘thenğœ™1elseğœ™2Å¾, variables, and functions
operating on values from the meta-language, namely, Isabelleâ€™s higher-order logic. We also call
assertions I/O specifications to emphasize theiruse asprogram specifications.
Example 2.5. The following I/O specification allows receiving an integer and subsequently
sending thedoubledvalue.
ğœ™=token(ğ‘¡)â˜…(âˆƒğ‘¥,ğ‘¡â€²,ğ‘¡â€²â€².recv(ğ‘¡,ğ‘¥,ğ‘¡â€²)â˜…send(ğ‘¡â€²,2ğ‘¥,ğ‘¡â€²â€²)).
Sincethe inputvalue ğ‘¥isexistentiallyquantifiedandunconstrained,thereisno predictionabout
the value that will be received. Here, we use I/O permissions performing only input ( recv) or only
output(send)insteadofboth.Forsuchpermissions,weelidetheirrelevantargument,implicitly
setting itto a default valueliketheunit â€¢. The singletokenpointsto thesourceplace ğ‘¡ofrecv.
NotethatI/OspecificationsuseplacestodeterminetheexecutionorderofI/Ooperationswithout
requiring specific program logic support beyond normal separation logic. For example, sequential
composition and choice are expressed by using separate chunks that share source or target places.
DeterminingwhetheranI/Ooperationmaybeperformedisthusassimpleascheckingwhether
thereisapermissionwithatokenatitssourceplace.Otherapproachesrequirecustomspecification
constructs and custom logics to express this (e.g., Koh et al.[2019];Oortwijn and Huisman [2019]).
Repeating behavior. The co-inductive definition of assertions allows us to define formulas co-
recursively.Forconsistency,Isabelle/HOLrequiresthatco-recursivecallsare productive [Blanchette
et al.2017], namely, guarded by some constructor, which is the case for all of our co-recursive
definitions.Forexample,foracountablesetofvalues ğ‘†,wedefinetheiteratedseparatingconjunction
âˆ€â˜…ğ‘£âˆˆğ‘†.ğœ™. Wecan alsoco-recursivelydefine possibly non-terminating I/O behavior.
Example 2.6. The assertion ğœ™=token(ğ‘¡)â˜…RS(ğ‘¡,0)specifies the behavior of repeatedly receiving
inputsand sending theirsum, aslong asthereceivedvaluesarepositive.
RS(ğ‘¡,ğ‘)=ğœˆâˆƒğ‘§,ğ‘¡â€²,ğ‘¡â€²â€².recv(ğ‘¡,ğ‘§,ğ‘¡â€²)â˜…ifğ‘§>0thensend(ğ‘¡â€²,ğ‘+ğ‘§,ğ‘¡â€²â€²)â˜…RS(ğ‘¡â€²â€²,ğ‘+ğ‘§)else true.
Here,theparameters ğ‘¡andğ‘ofRSrepresentthecurrentstate.Sincethisisaco-recursivedefinition,
itincludes thenon-terminating behaviors whereall receivedvaluesarestrictlypositive.
Semantics. Assertions have both a static semantics in terms of multisets of chunks and a transition
semanticsforwhichwehavegivenanintuitionabove.Thisintuitionsufficestounderstandour
methodology. Wethereforedefer thedefinitionof theformalsemantics to Section 5.1.
3 IGLOOMETHODOLOGY
Inthissection,wepresentourapproachfordevelopingfullyverifieddistributedsystems,which
satisfiestherequirementssetoutintheintroduction.Ourapproachappliestoanysystemwhose
components maintain a local state and exclusively communicate over an environment such as
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:8 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
a communication network or a shared memory system. There are neither built-in assumptions
about the number or nature of the different system components nor about the environment. In
particular, the environmentmay involvefaultyor adversarial behavior. Wealso support different
programming languages and code verifiers for the implementation and the interoperability of
heterogenous components written in different languages. This versatility is enabled by separating
themodeling and implementation side and using I/O specificationsto linkthem.
Aftergivinganoverviewofourmethodology(Section 3.1)andthedistributedleaderelection
protocol case study (Section 3.2), we explain our methodologyâ€™s steps and illustrate them by
transforming an informal, high-level description of the system and its environment into real-world
implementations in Java and Python with formal correctness guarantees (Sections 3.3Å›3.8). We
summarize our approachâ€™s soundness arguments (Section 3.9): trace properties established for the
modelsarepreserveddowntotheimplementationprovidedthatourtrustassumptions(Section 3.10)
hold. Wecurrently supporttheverification of safety properties,but not livenessproperties.
3.1 Overview ofFormalDevelopment Steps
Before we start a formal development, we must identify the system requirements and the assump-
tions about the environment. The system requirements include the (informally stated) goals to
be achieved by the system and structural constraints such as the types of its components. The
environmentassumptionsdescribethepropertiesoftheenvironment,includingcommunication
channels (e.g.,asynchronous, lossy, reordering channels), the typesofcomponentfaultsthat may
occur(e.g.,crash-stoporByzantine[ Cachinetal .2011]),andpossibleadversarialbehavior(e.g.,
theDolev-Yao model of an activenetwork adversary [ Dolev and Yao 1983 ]).
Our methodology consists of six steps (cf. Figure 1). In Steps 1Å›2, we use standard refinement to
developa detailed modelofthe systemand its environment.Thenumber ofrefinementsper stepis
not fixed. Each refinement is proven correct and may incorporate additional system requirements.
(1)Abstract models . We start with an abstract model that takes a global perspective on the
problem.It maysolve theproblem ina single transition.Typically, the mostcentral system
properties are already established for this model, or the abstract models that further refine it.
(2)Protocolmodels .Wethenmovefromtheglobaltoadistributedview,wherenodesexecute
a protocol and communicate over the environment. The result of this step is a model that
incorporates all systemrequirements and environment assumptions.
In Steps 3Å›6, we produce an interface model from which we can then extract component specifi-
cations,implement thecomponents,and verify thatthey satisfy theirspecifications.
(3)Interfacemodels .Wefurtherrefinetheprotocolmodelforthesubsequentdecompositioninto
systemcomponentsandtheenvironment,takingintoaccounttheI/Olibraryinterfacestobe
usedbytheimplementation.
(4)Decomposition. Wedecomposethemonolithicinterfacemodel intosystemcomponentsand
theenvironment. Theirre-composition istrace-equivalentwith themonolithic model.
(5)ComponentI/Ospecification. Wetranslatethecomponentmodelsintotrace-equivalentI/O
specifications(inseparation logic)of theprogramsthatimplement thecomponents.
(6)Component implementation and verification. We implement the components in a suitable
programminglanguage and provethatthey satisfy theirI/O specification.
Steps 1Å›4 are supported by a generic refinement and composition framework that we have
embeddedinIsabelle/HOL(seeSections 2.1and3.6).Steps3Å›5arenovelandspecifictoourapproach.
In Steps 3 and 4, we align our modelsâ€™ events with the implementationâ€™s I/O library functions and
thenseparatetheinterfacemodelintoasetofpossiblyheterogeneoussystemcomponents(e.g.,
clients and servers) and theapplication-specific environment(e.g.,modelingaparticularnetwork
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:9
semantics,faulty,or adversarial behavior).Step5constitutesoneofthe core contributionsof our
approach: a sound link between abstract models and I/O specifications in separation logic, also
formalizedinIsabelle/HOL.ItwillbeintroducedinformallyhereandformalizedinSection 5.Step6
corresponds to standard code verification, using tools such as Nagini (for Python) and VeriFast
(for Java and C). Due to our clear separation of modeling and implementation, the code verifier
must check only that a component implementation follows the protocol; code verification neither
needs to reason about the protocolâ€™s global properties nor about the environment, which simplifies
verificationandincreasesmodularity. InSection 3.9,wewillderivetheoverallsoundnessofour
methodologyfrom theindividual stepsâ€™ guarantees,which aresummarizedin Table 2.
Our three case studies demonstrate the versatility and expressiveness of our approach. We cover
different types of systems, including fault-tolerant and secure ones, different component types
withunboundednumbersofinstances,andTCPandUDPcommunication.Wehavewrittenand
verifiedimplementationsinPythonandJava,includingconcurrentones.Thissectionillustrates
our approach using the leader election case study; the other case studies are presented in Section 4.
3.2 Case Study:LeaderElection
The main requirement of a distributed leader election protocol is to elect at most one leader in
a network of uniquely identified but otherwise identical nodes, whose total number is a priori
unknown. Since we do not consider liveness properties in this work, we do not prove that the
protocolwill terminate withan electedleader.
We model an algorithm by Chang and Roberts [1979], which assumes a ring network and a
stricttotalorderonthesetofnodeidentifiers.Thealgorithmelectsthenodewiththemaximum
identifier as follows. Each node initially sends out its identifier to the next node in the ring and
subsequently forwards all received identifiers greater than its own. When a node receives its own
identifier, this is guaranteed to be the maximum identifier in the ring, and the node declares itself
the leader. For the environment, we assume that each node asynchronously sends messages to the
next nodein the ringover anunreliable, duplicating,andreordering channel. We do not consider
other faults or adversarial behaviorinthis example, but seeSection 4forcasestudies thatdo.
3.3 Step1: Abstract Models
Acommonapproachtodevelopsystemsbyrefinementistostartfromaveryabstractmodelwhose
correctnessiseitherobviousorcanbeprovedbyasetofsimpleinvariantsorothertraceproperties.
This model takes a global Å‚birdâ€™s eyeÅ¾ view of an entire run of the protocol in that it does not
explicitlymodel thenetwork communicationor representtheindividual protocolsteps.
Example3.1. TheabstractmodelofleaderelectionelectsaleaderinasingleÅ‚one-shotÅ¾transition.
Weassumeagivenset IDofnodeidentifiers.Themodelâ€™sstatespaceisdefinedasan ID-indexed
family of local states containing a single boolean state variable identifying the leader, i.e., ğ‘†0=
IDâ†’ (|leaderâˆˆB|).Initially, leader(ğ‘ 0(ğ‘–))=false, for allğ‘–âˆˆID. There is a singleevent electthat
elects the leader. The guard ensures that this event can be performed only by a single, initially
arbitrary node thatupdatesits localvariable leadertotrue.
elect(ğ‘–):(âˆ€ğ‘—.leaderğ‘—â‡’ğ‘–=ğ‘—)âŠ²leaderğ‘–:=true.
Weuseindexingtorefertodifferentinstancesofvariables,e.g., leaderğ‘—referstonode ğ‘—â€™slocalstate.
Note that the guard refers to other nodesâ€™ local states; hence, this model takes a global point of
view.Wehaveprovedthatthismodelsatisfiesthemainrequirementforleaderelection,namely,
theuniqueness of theleader. This isformalizedasthetrace property
ğ¿0={ğœ| âˆ€ğ‘–, ğ‘—.elect(ğ‘–) âˆˆğœâˆ§elect(ğ‘—) âˆˆğœâ‡’ğ‘–=ğ‘—},
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:10 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
whereğ‘’âˆˆğœmeans that the event ğ‘’occurs in the trace ğœ. This model is sufficiently abstract to
specifyanyleaderelectionalgorithm,and will berefinedto theprotocoldescribedabovenext.
3.4 Step2: Protocol Models
In Step 2, we move from a global to a distributed perspective, and distinguish system components
(e.g., nodes or clients and servers) that communicate over an environment (e.g., a wide-area
network). The way that we model the environment accounts for any assumptions made about
network communication. For example, we can represent a reliable, non-duplicating, reordering
channelasamultisetofmessages.Thisstepmayalsointroduceafailuremodelforfault-tolerant
systemsoranadversarymodelforsecuresystems.Theresultofthisstepisacompletemodelof
our systemand environment thatsatisfiesall systemrequirements.
Example3.2. Werefineourabstractmodelintoaprotocolmodel.Wemodeltheenvironment
by assuming a finite, totally ordered set of identifiers IDand that the nodes are arranged in a
ringdefinedbyafunction next:IDâ†’ID,wherenext(ğ‘–)yieldsnode ğ‘–â€™ssuccessor inthering. We
extend the state with communication channels, which we model as sets, from which messages
areneverremoved;thisrepresentsourassumptionthatthenetworkmayreorderandduplicate
messages. Since we do not consider liveness properties, message loss is implicitly represented
byneverreceivingamessage.Sincemessagescontainnodeidentifiers,ourstatespacebecomes
ğ‘†1=IDâ†’ (|leaderâˆˆB,chanâˆˆP(ID) |).
Threeeventsmodeltheprotocolsteps:a setupeventwherenodessendtheirownidentifierto
the next node in the ring, an acceptevent where they forward received identifiers greater than
theirown, and an electeventwherea node receiving its ownidentifier declaresitself theleader.
setup(ğ‘–):true âŠ²channext(ğ‘–):=channext(ğ‘–)âˆª{ğ‘–}
accept(ğ‘–, ğ‘—):ğ‘—âˆˆchanğ‘–âˆ§ğ‘—>ğ‘–âŠ²channext(ğ‘–):=channext(ğ‘–)âˆª{ğ‘—}
elect(ğ‘–):ğ‘–âˆˆchanğ‘– âŠ²leaderğ‘–:=true
We have proved that this protocol model refines the abstract model defined in Example 3.1. For
thisweusethesimulationrelationthatremovesthefield chanfromthelocalstateandthemediator
function that maps electto itself and the newevents to skip. The proof involvesshowing that the
guardofthismodelâ€™s electeventimpliestheguardoftheabstractmodelâ€™s electevent.Weprove
two invariants that together imply this. The first one is inductive and states that if a node ID ğ‘–is in
the channelof node ğ‘—thenğ‘˜<ğ‘–for allnodeIDs ğ‘˜inthechannels intheringinterval from ğ‘–toğ‘—.
From this it follows that if ğ‘–âˆˆchanğ‘–thenğ‘–is the maximal node ID. The second invariant expresses
thatonlythenode withthemaximal node IDcan become a leader.
3.5 Step3: Interface Models
This is the first step towards an implementation. Its purpose is twofold: first, we prepare the model
for the subsequent decomposition step(Step 4) and,second, we align the I/O eventswith the API
functions of the I/O libraries to be used in the implementation. The resulting interface model must
satisfy thefollowing structural interfacerequirements :
(1)The state space is a product of the componentsâ€™ local state spaces and the environmentâ€™s
state space. The events are partitioned into I/O events , which model the communication with
theenvironment, and internal events , which model localcomputations.
(2)EachI/OeventcanbeassociatedwithasingleI/Olibraryfunction(e.g.,receivingorsendinga
messageonasocket,butnotboth).Itmusthavethesameparametersasthatlibraryfunction,
eachofwhichcanbeidentifiedasanoutputparameter(e.g.,themessagetosend)oraninput
parameter(e.g., an error code returnedasa result).
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:11
setupğ‘–():true âŠ²obufğ‘–:=obufğ‘–âˆª{ğ‘–}
receiveğ‘–(ğ‘—):ğ‘—âˆˆchanaddr(ğ‘–) âŠ²ibufğ‘–:=ibufğ‘–âˆª{ğ‘—}
acceptğ‘–(ğ‘—):ğ‘—âˆˆibufğ‘–âˆ§ğ‘—>ğ‘– âŠ²obufğ‘–:=obufğ‘–âˆª{ğ‘—}
sendğ‘–(ğ‘—,ğ‘):ğ‘—âˆˆobufğ‘–âˆ§ğ‘=addr(next(ğ‘–))âŠ²chanğ‘:=chanğ‘âˆª{ğ‘—}
electğ‘–():ğ‘–âˆˆibufğ‘– âŠ²leaderğ‘–:=true.
Fig. 2. Event system resulting from interface refinement step.
(3)EachI/O eventâ€™s guardmustbetheconjunction of
â€¢acomponentguard ,which refersonlytothecomponentâ€™slocalstate, theeventâ€™soutput
parameters, and thecomponent identifier, and
â€¢anenvironment guard , referring only to the environmentâ€™s state, the input parameters, and
thecomponent identifier.
Our approach leaves the choice of the abstraction level of the interface modelâ€™s I/O events to the
user. Forexample,theAPIsofnetworksocketlibraries typicallyrepresentpayloadsas bitstrings,
whichtheapplicationmustparseintoandmarshalfromitsinternalrepresentation.Wemaychoose
toeither (i) defineI/O events (andthusI/O operations) thatoperateon bitstrings, which requires
modeling andverifyingparsingandmarshallingexplicitly, or(ii) keeptheirinterfaceonthe level
of parseddataobjects, and trust thatthesefunctionsareimplementedcorrectly.
Example3.3. Werefinetheprotocolmodelintoamodelsatisfyingtheinterfacerequirements.The
protocol modelâ€™s accepteventreceives, processes,and sends amessage.TosatisfyConditions1Å›2
above, we introduce two local buffers, ibufandobuf, for each node and split acceptinto three
events:receivetransfersamessagefromthepreviousnodetotheinputbuffer ibuf,acceptprocesses
a message from ibufand places the result in the output buffer obuf, andsendsends a message
fromobufto thenextnode.
We also align the I/O events sendandreceivewith the I/O operations UDP_send_int(msg,addr)
andUDP_receive_int(msg), which are offered by standard socket libraries. Here, we represent
messages as integers, but as stated above, we could alternatively represent them as bitstrings,
and model parsing and marshalling explicitly (including bounds and endianness), resulting in
strongercorrectnessguarantees.SinceeachI/OeventmustmatchthecorrespondingI/Ooperationâ€™s
parameters(Condition2),we addthesendoperationâ€™sdestinationaddressasaneventparameter.
Hence,weintroduceaninjectivefunction addr:IDâ†’Addr,whereAddristhesetofaddresses.
UDP communication is unreliable and messages sent may be reordered, duplicated, or lost; our
environment model faithfullyrepresents this behaviorbymodeling channelsassets(Section 3.4).
Wedefinethestatespaceastheproduct ğ‘†2=ğ‘†s
2Ã—ğ‘†e
2(Condition 1)of a systemstatespace ğ‘†s
2=
IDâ†’ (|leaderâˆˆB,ibufâˆˆP(ID),obufâˆˆP(ID) |)and an environment state space ğ‘†e
2=Addrâ†’
(|chanâˆˆP(ID) |). The events are specified in Figure 2. We henceforth consider the component
identifier ğ‘–asacomponentparameterandthereforewriteitasasubscriptoftheevent. Only receive
andsendareI/Oevents;allothersareinternal(Condition1).TheseI/Oeventshavetherequired
formandparameters(Condition2)andtheirguardshavetherequiredseparableform(Condition3).
Theparameter ğ‘—ofreceiveistheonlyinputparameterandallothersareoutputs.Thesimulation
relationwiththeprotocolmodelprojectsawaytheinternalbuffers.Themediatorfunctionmaps
electto itself,sendğ‘–(ğ‘—,ğ‘)tosetup(ğ‘–)ifğ‘–=ğ‘—and toaccept(ğ‘–, ğ‘—)otherwise, and all other events to
skip. The refinement proof requires an invariant relating internal buffers to channels, e.g., stating
thatğ‘—âˆˆibufiimpliesğ‘—âˆˆchanaddr(ğ‘–).
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:12 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
3.6 Step4: Decomposition
To support distributed systems with different component types (such as nodes or clients and
servers),wedecomposethemonolithicinterfacemodelfromStep3intotheparallelcomposition
of an environment model and (a family of)component modelsforeach component type.
Wefirstdecomposetheinterfacemodelintoaparallelcomposition E=Esâˆ¥ğœ’Eeofasystem
modelEsand an environment model Ee. We have already distinguished their respective state
spacesğ‘†sandğ‘†ein the interface model. The I/O events ğ‘’ofEare split into a system part ğ‘’s,
consistingof ğ‘’â€™scomponentguardandsystemstateupdates,andanenvironmentpart ğ‘’e,consisting
ofğ‘’â€™senvironmentguardandenvironmentstateupdates.Wedefine ğœ’suchthatitsynchronizes
thesplitI/Oeventsandinterleavestheinternalevents. Thesystemmodelisfurthersubdivided
into models of different component types, which are composed using interleaving composition
Es=Es
1/interleaveÂ·Â·Â·/interleaveEs
ğ‘›.Thisreflectsourassumptionthatthecomponentsexclusivelycommunicatevia
the environment. If there are multiple instances of a component type, parametrized by a countable
index set ğ¼of identifiers, the respective model, say Es
ğ‘˜, becomes an interleaving composition over ğ¼,
thatis, /interleaveğ‘–âˆˆğ¼Es
ğ‘˜(/âŠ‘ecğ›¾ğ‘˜(ğ‘–)).Each componentmodel Es
ğ‘˜(/âŠ‘ecğ‘)mayhavesomeparameters /âŠ‘ecğ‘.We instantiate
theseusinga configurationmap /âŠ‘ecğ›¾ğ‘˜,whichrepresentsassumptionsonthe correctsystemconfiguration .
Notethat component models may be further refined before translating them to I/O specifications.
InpreparationforthesubsequenttranslationtoI/Ospecifications,wemodel(instancesof)system
componentsina subclassof guardedeventsystems.An I/O-guardedeventsystem G=(ğ‘†,ğ¸,ğº,ğ‘ˆ)
is a guarded event system, where ğ¸consists of events of the form bio(ğ‘£,ğ‘¤)(formally introduced as
I/O actions in Section 5.1) and all guards ğºbio(ğ‘£,ğ‘¤)are component guards as in Condition (3), i.e.,
they must not depend on the I/O actionâ€™s input ğ‘¤. This models that an input becomes available
onlyastheresultofanI/OoperationandcannotbeselectedbeforetheI/Ooperationisinvoked.
Furthermore,wemodelacomponentâ€™sinternaleventsas ghostI/Oactions ;theseactionschange
thestateofthe abstractmodel,butdonotcorrespondtoreal I/Ooperations.Theimplementation
may haveto performa corresponding statechangeto stayalignedwith theabstractmodel.
We prove the correctness of the decomposition by showing that the parallel (re)composition of
all parts istrace-equivalentto theoriginalsystem.
Example 3.4. All nodes instantiate the same component type. We thus decompose the model
from the previous step into an environment event system Eeand an I/O-guarded event system
Es(ğ‘–,ğ‘),parametrizedbyanodeidentifier ğ‘–âˆˆIDandanaddress ğ‘âˆˆAddr.Thesewillalsobethe
parameters of the futureprogram ğ‘(ğ‘–,ğ‘)implementing Es(ğ‘–,ğ‘). For the systemâ€™s (re)composition,
we use the configuration map /âŠ‘ecğ›¾(ğ‘–)=(ğ‘–,addr(next(ğ‘–))), which instantiates the destination address
ğ‘forğ‘–â€™soutboundmessageswiththeaddressof ğ‘–â€™ssuccessorinthering. Theenvironmentoperates
on the state ğ‘†e
3=Addrâ†’ (|chanâˆˆP(ID) |)and the state space of each node model Es(ğ‘–,ğ‘)is
ğ‘†s
3=(|leaderâˆˆB,ibufâˆˆP(ID),obufâˆˆP(ID) |). The environment has the following events, where
â€˜âˆ’â€™represents theidentity updatefunction:
receivee(ğ‘–,ğ‘š):ğ‘šâˆˆchanaddr(ğ‘–)âŠ²âˆ’
sende(ğ‘–,ğ‘š,ğ‘):true âŠ²chanğ‘:=chanğ‘âˆª{ğ‘š}.
These events executesynchronously with theirmatchingsystemparts:
receives
ğ‘–,ğ‘(ğ‘š):true âŠ²ibuf:=ibufâˆª{ğ‘š}
sends
ğ‘–,ğ‘(ğ‘š,ğ‘â€²):ğ‘šâˆˆobufâˆ§ğ‘â€²=ğ‘âŠ²âˆ’.
Notethatthe receiveseventâ€™sguarddoesnotdependonitsinputparameter ğ‘šandthesends
ğ‘–,ğ‘eventâ€™s
single output parameter is a pair of a message and an address. The equality ğ‘â€²=ğ‘in the guard of
sends
ğ‘–,ğ‘enforces that messages are sent only to the node at the address ğ‘, which is a component
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:13
ğ‘ƒ(ğ‘¡,(ğ‘–,ğ‘),ğ‘ )=ğœˆ(âˆƒğ‘¡â€².setup(ğ‘¡,ğ‘¡â€²)â˜…ğ‘ƒ(ğ‘¡â€²,(ğ‘–,ğ‘),ğ‘ (|obuf:=obuf(ğ‘ ) âˆª{ğ‘–}|)))â˜…
(âˆƒğ‘š,ğ‘¡â€².UDP_receive_int(t,m,tâ€²)â˜…P(tâ€²,(i,a),s(|ibuf:=ibuf(ğ‘ ) âˆª{ğ‘š}|)))â˜…
(âˆ€â˜…ğ‘š.ifğ‘šâˆˆibuf(ğ‘ ) âˆ§ğ‘–<ğ‘šthenâˆƒğ‘¡â€².accept(ğ‘¡,ğ‘š,ğ‘¡â€²)â˜…
ğ‘ƒ(ğ‘¡â€²,(ğ‘–,ğ‘),ğ‘ (|obuf:=obuf(ğ‘ ) âˆª{ğ‘š}|))else true)â˜…
(âˆ€â˜…ğ‘š,ğ‘â€².ifğ‘šâˆˆobuf(ğ‘ ) âˆ§ğ‘â€²=ğ‘thenâˆƒğ‘¡â€².UDP_send_int(ğ‘¡,(ğ‘š,ğ‘â€²),ğ‘¡â€²)â˜…
ğ‘ƒ(ğ‘¡â€²,(ğ‘–,ğ‘),ğ‘ )else true)â˜…
(ifğ‘–âˆˆibuf(ğ‘ )thenâˆƒğ‘¡â€².elect(ğ‘¡,ğ‘¡â€²)â˜…ğ‘ƒ(ğ‘¡â€²,(ğ‘–,ğ‘),ğ‘ (|leader:=true|))else true).
Fig. 3. I/O specification of leader election nodes.
parameter.Thisisaconstraintonthefutureprogramâ€™suseoftheI/Olibraryfunction.Theinternal
eventssetupğ‘–,ğ‘(),acceptğ‘–,ğ‘(ğ‘š),andelectğ‘–,ğ‘()ofEs(ğ‘–,ğ‘)areghostI/Oactions,whichareidenticalto
their counterparts inthe previous model modulotheir slightly different parametrization.Wehave
provedthatthecomposition of all parts istrace-equivalentto theoriginalmonolithic system.
3.7 Step5: I/O Specifications
We can now perform the central step of our approach: we extract, for each component, an I/O
specification that defines the implementationâ€™s I/O behavior. Our translation maps an I/O-guarded
parametrizedeventsystem Es(/âŠ‘ecğ‘)to an I/O specification of theform
ğœ™(/âŠ‘ecğ‘)=âˆƒğ‘¡.token(ğ‘¡)â˜…ğ‘ƒ(ğ‘¡,/âŠ‘ecğ‘,ğ‘ 0),
whereğ‘ƒisaco-recursivelydefinedpredicateencodingtheeventsand ğ‘ 0istheeventsystemâ€™sinitial
state.1The predicate ğ‘ƒtakes a place ğ‘¡, the event systemâ€™s (and future programâ€™s) parameters /âŠ‘ecğ‘,
and the event systemâ€™s abstract state ğ‘ as arguments. The predicate ğ‘ƒcontains, for each event and
all values of its output parameters satisfying the guard, a permission to execute the I/O operation
representedbytheevent,andanotherinstanceofitselfwiththeargumentrepresentingthenew
state resulting from applying the eventâ€™s update function. This translation is formally defined and
provedcorrectinSection 5. Here, weexplaintheintuitionbehind itusing our example.
Example3.5. Figure3definesthepredicate ğ‘ƒ(ğ‘¡,(ğ‘–,ğ‘),ğ‘ )forourexample,where ğ‘–andğ‘denotethe
local node identifier ğ‘–and the address ğ‘of the next node in the ring. The fourth top-level conjunct
ofğ‘ƒcorresponds to the sends
ğ‘–,ğ‘(ğ‘š,ğ‘â€²)event from the previous step. It states that for all possible
valuesoftheoutputparameter (ğ‘š,ğ‘â€²)thatfulfilltheeventâ€™sguard ğ‘šâˆˆobuf(ğ‘ ) âˆ§ğ‘â€²=ğ‘,thereis
a permission to perform the I/O operation UDP_send_int(which is mapped to the sends
ğ‘–,ğ‘event)
and another instance of ğ‘ƒat the operationâ€™s target place with the same state, since sends
ğ‘–,ğ‘does
not change the local state. The second (simplified) conjunct corresponds to the receives
ğ‘–,ğ‘event and
existentiallyquantifiesovertheeventâ€™sinput parameterand containsanotherpredicateinstance
with an updated state ğ‘ (|ibuf:=ibuf(ğ‘ ) âˆª{ğ‘š}|)as defined by receives
ğ‘–,ğ‘. The remaining conjuncts
correspond to theinternalevents setup,accept, andelect.
1The formal development of our theory (Section 5) is based on event systems with single initial states. This is without loss
ofgenerality sincemultipleinitial statescan easily beintroduced by anon-deterministicinitialization event.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:14 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
def main ( my_id : int , o u t _ h o s t : str ) :
#@ PRE: exists t . token ( t ) and P(t , (my_id , out_host ) , INIT_ STATE)
#@ POST: true
to_send = my_id # variable stores only the largest identifier seen so far
se t u p ( ) # ghost I /O operation
while True :
#@ INVARIANT: exists t , s . token ( t ) and P(t , (my_id , out_hos t ) , s )
#@ INVARIANT: to_send in s . obuf and to_send >= my_id
s e n d _ i n t ( out_host , to_send )
msg = t r y _ r e c e i v e _ i n t ( ) # returns None on timeout
ifmsgis not None :
ifmsgismy_id :
e l e c t ( ) # ghost I /O operation
break
elif msg > to_send :
a c c e p t ( msg ) # ghost I /O operation
to_send = msg
Listing 1. Pseudocode of the leader election algorithm with proof annotations (simplified). The method
try_receive _inttries a receive operation and either returns an identifier or times out and returns None .
3.8 Step6: ComponentImplementation and Verification
In the final step, we prove for every component that its implementation ğ‘fulfills the I/O specifica-
tionğœ™thatwas extractedintheprevious step. This requirement isexpressedas
traces(ğ‘) âŠ†traces(ğœ™), (1)
i.e., the I/O traces of the component implementation ğ‘, as defined by its operational semantics, are
included inthose specified by theI/O specification ğœ™. Here,weelidepossible parameters /âŠ‘ecğ‘of the
programğ‘and the I/O specification ğœ™for the sake of a lighter notation. Since I/O specifications are
language-agnostic,theimplementationmayuseanyprogramminglanguage.Verifying (1)typically
requires defining a suitable I/O-aware semantics of the chosen language that defines the I/O traces
producedbyitsprograms.Weassumethattheverificationtechniqueuseddefinesaninterpretation
ofHoare triplesoftheform |={ğœ™}ğ‘{ğœ“},anda soundprogramlogictoprovethem.We onlyrely
ontheverifier assumption statingthatthe correctness of a commandwith respectto a precondition
implies the trace inclusion between the command and the precondition assertion. Since the I/O
permissions inthe precondition restrictwhich I/O operations may be performed, these triples do
not triviallyhold even thoughthepostcondition is true:
|={ğœ™}ğ‘{true}impliestraces(ğ‘) âŠ†traces(ğœ™). (VA)
OurapproachleavesopenthemechanismforprovingsuchHoaretriples.Inprinciple,proofs
can be constructed using an interactive theorem prover, an SMT-based automated verifier, or even
aspen-and-paperproof.I/Ospecificationsconsistonlyofconstructsthatcanbeexpressedusing
standard separation logic with abstract predicates. This allows us to leverage existing tool support,
in particular, proof automation. For instance, encoding such specifications in VeriFast required less
than25LoCtodeclaretypesforplacesandabstractpredicatesforchunks,andnotoolmodifications.
The I/O specification is (currently manually) converted to the syntax of the respective tool, and
theprogramverifieristhenusedtoprovethecorrectnessoftheprogramwithrespecttoitsI/O
specification. Assuming ( VA)holdsforthetool,this guaranteestherequiredtrace inclusion( 1).
Besides the verification, we must informally justify that the actual programâ€™s I/O operations
satisfytheassumptionsencodedintheenvironmentmodel.Forexample,wemayimplementan
order-preserving network channel modelusing TCP sockets, but not UDP sockets.Conversely, itis
soundto implement an unorderedchannel model using either TCP or UDP communication.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:15
def s e n d _ i n t ( a d d r e s s : str, msg : int ) :
#@ PRE: token (? t ) âˆ— UDP_send_int (t , (msg , address ) , ?tp )
#@ PRE: connected ( this , address )
#@ PRE: 0 <= msg <= MAX_MSG_VAL
#@ POST: token ( tp )
#@ EXCEPTIONAL POST: token ( t ) âˆ— UDP_send_int (t , (msg , addr ess ) , tp )
Listing 2. The simplified pseudocode contract for a library method for sending packets via UDP. The names
starting with question marks are implicitly existentially quantified. connected is a separation logic predicate
that contains the heap memory of a UDP socket object connected to the shown address.
Example 3.6. We have implemented three versions of the leader election algorithm, a sequential
andaconcurrentoneinJavaandasequentialversioninPython,andverifiedinVeriFastandNagini
that these implementations conform to their I/O specification: |={ğœ™(ğ‘–,ğ‘)}main(ğ‘–,ğ‘) {true}. All
threeimplementationsareinteroperable and successfully electa leaderin actual networks.
Listing1shows a slightly simplified pseudocode versionof thesequential implementation; the
Java and Python versionssharethe same structurebut contain additionalannotations asrequired
by the respective verifier. The concurrent version uses two separate threads for receiving and
sending identifiers. We use the standard UDP socket libraries of the respective languages; since the
APIinbothcasesisstructureddifferently,wedefinedtheI/Ooperationsusedinthespecificationto
becompatiblewithboth.WeannotatedtherelevantI/Olibraryoperationswithcontracts,whose
correctnessisassumedand mustbevalidatedmanuallyagainsttheenvironment model.
Listing2shows a simplified pseudocode specification of a message sending function. Its precon-
ditionconsistsofthreetypicalpartsthat(i)specifiytheI/Obehaviorofthisfunctionintermsof
tokensandI/Opermissions,(ii)constraintheprogramstate,inthiscaserequiringthatoursocketis
already connected to the receiver address, and (iii) impose additional restrictions on messages that
donot exist on moreabstractlevels,inthis case, thatthesent messagefalls within a validrange.
SincetheI/Ospecification describes theallowedI/Obehavior in termsofthemodelâ€™s state,the
verificationprocessrequiresrelatingtheprogramtothemodelstate.Thelatterisrepresentedinthe
programasa ghoststate ,whichispresentonlyforverificationpurposes,butnotduringprogram
execution. If the verifier can prove for a given program point that a token for a place ğ‘¡and the
predicate ğ‘ƒ(ğ‘¡,(ğ‘–,ğ‘),ğ‘ )areheldforsomemodelstate ğ‘ ,thismeansthatthecurrentprogramstate
corresponds to the model state ğ‘ . The invocations of the internal operations setup,accept, andelect
in thecode updatetheghost stateto stayalignedwith theprogram state.
Asanoptimization,theimplementationsstoreandforwardonlythelargestidentifierseensofar,
sincesmalleronescanneverbelongtotheleader.Theverifierprovestheloopinvariantthatthis
largest integer isalwaysintheoutputbuffer and may thereforebesent out.
Note that, although we do not prove liveness, our implementation repeatedly resends UDP
packets since packets may be lost. This will continue even after a leader has been elected since our
simple protocoldoesnot includea leaderannouncement phase.
3.9 OverallSoundness Guarantees
Our methodology provides a general wayof proving properties of adistributed system. Table 2
summarizes the soundness guarantees of each step (see also Figure 1). We now show how to
combine them to obtain the overall soundness guarantee that the modelsâ€™ properties are preserved
down to the implementation. Wewillfirst discussthe simplercase with asingleinstanceofeach
component and later extendthis reasoningto multiple instances.
Let our implemented system be defined by S=(C1/interleave.../interleaveCğ‘›) âˆ¥ğœ’ğ‘’Ere,where each Cğ‘—is the
event system defining the operational semantics of ğ‘ğ‘—, i.e.,traces(Cğ‘—)=traces(ğ‘ğ‘—), and suppose
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:16 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
Table 2.Methodoverview withguarantees of eachstep (initial stateselided).
stepsactivity guarantee justification
1Å›3model refinements and Ë†ğœ‹ğ‘–(traces(Mğ‘š)) âŠ†traces(Mğ‘–)ref.Mğ‘–+1âŠ‘ğœ‹ğ‘–+1Mğ‘–
interfacerefinement whereË†ğœ‹ğ‘–=ğœ‹ğ‘šâ—¦Â·Â·Â·â—¦ğœ‹ğ‘–+1Theorem 2.1
4decompose Mğ‘šintotraces(Mğ‘š)= mutual refinement
Es
1,...,Es
ğ‘›, andEetraces((Es
1/interleave.../interleaveEs
ğ‘›) âˆ¥ğœ’ğ‘’Ee)Theorem 2.1
5translate Es
ğ‘—intoğœ™ğ‘—traces(ğœ™ğ‘—)=traces(Es
ğ‘—) Theorems 5.5and5.7
6verify|={ğœ™ğ‘—}ğ‘ğ‘—{true}traces(ğ‘ğ‘—) âŠ†traces(ğœ™ğ‘—) Assumption ( VA)
theeventsystem Erecorrespondstotherealenvironment.FromSteps5Å›6â€™sguaranteeslistedin
Table2,wederive traces(Cğ‘—) âŠ†traces(Es
ğ‘—).Furthermore,weassumethattheenvironmentmodel
faithfullyrepresents therealenvironment, i.e.,
traces(Ere) âŠ†traces(Ee). (EA)
Using Corollary 2.4and Step 4â€™s guarantee, we derive that the implemented systemâ€™s traces
areincludedintheinterfacemodelâ€™straces: traces(S) âŠ†traces(Mğ‘š).UsingLemma 2.2andthe
guarantees of Steps 1Å›3, we derive our overall soundness guarantee stating that any trace property
ğ‘ƒğ‘–of model Mğ‘–ispreservedall theway downto theimplementation:
Mğ‘–|=ğ‘ƒğ‘–=â‡’ S |=Ë†ğœ‹âˆ’1
ğ‘–(ğ‘ƒğ‘–). (SOUND)
Withmultiplecomponentinstances,theeventsystems Es
ğ‘—andCğ‘—havetheformofcompositions
/interleaveğ‘–âˆˆğ¼Es
ğ‘—(/âŠ‘ecğ›¾ğ‘—(ğ‘–))and/interleaveğ‘–âˆˆğ¼Cğ‘—(/âŠ‘ecğ›¾ğ‘—(ğ‘–))for some configuration map /âŠ‘ecğ›¾ğ‘—and we have traces(Cğ‘—(/âŠ‘ecğ‘))=
traces(ğ‘ğ‘—(/âŠ‘ecğ‘))for all parameters /âŠ‘ecğ‘. The guarantees of Step 4 in Table 2hold for these compositions
and those of Steps 5Å›6 for the individual parametrized components. We then easily derive the
guarantee (SOUND)usingatheoremsimilartoCorollary 2.4forindexedinterleavingcomposition.
3.10 TrustAssumptions
The guaranteesdescribedinthelast subsectionhold underthefollowing trust assumptions:
(1)Environmentassumptions: Themodeledenvironmentincludesallpossiblebehaviorsofthe
real systemâ€™s environment, as formulated in Assumption (EA). This means it faithfully
represents the behavior of all real components below the interface of the I/O library used in
the implementation. These may include the I/O library, the operating system, the hardware,
the communication network, as well as potential attackers and link or node failures. Recent
work byMansky et al .[2020] demonstrates how to connect the verification of I/O behavior
to a verified operating system to remove the I/O library and operating system from the trust
assumptions.Theirapproachcouldbeadaptedtooursetting.Otherenvironmentassumptions,
such astheattacker model, remainand cannotbeeliminatedthroughformalproofs.
(2)Correct program configuration: The programs are called with parameters conforming to
the configuration map /âŠ‘ecğ›¾. For instance, our case study assumes that each node program is
initialized with parameters /âŠ‘ecğ›¾(ğ‘–)=(ğ‘–,ğ‘)whereğ‘–is a node identifier and ğ‘=addr(next(ğ‘–))is
the network address of ğ‘–â€™s successor in the ring. Verifying the configuration, which typically
happensusing scriptsor manual procedures,isorthogonal to program correctness.
(3)Manual translationofI/Ospecification: The I/Ospecification istranslatedcorrectlyfromthe
Isabelle/HOLtothecode verifiertoolâ€™s syntax. Thistranslationis manual, butwell-defined
and can thus be automated in the future by a translator implemented and verified in Isabelle.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:17
(4)Toolchain soundness. The verification logics and tools are sound and all proofs are thus
correct.They agreeon the semantics of I/O specificationsand thecode verifiersatisfiesthe
verifier assumption (VA). In our case, this concerns Isabelle/HOL and either VeriFast (which
usesZ3[deMouraandBjÃ¹rner2008 ])orNagini(whichdependsonViper[ MÃ¼lleretal .2016]
and Z3). The trusted codebase could be reduced further by using a foundational verifier such
asVST[Appel 2012 ], at thecostof a higherverification effort.
4 CASESTUDIES:FAULT-TOLERANCE ANDSECURITY
Weevaluateourmethodologywithtwoadditionalcasestudiesthatdemonstratethegeneralityand
versatilityofIgloo.Concretely,westudyafault-tolerant,primary-backupreplicationsystemandan
authentication protocol. These case studies showcase different features of our approach: (1) proofs
ofglobal,protocol-levelproperties,(2)environmentswithdifferenttypesofnetworksaswellas
faultyandadversarialenvironments,(3)differentcomponenttypeswithunboundednumbersof
instances, and (4) sequential and concurrent implementations in different programming languages.
4.1 Primary-BackupReplication
Weapplyourmethodologytoaprimary-backupreplicationprotocolpresentedby vanRenesseand
Guerraoui [2010].Thiscasestudyexhibitsthefollowingfeaturessupportedbyourapproach:(i)
an environmentthatincludesa faultmodel forcomponents,(ii)reliable, in-ordercommunication
implementedbyTCP, and (iii) sequential aswell asconcurrentimplementations.
4.1.1 Description. The primary-backup replication protocol maintains an append-only distributed
data structure, called log, which is a sequence of arbitrary data (e.g., database commands). One
server,the primary,receivesrequestsfromclientstoappendelementstothelog.Theprimaryserver
first synchronizes a given append request with all other servers, the backups, before extending
its own log and responding to the client. The protocolâ€™s goal is to maintain backup consistency ,
i.e.,thelogstoredontheprimarywhenitrepliestotheclientisaprefixofthelogsstoredatall
backups. We assume a fail-stop fault model, where servers can fail but not recover, and perfect
failure detection,where allclientsandservers eventuallydetect serverfailures (see,e.g., [ Cachin
et al.2011]). The servers are totally ordered, and initially, the first server is the primary. A backup
server becomesthenew primaryonce itdetects thatallprevious servers in theorderhave failed.
4.1.2 ProtocolModel. Inthiscasestudy,wehavechosennottomodelanabstractversionofthe
protocol(Step1),butrathertheconcreteprotocol(Step2)directly.Whilethenormal(fault-free)
operation of the protocol is straightforward, the non-deterministic failures and their detection add
significantcomplexity.Whenanewprimaryservertakesover,itslogmaydivergefromthoseof
thebackups.Bysynchronizingitslogwiththoseofthebackupservers,itreestablishesaconsistent
state beforeresponding toa client. Oncebackup ğ‘has repliedto async request fromprimary ğ‘,
all logscontainedintheirstates and sent between themaretotallyorderedin a prefix relation:
ordered-wrt-prefix (âŸ¨log(ğ‘)âŸ© Â·transit(ğ‘,ğ‘) Â· âŸ¨log(ğ‘)âŸ© Â·transit(ğ‘,ğ‘) Â· âŸ¨pend(ğ‘)âŸ©).
Here,pend(ğ‘)is the primaryâ€™s log including all pending additions, and transit(ğ‘,ğ‘)is the sequence
oflogsintransitfrom ğ‘toğ‘(insyncrequestsorresponses).Additionalinductiveinvariantsand
history variables are needed to derive this invariant. Careful modeling is also required for the
failuredetection.Theenvironmentstatecontainsaset liveenv,consisting ofalllive servers.Since
clients and servers may detect failures only after some delay, each of them has its own set live
containing all servers except for those whose failure was noticed. As we show in an invariant, live
setsaresupersetsof liveenv. Intotal,our proof of backup consistency relieson nine invariants.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:18 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
4.1.3 Towards an Implementation. Our protocol model already includes the input and output
buffers that are typically only added in Step 3. This allows us to directly decompose the model into
a trace-equivalentcomposition of client and servercomponentsand an environment (Step4).
Besidessendandreceive,theclientsandservershaveathirdI/Oevent, detect-failure ,toquery
the failure detector. Its system part removes a server from the componentâ€™s liveset whereas its
environment parthasof a guardensuring thattheremovedserverisnot in the liveenv-set.
WeextractI/Ospecificationsforboththeserverandtheclientcomponenttypes(Step5).This
extraction, as well as the equivalence proof between the componentâ€™s event systems and their I/O
specifications,followsthesamestandardpatternasinoursecuritycasestudybelow.Thus,this
stepcouldlikelybeautomatedinthefuture.
4.1.4 Code Level. We implement a sequential client and a concurrent server in Java. To handle
requests in parallel, wesplit theserverinto multiple threads, communicatingoversharedbuffers,
guarded by a lock. For TCP, we use Javaâ€™s standard socket library. For failure detection, clients
andservers get afailure detector objectas an argument.This object provides methods toquery
whetheraserverhasfailed.IfJavaâ€™ssocketAPIdeterminesthataconnectionattempttimesout,
thefailuredetectorisqueried.Accordingtotheprotocol,failedserversareremovedfromthesetof
liveservers, otherwise the last action is repeated. For this case study, we provide a dummy failure
detectorinstance,which storesthe setof failed server ids.Whenwekill aserver in our execution
script, the server process is terminated and its id is added to that set. The setup of contracts for
trustedlibrariesandtheverificationofourclientandserverimplementationsinVeriFastagainst
theirrespectiveI/O specificationsclosely followsour approach describedin Section 3.8.
In the server, all shared data is protected by a lock. For this lock, we define a monitor invari-
ant[LeinoandMÃ¼ller2009 ],declaringthatthelockownsallshareddatastructuresandtheI/O
permissions. The ownership of these resources is transferred to a thread when it acquires the lock
and is transferred back when the lock is released. The I/O permissions define which I/O operations
maybeperformeddependingonthecomponentmodelâ€™sstate.Sincetheimplementationâ€™sbehavior
dependsontheactualprogramstate,inparticularthestateguardedbythelock,wealsoneedtolink
themodelstatetotheactualstateinthemonitorinvariant.Wedothisusinganabstractionfunction.
Thus,whenexecutinganI/Ooperation,theassociatedmodelstateupdatemustbematchedbya
corresponding program stateupdatebeforethelockcan bereleased.
4.2 Two-PartyEntityAuthentication
Wealsouseourmethodologytoderiveandimplementatwo-partyauthenticationprotocolstan-
dardized asISO/IEC 9798-3. This casestudy demonstrates the following features of ourapproach:
(i)anadversarialenvironment, (ii)theuseofcryptography, (iii)unreliable,unorderedchannels
implemented by UDP, and (iv) the use of data abstraction linking abstract message terms and their
concretecryptographic bitstringrepresentations.
4.2.1 Description. Instandard(informal) Alice&Bobnotation, theprotocolreads asfollows.
M1.ğ´â†’ğµ:ğ´,ğµ,ğ‘ğ´
M2.ğµâ†’ğ´:[ğ‘ğµ,ğ‘ğ´,ğ´]pri(ğµ)
Hereğ‘ğ´andğ‘ğµare the nonces generated by the initiator ğ´and the responder ğµrespectively, and
[ğ‘€]pri(ğµ)denotesthedigitalsignatureofthemessage ğ‘€withğµâ€™sprivatekey.First,theinitiator
generates a fresh nonce and sends it to the responder. Afterwards, the responder generates his
own nonce, signs it together with the initiatorâ€™s nonce and name, and sends the signed message to
theinitiator.Thenoncesprovidereplayprotection. Theprotocolâ€™s authenticationgoalisthatthe
initiatoragreeswiththeresponder on theirnamesand thetwononces.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:19
4.2.2 Abstract and Protocol Models. We follow the four-level refinement strategy for security
protocolsproposedby SprengerandBasin [2018].Itslevelscorrespondstothefirsttwostepsof
our methodology. We start from an abstract model of the desired security property, in our case,
injectiveagreement[ Lowe1997 ].Wethenrefinethisintoaprotocolmodelthatintroducesthetwo
protocolroles(i.e.,Igloocomponenttypes)andtheirruns.Eachprotocolruninstantiatesaroleand
storestheparticipantsâ€™namesandreceivedmessagesinitslocalstate.Wemodelanunbounded
numberofrunsasafinitemapfromrunidentifierstotherunsâ€™localstates.Therunscommunicate
over channels with intrinsic security properties. In our case, ğ´sends her nonce on an insecure
channel to ğµ, who returns itwith his own nonce on an authenticchannel back to ğ´. The attacker
can read, but not modify, messages on authenticchannels.
In a second refinement, we represent messages as terms, use digital signatures to implement
authentic channels, and refine the attacker into a standard Dolev-Yao attacker [ Dolev and Yao
1983] whocompletely controls the network. Theattackerâ€™s capabilities are defined by a closure
operatorDY(ğ‘€), denoting the set of messages he can derive from the set of observed messages ğ‘€
using both message composition (such as encryption) and decomposition (such as decryption). All
refined models correspond to Igloo protocol models with different levels of detail. The refinement
proofsimply thatthey all satisfy injectiveagreement.
4.2.3 Towards an Implementation. We further refine the final protocol model into an interface
model, where the messages are represented by bitstrings of an abstract type bs, which we later
instantiate to actual bitstrings. We assume a surjective abstraction function ğ›¼:bsâ†’msgfrom
bitstringstomessages.Aspecialterm Junkrepresentsallunparsablebitstrings.Wedefineaconcrete
attackeroperatingon(setsof)bitstringsby DYğ‘ğ‘ =ğ›¼âˆ’1â—¦DYâ—¦ğ›¼,whereğ›¼âˆ’1istheinverseof ğ›¼lifted
to message sets. The simulation relation includes the equation ğ›¼(CIK)=IK, whereCIKandIK
respectively represent the concrete attackerâ€™s knowledge and the Dolev-Yao attackerâ€™s knowledge.
This allowsusto transfer theDolev-Yao modelâ€™s security guaranteesto theimplementation.
Wealsoaugmenteachroleâ€™sstatewithbuffersforreceivingandsendingbitstringmessages.The
sendandreceiveI/Oeventseachtakeanetworkaddressandabitstringmessage.Thetworolesâ€™
eventsstilloperateonmessageterms,butexchangemessageswithI/Obuffers.Forexample,we
refine a guard ğ‘šâˆˆIKmodeling a message reception in the protocol model by ğ‘ğ‘ âˆˆibufâˆ§ğ›¼(ğ‘ğ‘ )=
ğ‘šin the interface model. The rolesâ€™ events have several parameters, including the run id, the
participantsâ€™ names,and thelong-term key bitstrings, which later become program parameters.
Finally, we decompose the interface model into an environment and (an unbounded number of)
initiator and responder components. From these, we derive the initiatorâ€™s and the responderâ€™s I/O
specifications.Ourframework provides lemmasto supportthecorresponding proofs.
4.2.4 CodeLevel. Weimplementeachcomponenttype(protocolrole)inbothJavaandPython.
Eachroleâ€™simplementationsendsandreceivesonemessageandchecksthatreceivedmessageshave
thecorrectform.Ourimplementationprovidesa(trusted)parsingandmarshallingfunctionforeach
typeofabstractmessage(e.g.,signatures,identifiers,pairs),eachspecifiedbyacontractrelating
the message to its bitstring representation using ğ›¼. This yields a partial definition of ğ›¼, which
weotherwise leaveabstracttoavoidmodelingbit-levelcryptographic operations.Since ğ›¼relates
eachbitstringtoauniquemessageterm(or Junk),weensurethateverybitstringrepresentinga
non-junk message can be parsed unambiguously by tagging bitstring messages with their type. We
employ widely-usedcryptographic libraries: PyNaClforPython and Javaâ€™s standardlibrary.
Listing3shows the contract and implementation of the signature verification function. It checks
the signatureâ€™s tag and then calls the cryptographic libraryâ€™s signature verification function, which
eitherreturnsthecorrespondingplaintextmessageorraisesanexceptionforinvalidsignatures.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:20 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
def v e r i f y ( signed_msg : bytes , key : b y t e s ) âˆ’> b y t e s :
#@ PRE: alpha ( key ) == Key( publicKey (?a )))
#@ POST: alpha ( signed_msg ) == Crypt (Key( privateKey (a ))) , alpha ( result ))
#@ && len ( signed_msg ) == len ( result ) + 1 + SIGNATURE_SIZE
#@ EXCEPTIONAL POST: forall msg. alpha ( signed_msg ) != Cryp t (Key( privateKey (a )) , alpha (msg ))
if len ( signed_msg ) == 0 orsigned_msg [ 0 ] ! = SIGNATURE_TAG :
raise I n v a l i d D a t a E x c e p t i o n ( " I n v a l i d â£ tag â£ on â£ s i g n a t u r e " )
return n a c l . v e r i f y ( signed_msg [ 1 : ] ) # raises exception if signature is not valid
Listing 3. Simplified pseudocode implementation of a function for verifying signatures and its (trusted)
specification. The pre- and postconditions relate the bitstrings to their abstract message representations that
are used in the I/O specification. Variable ais implicitly existentially quantified (denoted by a question mark).
Thecontractrequiresthatthekeybitstringrepresentssomeagentâ€™spublickeyandguaranteesthat
thefunction terminates normally ifftheinput bitstringwas signedwith thatagentâ€™sprivate key.
WeuseVeriFastandNaginitoprovetheimplementationscorrect.Asanoverallresult,weobtain
a proof thattheentiresystemsatisfiestheintendedauthenticationproperty.
5 FROMEVENT SYSTEMS TO I/O SPECIFICATIONSIN SEPARATIONLOGIC
A central aspect of our methodology is to soundly link protocol models and code. We use I/O
specificationstobridgethesubstantialsemanticgapbetweenthecomponentmodelsthatresult
fromtheinterfacemodeldecompositionstepandthecode.Thecomponentmodelsaregivenas
event systems, whereas I/O specifications are separation logic formulas built over I/O permissions,
possibly employing co-recursive predicates to specify non-terminating behavior. What event
systems and I/O specifications share is a trace semantics. We therefore define a translation of
the componentsâ€™ event systems into I/O specifications and prove that they are trace-equivalent
byestablishingasimulationineachdirection.Itisthistraceequivalencethat,togetherwiththe
verifierassumption (VA)andthecompositionalrefinementtheorem(Corollary 2.4),enablesthe
seamless switching from modelsto code verification in our methodology(cf.Section 3.9).
InsteadoftranslatingcomponentmodelsdirectlyintoI/Ospecifications,wewillpassthrough
an intermediate translation to a sequential process calculus. This intermediate step has several
benefits. First, it shifts the focus from data (guards and state updates) to I/O interactions. Second, it
introduces a minimal syntax for these interactions, providing a useful structure for the correctness
proofs.Third,itbuildsabridgebetweentwopopularspecificationformalisms:processcalculion
themodeling level and permission-basedI/O specificationsin separation logic on thecode level.
Themainchallengeinprovingourresultstemsfromthedisparatesemanticsofeventsystems
andprocessesononehandandI/Ospecificationsontheotherhand.Concretely,wemustshow
that a process ğ‘ƒcan simulate the traces induced by its corresponding assertion ğœ™ğ‘ƒ. As we shall see,
an assertionâ€™s behavior is the intersection of all its modelsâ€™ behaviors. This is challenging as some
models of ğœ™ğ‘ƒexhibit spurious behavior not present in ğ‘ƒand also due to the absence of a single
model representingexactly thebehaviorof ğœ™ğ‘ƒ.
5.1 Background: SemanticsofI/O Specifications forSeparation Logic
WeslightlyextendthesemanticsoftheI/Ospecificationsof Penninckxetal .[2015]byenforcing
a typing discipline on inputs by using a typingfunction Ty:BiosÃ—Valuesâ†’ (P(Values) \ {âˆ…}),
which assigns to each I/O operation and output value a type, given as a non-empty set of accepted
inputs. An I/O permission bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡â€²)and its input value ğ‘¤arewell-typed ifğ‘¤âˆˆTy(bio,ğ‘£), and
achunkiswell-typedifitisawell-typedI/Opermissionoratoken.Thetypingfunctionspecifiesa
relational contract for each I/O operation. The set Ty(ğ‘ğ‘–ğ‘œ,ğ‘£)typically captures the possible results
of an I/O operation, which isusefulto matchI/O operations to I/O library functions.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:21
ğ‘¤âˆˆTy(bio,ğ‘£)
{token(ğ‘¡),bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡â€²)}#+#â„bio(ğ‘£,ğ‘¤)âˆ’ âˆ’âˆ’âˆ’âˆ’âˆ’ â†’ H{token(ğ‘¡â€²)}#+#â„Bio
ğ‘¤â‰ ğ‘¤â€²ğ‘¤,ğ‘¤â€²âˆˆTy(bio,ğ‘£)
{token(ğ‘¡),bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡â€²)}#+#â„bio(ğ‘£,ğ‘¤â€²)âˆ’ âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ â†’ HâŠ¥Contradictğ‘¤âˆˆTy(ğ‘ğ‘–ğ‘œ,ğ‘£)
âŠ¥bio(ğ‘£,ğ‘¤)âˆ’ âˆ’âˆ’âˆ’âˆ’âˆ’ â†’ HâŠ¥Chaos
Fig. 4. Heap transition rules.
AssertionSemantics. Theformalsemanticsofourassertionsisco-inductivelydefinedover heaps
â„âˆˆHeap, whereHeap=Chunks#isthesetof multisetsof chunks(seeSection 2.2),asfollows.
â„|=ğ‘ â‡â‡’ğ‘=true
â„|=ğ‘ â‡â‡’ğ‘âˆˆ#â„âˆ§ğ‘iswell-typed
â„|=ğœ™1â˜…ğœ™2â‡â‡’ âˆƒâ„1,â„2âˆˆHeap.â„=â„1+#â„2âˆ§â„1|=ğœ™1âˆ§â„2|=ğœ™2
â„|=âˆƒğ‘£.ğœ™â‡â‡’ âˆƒğ‘£â€²âˆˆValues.â„|=ğœ™[ğ‘£â€²/ğ‘£]
â„|=âˆƒğ‘¡.ğœ™â‡â‡’ âˆƒğ‘¡â€²âˆˆPlaces.â„|=ğœ™[ğ‘¡â€²/ğ‘¡]
Notethata heaphereisdifferentfromaprogramâ€™sheapmemory;itschunksrepresentpermissions
to perform I/O operations or tokens, not memory locations and their values. Here, we elide the
ordinary program heap forsimplicity and since itisorthogonal to modeling I/O behavior.
The semantics of assertions satisfiesthefollowing monotonicity property.
Lemma 5.1 (Monotonicity). Ifâ„|=ğœ™thenğ‘”+#â„|=ğœ™.
Example5.2. ConsidertheI/Ospecification ğœ™=token(ğ‘¡)â˜…(âˆƒğ‘¥,ğ‘¡â€²,ğ‘¡â€²â€².recv(ğ‘¡,ğ‘¥,ğ‘¡â€²)â˜…send(ğ‘¡â€²,2ğ‘¥,ğ‘¡â€²â€²))
fromExample 2.5.Examplesofheapsthatsatisfy ğœ™areâ„1={token(ğ‘¡),recv(ğ‘¡,12,ğ‘¡1),send(ğ‘¡1,24,ğ‘¡2)}#,
â„2={token(ğ‘¡),recv(ğ‘¡,12,ğ‘¡),send(ğ‘¡,24,ğ‘¡)}#, andâ„3=â„1+#{send(ğ‘¡1,35,ğ‘¡2)}#. More generally, all
heaps satisfying ğœ™have the form ğ»ğœ™(ğ‘¥,ğ‘¡â€²,ğ‘¡â€²â€²,â„)={token(ğ‘¡),recv(ğ‘¡,ğ‘¥,ğ‘¡â€²),send(ğ‘¡â€²,2ğ‘¥,ğ‘¡â€²â€²)}#+#â„
forsome value ğ‘¥, placesğ‘¡â€²andğ‘¡â€²â€², and heap â„. Wewill returnto this examplebelow.
Heap Transitions. Heaps have a transition semantics, where I/O permissions are consumed by
pushingatokenthroughthem.Thissemanticsisgivenbytheeventsystem H=(HeapâŠ¥,Act,âˆ’ â†’H)
with the set of states HeapâŠ¥and the set of events Act={bio(ğ‘£,ğ‘¤) |bioâˆˆBiosâˆ§ğ‘£,ğ‘¤âˆˆValues},
calledI/Oactions .Notethat bioisoverloaded,withthe2-argumentversionyieldingtraceevents
andthe4-argumentonedefiningachunk.AnI/Oaction bio(ğ‘£,ğ‘¤)iswell-typed ifğ‘¤âˆˆTy(bio,ğ‘£)
and a trace ğœâˆˆActâˆ—iswell-typedifall its events are.
The transition relation âˆ’ â†’HofHis defined by the rules in Figure 4and mostly matches the
place-I/O-permission multigraph intuition given in Section 2.2. The rule Biocorresponds to a
normal heap transition executing an I/O operation. The input read is well-typed. The token moves
totheI/Opermissionâ€™stargetplaceandthepermissionisconsumedandremovedfromtheheap.
The rule Contradict describes the situation where a transition bio(ğ‘£,ğ‘¤)would be possible, but the
environmentprovidesaninput ğ‘¤â€²â‰ ğ‘¤thatisdifferentfromtheonepredictedbythechunk.In
this case, the heap can perform a transition bio(ğ‘£,ğ‘¤â€²)to the special state âŠ¥. In this state, arbitrary
(well-typed) behavior is possible by the rule Chaos. Hence, all traces of Hare well-typed. For a set
of heapsğ», wedefine thesetof tracesof ğ»to containthetracesexecutable in allheaps ofğ», i.e.,
tracesH(ğ»)={ğœ| âˆ€â„âˆˆğ».ğœâˆˆtraces(H,â„)}.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:22 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
The setof tracesof an assertion ğœ™isthendefinedto bethesetof tracesof its heap models,i.e.,
tracesH(ğœ™)=tracesH({â„|â„|=ğœ™}).
Thisuniversalquantificationoverallheapmodelsof anassertionconstitutes themainchallenge in
our soundnessproof (Theorem 5.7).Letusnow lookat an exampleillustratingthesedefinitions.
Example5.3(Heapandassertiontraces). Considertheheapmodels â„1,â„2,andâ„3oftheI/Ospeci-
ficationğœ™from Example 5.2. First focusing on regular behaviors , i.e., ignoring the rules Contradict
andChaos, theirtracesaregiven bythefollowing sets,where â†“denotesprefix closure:
â€¢traces(H,â„1)={recv(12) Â·send(24)}â†“,
â€¢traces(H,â„2)=traces(H,â„1) âˆª{send(24) Â·recv(12)}â†“, and
â€¢traces(H,â„3)=traces(H,â„1) âˆª{recv(12) Â·send(35)}â†“.
The first heap, â„1, exhibits an instance of the expected behavior: receive a value and send the
doubledvalue.Theheaps â„2andâ„3,however,alsoallowunintendedbehaviors.Heap â„2hasatrace
wherereceiveandsendareinverted.Thiscomesfromthesemanticsofexistentialquantification,
which does not ensure that the places are distinct. Heap â„3can send a value different from the
doubledinputvalue,whichispossibleduetothemonotonicitypropertyinLemma 5.1.Duetothese
additional behaviors, which we call spurious, the settracesH(ğœ“)of traces of an I/O specification ğœ“
is defined to contain those traces that are possible in allheap models of ğœ“. The three heaps above
onlysharethetracesof â„1, which correspondsto theintendedbehavior.
Notethatthesespuriousbehaviorsarenotanartifactoftheparticularformalismweuse,but
a standard part of the permission-based specification style of separation logics in general. For
example, allprogram heaps satisfyinga standardpoints-to assertion ğ‘¥â†¦â†’ğ‘’allow the program to
dereferencethepointer ğ‘¥,butsomeheapsmayalsoallowdereferencingthepointer ğ‘§becauseğ‘§
andğ‘¥happen to alias in a particular interpretation (analogous to Å‚aliasingÅ¾ places in â„2), or, for
logicswithmonotonicity,maycontain(andthereforeallowaccessto)extramemorypointedto
byğ‘¦. However, like in our case, the program logic must not allow dereferencing ğ‘¦orğ‘§because it is
not possiblein allprogram heaps satisfying theassertion.
Therules Contradict andChaosadd,foranyregulartraceoftheform ğœ1Â·recv(ğ‘¤) Â·ğœ2,chaotic
tracesof theform ğœ1Â·recv(ğ‘¤â€²) Â·ğœforeachwell-typed ğ‘¤â€²â‰ ğ‘¤andwell-typedtrace ğœ.These rules
formalizethat aheapreading some(well-typed)input different from the onepredicted bythe I/O
permissionmaybehavearbitrarily.Forexample,both â„â€²
1={token(ğ‘¡),recv(ğ‘¡,19,ğ‘¡1),send(ğ‘¡1,38,ğ‘¡2)}#
andâ„1aremodelsof ğœ™andğœ–istheironlysharedregulartrace.However,theregulartracesof â„â€²
1are
alsochaotictracesof â„1andviceversa.Hence, tracesH({â„1,â„â€²
1})consistsoftheregulartracesof
â„1andâ„â€²
1.Thisensuresthat tracesH(ğœ™)={recv(ğ‘¥) Â·send(2ğ‘¥) |ğ‘¥âˆˆValues}â†“isthetraceproperty
intendedbytheassertion ğœ™. Withoutthesetworules, wewouldhave tracesH(ğœ™)={ğœ–}.
5.2 Embedding I/O-GuardedEventSystemsinto Processes
Weco-inductivelydefine a simple language of (sequential) processes:
ğ‘ƒ::=ğœˆNull|bio(ğ‘£,ğ‘§).ğ‘ƒ|ğ‘ƒ1âŠ•ğ‘ƒ2.
Here, Nullistheinactiveprocess, bio(ğ‘£,ğ‘§).ğ‘ƒisprefixingwithanI/Ooperation,whichbindsthe
input variable ğ‘§inğ‘ƒ, andğ‘ƒ1âŠ•ğ‘ƒ2isa binary choiceoperator. Let Procbethesetof all processes.
Wecanthenco-recursivelydefineprocesses.Forexample,wedefineacountablechoiceoperator/circleplustext.1
ğ‘£âˆˆğ‘†ğ‘ƒ(ğ‘£)overasetofvalues ğ‘†with Nullastheneutralelement,analogoustothedefinitionof
theiteratedseparatingconjunction.Wecanalsoco-recursively definenon-terminatingprocesses.
Example 5.4. A process corresponding to the I/O specification from Example 2.6is specified by
RSP(0), whereRSP(ğ‘)=ğœˆrecv(ğ‘§).ifğ‘§>0thensend(ğ‘+ğ‘§).RSP(ğ‘+ğ‘§)else Null.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:23
Theoperationalsemanticsofprocessesisgiven bytheeventsystem P=(Proc,Act,âˆ’ â†’P),where
thetransition relation âˆ’ â†’Pisinductivelydefinedbythefollowing rules:
ğ‘¤âˆˆTy(bio,ğ‘£)
bio(ğ‘£,ğ‘§).ğ‘ƒbio(ğ‘£,ğ‘¤)âˆ’ âˆ’âˆ’âˆ’âˆ’âˆ’ â†’ Pğ‘ƒ[ğ‘¤/ğ‘§]Prefğ‘ƒ1ğ‘âˆ’ â†’Pğ‘ƒâ€²
1
ğ‘ƒ1âŠ•ğ‘ƒ2ğ‘âˆ’ â†’Pğ‘ƒâ€²
1Choice 1ğ‘ƒ2ğ‘âˆ’ â†’Pğ‘ƒâ€²
2
ğ‘ƒ1âŠ•ğ‘ƒ2ğ‘âˆ’ â†’Pğ‘ƒâ€²
2Choice 2
Wewrite traces(ğ‘ƒ)asa shorthandfor traces(P,ğ‘ƒ).
Translation. WedefineatranslationfromI/O-guardedeventsystems G=(ğ‘†,Act,ğº,ğ‘ˆ)toprocesses.
The process proc(G,ğ‘ )represents Ginstateğ‘ and isco-recursivelydefinedby
proc(G,ğ‘ )=ğœˆ/circleplusdisplay.1
bioâˆˆBios/circleplusdisplay.1
ğ‘£âˆˆValuesifğº(bio,ğ‘£)(ğ‘ )thenbio(ğ‘£,ğ‘§).proc(G,ğ‘ˆbio(ğ‘£,ğ‘§)(ğ‘ ))else Null.
Recallthathereweborrowtheconditionalfromourmeta-languageHOL.Thefollowingcorrectness
resultisestablishedbya simulation ineach direction.
Theorem 5.5 (Correctness of event system translation). For any I/O-guarded event system
G=(ğ‘†,Act,ğº,ğ‘ˆ)and state ğ‘ âˆˆğ‘†,wehave traces (G,ğ‘ )=traces(proc(G,ğ‘ )).
5.3 Embedding Processesinto I/O Specifications
Wenowco-recursivelydefinetheembedding embfromprocessesandplacesintoI/Ospecifications:
emb(Null,ğ‘¡)=ğœˆtrue
emb(bio(ğ‘£,ğ‘§).ğ‘ƒ,ğ‘¡)=ğœˆâˆƒğ‘¡â€²,ğ‘§â€².bio(ğ‘¡,ğ‘£,ğ‘§â€²,ğ‘¡â€²)â˜…emb(ğ‘ƒ[ğ‘§â€²/ğ‘§],ğ‘¡â€²)
emb(ğ‘ƒ1âŠ•ğ‘ƒ2,ğ‘¡)=ğœˆemb(ğ‘ƒ1,ğ‘¡)â˜…emb(ğ‘ƒ2,ğ‘¡).
We define the process assertion ofğ‘ƒbyemb(ğ‘ƒ)=âˆƒğ‘¡.token(ğ‘¡)â˜…emb(ğ‘ƒ,ğ‘¡). We then prove by
co-induction thatcountable choicetranslatesto iteratedseparating conjunction.
Lemma 5.6. emb(/circleplustext.1
ğ‘£âˆˆğ‘†ğ‘ƒ(ğ‘£),ğ‘¡)=âˆ€â˜…ğ‘£âˆˆğ‘†.emb(ğ‘ƒ(ğ‘£),ğ‘¡).
Wenowturntoourmainresult,namely,thetraceequivalenceofprocess ğ‘ƒanditsI/Ospecification
emb(ğ‘ƒ). Wefocuson theintuitionhereand presenttheformaldetails in [ Sprenger et al. 2020a ].
Theorem5.7 (Correctnessof processtranslation). traces(ğ‘ƒ)=tracesH(emb(ğ‘ƒ)).
TheprooffollowsfromPropositions 5.8,5.12,and5.13towhichtheremainderofSection 5is
devoted.TogetherwithTheorem 5.5,thisresultallowsustotranslateanyI/O-guardedeventsystem
Emodeling some component of our system into an I/O specification ğœ™E=emb(proc(E))with
identicalbehavior.Wecanthenuse ğœ™Easaspecificationforthecodeimplementing Eâ€™sbehavior.
The left-to-right trace inclusion of this theorem is captured by the following proposition, which
weprovebya simulation between process ğ‘ƒand heap modelsof emb(ğ‘ƒ).
Proposition5.8. traces(ğ‘ƒ) âŠ†tracesH(emb(ğ‘ƒ)).
The main difficulty lies in the proof of the reverse set inclusion and stems from the meaning of
tracesH(emb(ğ‘ƒ)), which contains exactly those traces ğœthat are a trace of allmodels of emb(ğ‘ƒ).
From Example 5.3, we know that many models of emb(ğ‘ƒ)(or of any assertion ğœ™for that mat-
ter) exhibit spurious behaviors that are not in tracesH(emb(ğ‘ƒ))(or intracesH(ğœ™), respectively).
Therefore, picking an arbitrary heap model of emb(ğ‘ƒ)and trying to simulate its transitions by the
processğ‘ƒâ€™stransitionswillfail.Instead,werestrictourattentionto canonical modelsthatdonot
exhibitspuriousbehaviors.Wedenoteby can(ğ‘ƒ)thesetofallcanonicalmodelsof ğ‘ƒ(introducedin
Section5.4).Wethendecomposetheproof into thefollowing chain of setinclusions:
tracesH(emb(ğ‘ƒ)) âŠ†tracesH(can(ğ‘ƒ)) âŠ†traces(ğ‘ƒ). (2)
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:24 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
âŠ•
ğ‘ƒ1
âŠ•ğ‘ƒ6
Null
âŠ•
ğ‘ƒ3
ğ‘ƒ4ğ‘ƒ2
Nullğ‘ƒ5
Null
Nullin(1) fail
out(1)
in(2) drop
out(3)ğœ–Â·ğœ–
ğœ–Â·ğ¿
ğ¿2Â·ğœ–ğœ–Â·ğ‘…
ğ‘…ğ¿Â·ğœ–
ğ¿2Â·ğ‘…
ğ¿2Â·ğ‘…ğ¿
ğ¿2ğ‘…ğ¿2Â·ğœ–
ğ¿2ğ‘…ğ¿3Â·ğœ–ğ¿2Â·ğ¿
ğ¿4Â·ğœ–ğ¿2Â·ğ‘…2
ğ¿2ğ‘…2ğ¿Â·ğœ–ğœ–
ğ¿2 ğ‘…ğ¿
ğ¿2ğ‘…ğ¿2ğ¿4
ğ¿2ğ‘…2ğ¿
ğ¿2ğ‘…ğ¿3in(1) fail
out(1)
in(2)drop
out(3)
Fig. 5. Process ğ‘ƒand the schedule ğœŒof Example 5.10(left) and resulting canonical model (right). Each process
(node in the left graph) is annotated with its position ğ‘ğ‘ğ‘œğ‘ =ğ‘ğ‘ğ‘œğ‘ Â·ğ‘¥.
The first inclusion expresses that the canonical models cover all behaviors of emb(ğ‘ƒ). We will
establishthesecondinclusionbysimulatingthebehaviorofcanonicalmodelsbyprocesstransitions.
5.4 Canonical Heap Models forProcesses
Anaturalcanonicalmodelcandidateforaprocess ğ‘ƒwouldbetheheap â„ğ‘ƒthatisisomorphicto ğ‘ƒâ€™s
computationtree,whereaprocess bio(ğ‘£,ğ‘¤).ğ‘„wouldresultinoneI/Opermission bio(ğ‘¡,ğ‘£,ğ‘¤,ğ‘¡ ğ‘¤)
for each input ğ‘¤on the heap. Although this proposal avoids spurious behaviors due to additional
permissionsand place identifications(cf.Example 5.3),itfailsasthefollowing exampleshows.
Example 5.9 (Failed attempt). Letğ‘ƒ=ğ‘–ğ‘›(ğ‘¥).ğ‘œğ‘¢ğ‘¡(ğ‘¥).Null,Values=B, andPlaces={L,R}âˆ—(for
tree positions). Then â„ğ‘ƒcontains both I/O permissions ğ‘–ğ‘›(ğœ–,false,L)andğ‘–ğ‘›(ğœ–,true,R). This would
lead totracesH(can(ğ‘ƒ))=traces(â„ğ‘ƒ)={ğœ–} âˆª {ğ‘–ğ‘›(ğ‘£) Â·ğœ|ğ‘£âˆˆB,ğœâˆˆActâˆ—}according to the
rules Contradict andChaosand henceto tracesH(can(ğ‘ƒ)) âŠƒtraces(ğ‘ƒ).
Wewillthereforeconstructthecanonicalheapmodelsofaprocess ğ‘ƒwithrespecttoaninput
schedule, which is essentially a prophecy variable that uniquely determines the inputs read by
the process. An input schedule is a function ğœŒ:Actâˆ—Ã—BiosÃ—Valuesâ†’Valuesmapping an I/O
traceğœ, an I/O operation bio, and an output value ğ‘£to an input value ğœŒ(ğœ,bio,ğ‘£). Hence, there will
beacanonicalmodel cmod(ğ‘ƒ,ğœŒ)foreachinputschedule ğœŒ,whichintuitivelycorrespondstothe
projection of ğ‘ƒâ€™s computation tree to the inputs prescribed by ğœŒ. The set can(ğ‘ƒ)contains such
a model for each input schedule ğœŒ. Our construction uses the set of places Places={L,R}âˆ—, i.e.,
the places are positions of a binary tree. The inputs being fixed, the only branching stems from
the choice operator. The following example illustrates our construction. We present its formal
definitionand theproofsof thecorresponding results in [ Sprenger et al. 2020a ].
Example 5.10(Canonicalmodel). Consider theprocess ğ‘ƒdefinedby
ğ‘ƒ=in(ğ‘¥).ğ‘„(ğ‘¥) âŠ•fail.Nullğ‘„(ğ‘¥)=out(ğ‘¥).NullâŠ• (in(ğ‘¦).out(ğ‘¥+ğ‘¦).NullâŠ•drop.Null).
For simplicity, the I/O operations dropandfailhave no arguments. Let ğœŒbe the input schedule
defined by ğœŒ(ğœ,ğ‘ğ‘–ğ‘œ,ğ‘£)=len(ğœ) +1. Figure5(left) shows the projection of ğ‘ƒâ€™s syntax tree to the
input schedule ğœŒ. Edges arising from action prefixes are labeled with the corresponding action.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:25
Eachnodeisannotatedwithitscurrentposition ğ‘ğ‘ğ‘œğ‘ =ğ‘ğ‘ğ‘œğ‘ Â·ğ‘¥,whichiscomposedof ğ‘ğ‘ğ‘œğ‘ ,the
targetpositionofthepreviousaction-labelededgeinthetree(or ğœ–ifthereisnone),andarest ğ‘¥.
Each edge labeled by some action bio(ğ‘£,ğ‘¤)and connecting position ğ‘ğ‘ğ‘œğ‘ =ğ‘ğ‘ğ‘œğ‘ Â·ğ‘¥toğ‘ğ‘ğ‘œğ‘ Â·L
translatesintoanI/Opermission bio(ğ‘ğ‘ğ‘œğ‘ ,ğ‘£,ğ‘¤,ğ‘ğ‘ğ‘œğ‘  Â·L)intheresultingcanonicalheap cmod(ğ‘ƒ,ğœŒ),
which isshowninFigure 5(right).
The following result states that the canonical model for a process ğ‘ƒand a schedule ğœŒis indeed a
model of the assertion corresponding to the process ğ‘ƒ. The first inclusion in (2)then easily follows.
Proposition 5.11 (Canonical model property). cmod(ğ‘ƒ,ğœŒ) |=emb(ğ‘ƒ,ğœ–)for all processes ğ‘ƒ
and well-typed schedules ğœŒ.
Proposition5.12. tracesH(emb(ğ‘ƒ)) âŠ†tracesH(can(ğ‘ƒ)).
5.5 ProcessesSimulate Canonical Models
Wenowturntothesecondtraceinclusionin (2):eachtraceofthecanonicalmodelset can(ğ‘ƒ)is
alsoatraceof ğ‘ƒ.Writing cmodt(ğ‘ƒ,ğœŒ)forthecanonicalmodel cmod(ğ‘ƒ,ğœŒ)withatokenaddedat
its root place, we would like transitions of the heap cmodt(ğ‘ƒ,ğœŒ)to lead to a heap cmodt(ğ‘ƒâ€²,ğœŒ)for
some process ğ‘ƒâ€², so wecan simulate itwith thecorresponding process transition from ğ‘ƒtoğ‘ƒâ€².
There are two obstaclestothisplan: (1) dead heap parts,which correspond tountakenchoices
in processes ğ‘ƒâŠ•ğ‘„and cannot perform any transitions, and (2) chaotic transitions where, given a
traceofthesetofcanonicalmodels can(ğ‘ƒ),someofthemodels cmodt(ğ‘ƒ,ğœŒ)incan(ğ‘ƒ)transitto
theÅ‚chaoticÅ¾state âŠ¥atsomepointalongthetrace.Theproblemhereisthatagivenprocesscannot
in generalsimulate the(arbitrary)I/O actionsthatarepossiblein thestate âŠ¥.
Our proofs must take such dead heap parts into account to address problem (1) and carefully
pickaparticularscheduletoavoidproblem(2).Here,wefocusonproblem(2)fromanintuitive
perspective(see[ Sprengeretal .2020a]foramorepreciseanddetailedaccount).Itssolutionisbased
on the observation that executing some I/O action bio(ğ‘£,ğ‘¤ğœŒ)withscheduled input ğ‘¤ğœŒ=ğœŒ(ğœ,bio,ğ‘£)
fromcmodt(ğ‘ƒ,ğœŒ)indeedleadstoaheap cmodt(ğ‘ƒâ€²,ğœŒ)forsomeprocess ğ‘ƒâ€²(and,inparticular,not
toâŠ¥).Hence,tosimulateagiventrace ğœoftheheap cmodt(ğ‘ƒ,ğœŒ)bytransitionsoftheprocess ğ‘ƒ,
wemustensurethattheschedule ğœŒisconsistentwiththetrace ğœ.Wethereforedefineawitness
schedule ğœŒwit(ğœ), which returnstheinputsappearing on thetrace ğœand hastheproperty:
cmodt(ğ‘ƒ,ğœŒwit(ğœ))ğœâˆ’ â†’â„=cmodt(ğ‘ƒâ€²,ğœŒwit(ğœ)) (3)
for some process ğ‘ƒâ€², i.e., in particular, â„â‰ âŠ¥. The final trace inclusion in Equation (2)then follows
immediately, since any trace ğœâˆˆtracesH(can(ğ‘ƒ))isalsoa trace of cmodt(ğ‘ƒ,ğœŒwit(ğœ)).
Proposition5.13. tracesH(can(ğ‘ƒ)) âŠ†traces(ğ‘ƒ).
6 RELATED WORK
Numerous formalismshave been developed for modeling and verifying systems. In the following,
wefocuson those approaches thatcombinemodelsand code, and targetdistributedsystems.
ModelVerification with CodeExtraction. Variousapproaches verify modelsof distributedsystems
in formalismsthat support the extraction of executablecode. Thefollowing four approaches are all
embeddedin Coq and supporttheextraction of OCaml programs.
In Verdi [ Wilcox et al .2015;Woos et al .2016], a system is specified by defining types and
handlersforexternalI/Oandfornetworkmessages.Thedevelopercanfocusontheapplication
anditscorrectnessproofbyessentiallyassumingafailure-freeenvironment.Theseassumptions
can be relaxed by applying Verdiâ€™s verified system transformers to make the application robust
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:26 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
with respect to communication failures or node crash failures. DISEL [ Sergey et al .2018] offers
a domain-specific language for defining protocols in terms of their invariants and atomic I/O
primitives.Itenablesthemodularverificationofprogramsthatparticipateindifferentprotocols,
usingseparation logicto representprotocol state separation. Componentprograms are verifiedin
the context of one or more protocol models using a Hoare logic embedded in a dependent type
theory.Theprogramverificationcanbeunderstoodasasinglerefinementstep.Velisarios[ Rahli
etal.2018]isaframeworkforverifyingByzantinefault-tolerantstate-machinereplicationprotocols
in Coqbased onalogic ofevents.It models systems asdeterministic statemachines andprovides
aninfrastructureformodelingandreasoningaboutdistributedknowledgeandquorumsystems.
Chapar [Lesani et al .2016] is a formal framework in Coq for the verification of causal consistency
for replicated key-valuestores. The technique uses anabstract operational semantics that defines
allthecausally-consistentexecutionsofaclientofthestore.Theimplementationofthestoreis
verifiedbyproving thatits concreteoperational semantics refinesthis abstractsemantics.
Liu et al.[2020] model distributed systems in Maudeâ€™s rewriting logic [ Clavel et al .2007]. These
are compiled into distributed implementations using mediator objects for the TCP communication.
Theyprovethatthegeneratedimplementationisstutteringequivalenttotheoriginalmodel,hence
preserving next-freeCTL*properties.The implementation runsin distributedMaude sessions.
All of these approaches enable the development of distributed systems that are correct by
construction. However, code extraction has three major drawbacks. First, the produced code is
either purely functional or based on rewriting logic, which precludes common optimizations
(e.g., using mutable heap data structures). Second, it is difficult for extracted code to interface
existingsoftwaremodules suchaslibraries;incorporatingexisting(possibly unverified)modules
isoftennecessaryinpractice.Third,theapproachesprescribeafixedimplementationlanguage;
however,itisoftenusefulinpracticetobeabletocombinecomponents,suchasclientsandservers,
writtenindifferentlanguages.Ourapproachavoidsallthreeproblemsbysupportingthebottom-up
development and verification of efficient, flexible implementations.
PSync [Dragoi et al .2016] is a domain-specific language for implementing round-based dis-
tributed, fault-tolerant systems. PSync programs are executed via an embedding into Scala. A
dedicated verifier allows one to prove safety and liveness properties of PSync programs, and a
refinement result shows that these carry over to the executable system. The focus of PSync is
mostlyon developing specific verifieddistributed algorithms rather thanentiresoftwaresystems.
Combinations of Model and Code Verification. The works most closely related to ours are those
ofKohetal.[2019]andofOortwijnandHuisman [2019].TheformerworkispartofDeepSpec[ Pierce
2016],whichisaresearchprogramwiththegoalofdevelopingfully-verifiedsoftwareandhardware.
The DeepSpec developments are based on the Verified Software Toolchain (VST) [ Cao et al.2018],
aframeworkforverifyingCprogramsviaaseparationlogicembeddedinCoq. Kohetal.[2019]
useinteraction trees [Xia et al.2020], which are similar to our processes, to specify a programâ€™s
I/O behavior and directly embed these into VSTâ€™s separation logic using a special predicate. In
contrast,ourembeddingofprocessesintoseparationlogicusingtheencodingof Penninckxetal .
[2015]allowsustoapplystandardseparationlogicandexistingprogramverifiers.Inboththeirand
ourwork,asuccessfulprogramverificationguaranteesaninclusionoftheprogramâ€™sI/Otraces
in those of the I/O specification or interaction tree. Koh et al.[2019] verify a simple networked
server in a TCP networking environment, for which they use two interaction trees at different
abstractionlevelsandrelatethembyaformofcontextualrefinementthatestablisheslinearizability.
Theirpaperleavesopenthequestionwhethertheirapproachcanbeusedtoverifysystem-wide
global properties of distributed systems with different types of components and operating in
different environments (e.g.,exhibiting faulty and adversarial behavior).For example,it is unclear
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:27
whethertheycouldverifyourcasestudyprotocols. OortwijnandHuisman [2019]useaprocess
calculus for modeling, which they embed into a concurrent separation logic (CSL). Their approach
reliesonautomatedtoolsandcombinesthemCRL2modelcheckerwithanencodingofCSLinto
Viper.Themodeling-levelexpressivenessislimitedbymCRL2beingafinite-statemodelchecker.
Moreover,whilethe soundnessofCSLimpliesthe preservationofstateassertionsfrom modeling
to implementation level, itisunclear whetherarbitrary trace propertiesarepreserved.
IronFleet[ Hawblitzeletal .2015]combinesTLA-stylerefinementwithcodeverification.Abstract
modelsaswellastheimplementationareexpressedinDafny[ Leino2010 ].Dafnyisapowerful
verificationframeworkthatsupports,amongotherfeatures,mutableheapdatastructures,inductive
andcoinductivedatatypes,andproofauthoring.ReasoningissupportedbyanSMTsolver,whichis
restricted to first-order logic. Dafny enables different kinds of higher-order reasoning by encoding
itintofirst-orderlogicinternally,but neverthelesshassomerestrictionsbothinexpressivityand
practicality for larger proofs when compared to native higher-order theorem provers. By using
Isabelle/HOL as modeling language, our approach provides the full expressiveness of higher-order
logic,whichalsoallowsustoformalizeourmeta-theory.Byusingasingleframework,Ironfleet
avoidstheproblemswehadtosolvewhenlinkingabstractmodelstoseparationlogicspecifications.
However, it lacks the flexibility to support different logics or modeling languages. Dafny currently
compiles to sequential C#, Go, and JavaScript, while existing separation logic based verifiers
supportconcurrentimplementationsandallowdeveloperstowritethecodedirectlyinfamiliar
programminglanguagesratherthaninDafny.IronFleetsupportsbothsafetyandlivenessproperties,
whereas our approach focuseson safety propertiesand leaveslivenessasfuturework.
ProjectEverest[ Bhargavanetal .2017]usesanapproachsimilartoIronFleettodevelopaverified
implementation of TLS. An abstract implementation is developed and verified in Lowâˆ—[Protzenko
etal.2017],asubsetofFâˆ—[Swamyetal .2016]gearedtowardimperativeC-likecodethatiscompiled
toC.Amainfocusofthisprojectisonverifyingcryptographicalgorithms.LikeIronFleet,Lowâˆ—
verification uses an SMT solverand theextractedC code issequential.
7 CONCLUSIONSANDFUTURE WORK
Weproposedanovelapproachfortheformaldevelopmentofdistributedsystems.Ourapproach
combines the top-down development of system models via compositional refinement with bottom-
up program verification. This supports a clean separation of concerns and simplifies the individual
verification tasks, which is crucial for managing the additional complexity arising in systems
operating in faulty or adversarial environments. For program verification, we support state-of-the-
art separation logics, which support mutable heap data structures, concurrency, and other features
neededtodevelopefficient,maintainablecode.Wedemonstratedthatourapproachbridgesthegap
betweenabstractmodelsandconcretecode,boththroughthetheoreticalfoundationsunderpinning
its soundness and with three complete case studies. The theory and case studies are mechanized in
Isabelle/HOLand theNagini and VeriFast program verifiers.
As future work, we plan to reduce the need for boilerplate Isabelle code by automating the
translationofinterfacemodelsintothecomponentsâ€™I/Ospecificationsthatareinputtothecode
verifiers.Wealsoplantosupportlivenessproperties,whichwillrequireamorecomplexrefinement
framework in the style of TLA [ Lamport 1994 ], including support for fairness notions. Finally,
wearecurrentlyapplyingourapproachtoverifysubstantialpartsoftheSCIONsecureInternet
architecture[ Perrigetal .2017].Weshowprotocol-levelglobalsecuritypropertiesintheDolev-Yao
symbolic attacker model and verify the I/O behavior (as well as memory safety, secure information
flow, and other properties)of thecurrently deployedimplementation of SCION routers.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:28 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
REFERENCES
MartÃ­nAbadiandLeslieLamport.1991. TheExistenceofRefinementMappings. Theor.Comput.Sci. 82,2(1991),253Å›284.
https://doi.org/10.1016/0304-3975(91)90224-P
Jean-RaymondAbrial.2010. ModelinginEvent-B-SystemandSoftwareEngineering . CambridgeUniversityPress. https:
//doi.org/10.1017/CBO9781139195881
AndrewW.Appel.2012. VerifiedSoftwareToolchain.In NASAFormalMethods-4thInternationalSymposium,NFM2012,
Norfolk, VA,USA,April 3-5, 2012. Proceedings . 2.https://doi.org/10.1007/978-3-642-28891-3_2
KarthikeyanBhargavan,BarryBond,AntoineDelignat-Lavaud,CÃ©dricFournet,ChrisHawblitzel,CatalinHritcu,Samin
Ishtiaq, Markulf Kohlweiss, Rustan Leino, Jay R. Lorch, Kenji Maillard, Jianyang Pan, Bryan Parno, Jonathan Protzenko,
Tahina Ramananandro, Ashay Rane, Aseem Rastogi, Nikhil Swamy, Laure Thompson, Peng Wang, Santiago Zanella
BÃ©guelin,andJeanKarimZinzindohoue.2017.Everest:TowardsaVerified,Drop-inReplacementofHTTPS.In 2ndSummit
onAdvancesinProgrammingLanguages,SNAPL2017,May7-10,2017,Asilomar,CA,USA(LIPIcs,Vol.71) ,BenjaminS.
Lerner, Rastislav BodÃ­k, and Shriram Krishnamurthi (Eds.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 1:1Å›1:12.
https://doi.org/10.4230/LIPIcs.SNAPL.2017.1
Jasmin Christian Blanchette, Aymeric Bouzy, Andreas Lochbihler, Andrei Popescu, and Dmitriy Traytel. 2017. Friends with
Benefits-ImplementingCorecursioninFoundationalProofAssistants.In ProgrammingLanguagesandSystems-26th
European Symposium on Programming,ESOP 2017, Held asPart of the European Joint Conferences on Theory andPractice
ofSoftware,ETAPS2017,Uppsala,Sweden,April22-29,2017,Proceedings (LectureNotesinComputerScience,Vol.10201) ,
Hongseok Yang (Ed.). Springer, 111Å›140. https://doi.org/10.1007/978-3-662-54434-1_5
Christian Cachin, Rachid Guerraoui, and LuÃ­s E. T. Rodrigues. 2011. Introduction to Reliable and Secure Distributed Program-
ming (2. ed.) . Springer. https://doi.org/10.1007/978-3-642-15260-3
QinxiangCao,LennartBeringer,SamuelGruetter,JosiahDodds,andAndrewW.Appel.2018. VST-Floyd:ASeparationLogic
Tool to Verify Correctness of CPrograms. J. Autom. Reasoning 61, 1-4(2018), 367Å›422. https://doi.org/10.1007/s10817-
018-9457-5
ErnestJ.H.ChangandRosemaryRoberts.1979. AnImprovedAlgorithmforDecentralizedExtrema-FindinginCircular
ConfigurationsofProcesses. Commun.ACM 22, 5(1979), 281Å›283. https://doi.org/10.1145/359104.359108
ManuelClavel, FranciscoDurÃ¡n,StevenEker, PatrickLincoln,Narciso MartÃ­-Oliet,JosÃ© Meseguer, andCarolyn L.Talcott
(Eds.).2007. AllAboutMaude-AHigh-PerformanceLogicalFramework,HowtoSpecify,ProgramandVerifySystemsin
RewritingLogic . LectureNotesin ComputerScience, Vol.4350. Springer. https://doi.org/10.1007/978-3-540-71999-1
Sjoerd Cranen, Jan Friso Groote, Jeroen J. A. Keiren, Frank P. M. Stappers, Erik P. de Vink, Wieger Wesselink, and Tim A. C.
Willemse.2013. AnOverviewofthemCRL2ToolsetandItsRecentAdvances.In ToolsandAlgorithmsfortheConstruction
andAnalysisofSystems-19thInternationalConference,TACAS2013,HeldasPartoftheEuropeanJointConferenceson
TheoryandPracticeofSoftware,ETAPS2013,Rome,Italy,March16-24,2013.Proceedings(LectureNotesinComputerScience,
Vol. 7795) , NirPitermanandScott A. Smolka(Eds.).Springer, 199Å›213. https://doi.org/10.1007/978-3-642-36742-7_15
Leonardo MendonÃ§a de Moura and Nikolaj BjÃ¹rner. 2008. Z3: An Efficient SMT Solver. In Tools and Algorithms for the
Construction and Analysis of Systems, 14th International Conference, TACAS 2008, Held as Part of the Joint European
Conferences on Theory and Practice of Software, ETAPS 2008, Budapest, Hungary, March 29-April 6, 2008. Proceedings
(Lecture Notes in Computer Science, Vol. 4963) , C. R. Ramakrishnan and Jakob Rehof (Eds.). Springer, 337Å›340. https:
//doi.org/10.1007/978-3-540-78800-3_24
DannyDolevandAndrewChi-ChihYao.1983. Onthesecurityofpublickeyprotocols. IEEETrans.InformationTheory 29,2
(1983), 198Å›207. https://doi.org/10.1109/TIT.1983.1056650
CezaraDragoi,ThomasA.Henzinger,andDamienZufferey.2016. PSync:apartiallysynchronouslanguageforfault-tolerant
distributedalgorithms.In Proceedingsofthe43rdAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesofProgramming
Languages, POPL2016,St. Petersburg,FL, USA,January20- 22,2016 , Rastislav BodÃ­kand RupakMajumdar(Eds.).ACM,
400Å›415. https://doi.org/10.1145/2837614.2837650
Marco Eilers and Peter MÃ¼ller. 2018. Nagini: A Static Verifier for Python. In Computer Aided Verification - 30th International
Conference, CAV 2018, Held as Part of the Federated Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings,
Part I (Lecture Notes in Computer Science, Vol. 10981) , Hana Chockler and Georg Weissenbacher (Eds.). Springer, 596Å›603.
https://doi.org/10.1007/978-3-319-96145-3_33
ChrisHawblitzel,JonHowell,ManosKapritsos,JacobR.Lorch,BryanParno,MichaelL.Roberts,SrinathT.V.Setty,andBrian
Zill.2015. IronFleet:provingpracticaldistributedsystemscorrect.In Proceedingsofthe25thSymposiumonOperating
Systems Principles, SOSP 2015, Monterey, CA, USA, October 4-7, 2015 , EthanL. Miller and Steven Hand (Eds.). ACM, 1Å›17.
https://doi.org/10.1145/2815400.2815428
Chris Hawblitzel, Jon Howell, Jacob R. Lorch, Arjun Narayan, Bryan Parno, Danfeng Zhang, and Brian Zill. 2014. Ironclad
Apps:End-to-EndSecurityviaAutomatedFull-SystemVerification.In OperatingSystemsDesignandImplementation
(OSDI), Jason FlinnandHank Levy (Eds.).USENIXAssociation, 165Å›181.
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:29
C. A. R.Hoare. 2003. The Verifying Compiler: A Grand Challange for Computing Research. In Modular Programming
Languages, Joint Modular Languages Conference, JMLC 2003, Klagenfurt, Austria, August 25-27, 2003, Proceedings (Lecture
NotesinComputerScience, Vol.2789) ,LÃ¡szlÃ³ BÃ¶szÃ¶rmÃ©nyiandPeter Schojer (Eds.).Springer,25Å›35. https://doi.org/10.
1007/978-3-540-45213-3_4
Bart Jacobs, Jan Smans, Pieter Philippaerts, FrÃ©dÃ©ric Vogels, Willem Penninckx, and Frank Piessens. 2011. VeriFast: A
Powerful,Sound,Predictable,FastVerifierforCandJava.In NASAFormalMethods-ThirdInternationalSymposium,NFM
2011, Pasadena, CA, USA, April 18-20, 2011. Proceedings (Lecture Notes in Computer Science, Vol. 6617) , Mihaela Gheorghiu
Bobaru,KlausHavelund,GerardJ.Holzmann,andRajeevJoshi(Eds.).Springer,41Å›55. https://doi.org/10.1007/978-3-
642-20398-5_4
GerwinKlein,KevinElphinstone,GernotHeiser,JuneAndronick,DavidCock,PhilipDerrin,DhammikaElkaduwe,Kai
Engelhardt,RafalKolanski,MichaelNorrish,ThomasSewell,HarveyTuch,andSimonWinwood.2009. seL4:formal
verification of an OS kernel. In Proceedings of the 22nd ACM Symposium on Operating Systems Principles 2009, SOSP 2009,
Big Sky, Montana, USA, October 11-14, 2009 , Jeanna Neefe Matthews and Thomas E. Anderson (Eds.). ACM, 207Å›220.
https://doi.org/10.1145/1629575.1629596
Nicolas Koh, Yao Li, Yishuai Li, Li-yao Xia, Lennart Beringer, Wolf HonorÃ©, William Mansky, Benjamin C. Pierce, and Steve
Zdancewic. 2019. From C to interaction trees: specifying, verifying, and testing a networked server. In Proceedings of the
8th ACM SIGPLAN International Conference on Certified Programs and Proofs, CPP 2019, Cascais, Portugal, January 14-15,
2019, AssiaMahboubi andMagnus O. Myreen (Eds.).ACM, 234Å›248. https://doi.org/10.1145/3293880.3294106
Leslie Lamport. 1994. The Temporal Logic of Actions. ACM Trans. Program. Lang. Syst. 16, 3 (1994), 872Å›923. https:
//doi.org/10.1145/177492.177726
K.RustanM.Leino.2010. Dafny:An AutomaticProgram VerifierforFunctional Correctness.In Logic forProgramming,
ArtificialIntelligence,andReasoning-16thInternationalConference,LPAR-16,Dakar,Senegal,April25-May1,2010,Revised
SelectedPapers (LectureNotesinComputerScience, Vol.6355) ,Edmund M.Clarkeand AndreiVoronkov(Eds.). Springer,
348Å›370. https://doi.org/10.1007/978-3-642-17511-4_20
K. Rustan M. Leino and Peter MÃ¼ller. 2009. A Basis for Verifying Multi-threaded Programs. In Programming Languages
andSystems,18thEuropeanSymposiumonProgramming,ESOP2009,HeldasPartoftheJointEuropeanConferenceson
Theory and Practice of Software, ETAPS 2009, York, UK, March 22-29, 2009. Proceedings (Lecture Notes in Computer Science,
Vol. 5502) , GiuseppeCastagna (Ed.). Springer, 378Å›393. https://doi.org/10.1007/978-3-642-00590-9_27
Xavier Leroy. 2006. Formal certification of a compiler back-end or: programming a compiler with a proof assistant.
InProceedings of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2006,
Charleston,SouthCarolina,USA,January11-13,2006 ,J.GregoryMorrisettandSimonL.PeytonJones(Eds.).ACM,42Å›54.
https://doi.org/10.1145/1111037.1111042
Mohsen Lesani, Christian J. Bell, and Adam Chlipala. 2016. Chapar: certified causally consistent distributed key-value
stores.In Proceedingsofthe43rdAnnualACMSIGPLAN-SIGACTSymposiumonPrinciplesofProgrammingLanguages,
POPL2016,St.Petersburg,FL,USA,January20-22,2016 ,RastislavBodÃ­kandRupakMajumdar(Eds.).ACM,357Å›370.
https://doi.org/10.1145/2837614.2837622
Si Liu, Atul Sandur, JosÃ© Meseguer, Peter Csaba Ã–lveczky, and Qi Wang. 2020. Generating Correct-by-Construction
Distributed Implementations from Formal Maude Designs. In NASA Formal Methods - 12th International Symposium,
NFM2020,MoffettField,CA,USA,May11-15,2020,Proceedings (LectureNotesinComputerScience,Vol.12229) ,RitchieLee,
Susmit Jha, andAnastasia Mavridou(Eds.).Springer, 22Å›40. https://doi.org/10.1007/978-3-030-55754-6_2
GavinLowe.1997. AHierarchyofAuthenticationSpecification.In 10thComputerSecurityFoundationsWorkshop(CSFWâ€™97),
June10-12,1997,Rockport,Massachusetts,USA .IEEEComputerSociety,31Å›44. https://doi.org/10.1109/CSFW.1997.596782
NancyA.LynchandFritsW.Vaandrager.1995. ForwardandBackwardSimulations:I.UntimedSystems. Inf.Comput. 121,2
(1995), 214Å›233. https://doi.org/10.1006/inco.1995.1134
William Mansky, Wolf HonorÃ©, and Andrew W. Appel. 2020. Connecting Higher-Order Separation Logic to a First-
Order Outside World. In Programming Languages and Systems - 29th European Symposium on Programming, ESOP
2020, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2020, Dublin, Ireland,
April 25-30, 2020, Proceedings (Lecture Notes in Computer Science, Vol. 12075) , Peter MÃ¼ller (Ed.). Springer, 428Å›455.
https://doi.org/10.1007/978-3-030-44914-8_16
Peter MÃ¼ller, Malte Schwerhoff, and Alexander J. Summers. 2016. Viper: A Verification Infrastructure for Permission-Based
Reasoning.In Verification,ModelChecking,andAbstractInterpretation-17thInternationalConference,VMCAI2016,St.
Petersburg, FL, USA,January 17-19,2016. Proceedings . 41Å›62.https://doi.org/10.1007/978-3-662-49122-5_2
TobiasNipkow,LawrenceC.Paulson,andMarkusWenzel.2002. Isabelle/HOL-AProofAssistantforHigher-OrderLogic .
LectureNotesin ComputerScience, Vol.2283. Springer. https://doi.org/10.1007/3-540-45949-9
Wytse Oortwijn and Marieke Huisman. 2019. Practical Abstractions for Automated Verification of Message Passing
Concurrency. In Integrated Formal Methods - 15th International Conference, IFM 2019, Bergen, Norway, December 2-6,
2019, Proceedings (Lecture Notes in Computer Science, Vol. 11918) , Wolfgang Ahrendt and Silvia Lizeth Tapia Tarifa (Eds.).
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.152:30 Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin
Springer, 399Å›417. https://doi.org/10.1007/978-3-030-34968-4_22
Matthew J. Parkinson and Gavin M. Bierman. 2005. Separation logic and abstraction. In Proceedings of the 32nd ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL 2005, Long Beach, California, USA, January
12-14,2005 , JensPalsberg andMartÃ­nAbadi (Eds.).ACM, 247Å›258. https://doi.org/10.1145/1040305.1040326
WillemPenninckx,BartJacobs,andFrankPiessens.2015.Sound,ModularandCompositionalVerificationoftheInput/Output
Behavior of Programs. In Programming Languages and Systems - 24th European Symposium on Programming, ESOP 2015,
HeldasPartoftheEuropeanJointConferencesonTheoryandPracticeofSoftware,ETAPS2015,London,UK,April11-18,2015.
Proceedings (LectureNotesinComputerScience,Vol.9032) ,JanVitek(Ed.).Springer,158Å›182. https://doi.org/10.1007/978-
3-662-46669-8_7
AdrianPerrig,PawelSzalachowski,RaphaelM.Reischuk,andLaurentChuat.2017. SCION:ASecureInternetArchitecture .
Springer. https://doi.org/10.1007/978-3-319-67080-5
Benjamin C. Pierce. 2016. The science of deep specification (keynote). In Companion Proceedings of the 2016 ACM SIGPLAN
InternationalConferenceonSystems,Programming,LanguagesandApplications:SoftwareforHumanity,SPLASH2016,
Amsterdam, Netherlands, October 30 - November 4, 2016 , Eelco Visser (Ed.). ACM, 1. https://doi.org/10.1145/2984043.
2998388
Ruzica Piskac, Thomas Wies, and Damien Zufferey. 2013. Automating Separation Logic Using SMT. In Computer Aided
Verification-25thInternationalConference,CAV2013,SaintPetersburg,Russia,July13-19,2013.Proceedings(LectureNotesin
ComputerScience,Vol.8044) ,NatashaSharyginaandHelmutVeith(Eds.).Springer,773Å›789. https://doi.org/10.1007/978-
3-642-39799-8_54
Jonathan Protzenko, Jean Karim ZinzindohouÃ©, Aseem Rastogi, Tahina Ramananandro, Peng Wang, Santiago Zanella
BÃ©guelin,AntoineDelignat-Lavaud,CatalinHritcu,KarthikeyanBhargavan,CÃ©dricFournet,andNikhilSwamy.2017.
Verified low-level programming embedded in F. PACMPL 1,ICFP(2017), 17:1Å›17:29. https://doi.org/10.1145/3110261
VincentRahli,Ivana Vukotic,MarcusVÃ¶lp, andPauloJorgeEstevesVerÃ­ssimo.2018. Velisarios:ByzantineFault-Tolerant
ProtocolsPowered by Coq. In ProgrammingLanguages and Systems - 27thEuropeanSymposiumon Programming,ESOP
2018, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2018, Thessaloniki, Greece,
April 14-20, 2018, Proceedings (Lecture Notes in Computer Science, Vol. 10801) , Amal Ahmed (Ed.). Springer, 619Å›650.
https://doi.org/10.1007/978-3-319-89884-1_22
JohnC.Reynolds.2002. SeparationLogic:ALogicforSharedMutableDataStructures.In 17thIEEESymposiumonLogic
in Computer Science (LICS 2002), 22-25 July 2002, Copenhagen, Denmark, Proceedings . IEEE Computer Society, 55Å›74.
https://doi.org/10.1109/LICS.2002.1029817
Ilya Sergey, James R. Wilcox, and Zachary Tatlock. 2018. Programming and proving with distributed protocols. PACMPL2,
POPL (2018), 28:1Å›28:30. https://doi.org/10.1145/3158116
Renato Silva and Michael J. Butler. 2010. Shared Event Composition/Decomposition in Event-B. In Formal Methods for
ComponentsandObjects-9thInternationalSymposium,FMCO2010,Graz,Austria,November29-December1,2010.Revised
Papers(LectureNotesinComputerScience,Vol.6957) ,BernhardK.Aichernig,FrankS.deBoer,andMarcelloM.Bonsangue
(Eds.).Springer, 122Å›141. https://doi.org/10.1007/978-3-642-25271-6_7
ChristophSprengerandDavidA.Basin.2018. Refiningsecurityprotocols. JournalofComputerSecurity 26,1(2018),71Å›120.
https://doi.org/10.3233/JCS-16814
Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin. 2020a.
Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed Systems Verification. CoRR
abs/2010.04749 (October2020). arXiv: 2010.04749 http://arxiv.org/abs/2010.04749
Christoph Sprenger, Tobias Klenze, Marco Eilers, Felix A. Wolf, Peter MÃ¼ller, Martin Clochard, and David Basin. 2020b.
Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification (Artifact) .
https://doi.org/10.5281/zenodo.4039826
Nikhil Swamy, Catalin Hritcu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan Bharga-
van,CÃ©dricFournet,Pierre-YvesStrub,MarkulfKohlweiss,JeanKarimZinzindohoue,andSantiagoZanellaBÃ©guelin.
2016. Dependent types and multi-monadic effects in Fâˆ—. InProceedings of the 43rd Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, POPL 2016, St. Petersburg, FL, USA, January 20 - 22, 2016 , Rastislav
BodÃ­k andRupakMajumdar(Eds.).ACM, 256Å›270. https://doi.org/10.1145/2837614.2837655
RobbertvanRenesseandRachidGuerraoui.2010. ReplicationTechniquesforAvailability.In Replication:TheoryandPractice
(Lecture Notes in Computer Science, Vol. 5959) , Bernadette Charron-Bost, Fernando Pedone, and AndrÃ© Schiper (Eds.).
Springer, 19Å›40. https://doi.org/10.1007/978-3-642-11294-2_2
JamesR.Wilcox,DougWoos,PavelPanchekha,ZacharyTatlock,XiWang,MichaelD.Ernst,andThomasE.Anderson.
2015. Verdi: aframework forimplementing andformallyverifying distributed systems. In Proceedingsof the 36th ACM
SIGPLAN Conferenceon ProgrammingLanguage Design andImplementation, Portland, OR,USA, June15-17, 2015 ,David
GroveandSteveBlackburn(Eds.).ACM, 357Å›368. https://doi.org/10.1145/2737924.2737958
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification 152:31
DougWoos,JamesR.Wilcox,SteveAnton,ZacharyTatlock,MichaelD.Ernst,andThomasE.Anderson.2016. Planningfor
changeinaformalverificationoftheRaftconsensusprotocol.In Proceedingsofthe5thACMSIGPLANConferenceon
CertifiedProgramsandProofs,SaintPetersburg,FL,USA,January20-22,2016 ,JeremyAvigadandAdamChlipala(Eds.).
ACM, 154Å›165. https://doi.org/10.1145/2854065.2854081
Li-yao Xia, Yannick Zakowski, Paul He, Chung-Kil Hur, Gregory Malecha, Benjamin C. Pierce, and Steve Zdancewic.
2020. Interaction trees: representingrecursive and impure programs inCoq. Proc. ACM Program.Lang. 4,POPL (2020),
51:1Å›51:32. https://doi.org/10.1145/3371119
Proc. ACM Program. Lang.,Vol. 4,No. OOPSLA,Article 152. Publication date: November2020.