Inverted Files for Text Search Engines
JUSTIN ZOBEL
RMIT University, Australia
AND
ALISTAIR MOFFAT
The University of Melbourne, Australia
The technology underlying text search engines has advanced dramatically in the past decade. The develop-
ment of a family of new index representations has led to a wide range of innovations in index storage, indexconstruction, and query evaluation. While some of these developments have been consolidated in textbooks,many speciﬁc techniques are not widely known or the textbook descriptions are out of date. In this tutorial,we introduce the key techniques in the area, describing both a core implementation and how the core canbe enhanced through a range of extensions. We conclude with a comprehensive bibliography of text indexingliterature.
Categories and Subject Descriptors: H.3.1 [ Information Storage and Retrieval ]: Content Analysis and
Indexing— Indexing methods ; H.3.2 [ Information Storage and Retrieval ]: Information Storage— File
orzanization ; H.3.3 [ Information Storage and Retrieval ]: Information Search and Retrieval— Query for-
mulation, retrieval models, search process ; D.4.3 [ Operating Systems ]: File Systems Management— Access
methods, ﬁle organization ; E.4 [ Coding and Information Theory ]—Data compaction and compression ;
E.5 [ Files ]—Organization/structure ; F.2.2 [ Analysis of Algorithms and Problem Complexity ]: Nonnu-
merical Algorithms and Problems— Sorting and searching ; I.7.3 [ index Generation ]
General Terms: Algorithms, Experimentation, Performance
Additional Key Words and Phrases: Inverted ﬁle indexing, document database, text retrieval, information
retrieval, Web search engine
1. INTRODUCTION
Text search is a key technology. Search engines that index the Web provide a breadth
and ease of access to information that was inconceivable only a decade ago. Text searchhas also grown in importance at the other end of the size spectrum. For example, thehelp services built into operating systems rely on efﬁcient text search, and desktopsearch systems help users locate ﬁles on their personal computers.
The Australian Research Council and the Victorian Partnership for Advanced Computing have provided
valuable ﬁnancial support as have our two home institutions.
Authors’ addresses: J. Zobel, School of Computer Science & Information Technology, RMIT University, Aus-
tralia; email: jz@cs.rmit.edu.au; A. Moffat, Department of Computer Science & Software Engineering, TheUniversity of Melbourne, Australia.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted
without fee provided that copies are not made or distributed for proﬁt or direct commercial advantage andthat copies show this notice on the ﬁrst page or initial screen of a display along with the full citation. Copy-rights for components of this work owned by others than ACM must be honored. Abstracting with credit ispermitted. To copy otherwise, to republish, to post on servers, to redistribute to lists, or to use any componentof this work in other works requires prior speciﬁc permission and/or a fee. Permissions may be requestedfrom Publications Dept., ACM, Inc., 1515 Broadway, New York, NY 10036 USA, fax: +1 (212) 869-0481, or
permissions@acm.org.
c/circlecopyrt2006 ACM 0360-0300/2006/07-ART6 $5.00 DOI: http://doi.acm.org/10.1145/
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.10.1145/1132956/1132959
1132956.11329592 J. Zobel and A. Moffat
Search engines are structurally similar to database systems. Documents are stored
in a repository, and an index is maintained. Queries are evaluated by processing theindex to identify matches which are then returned to the user. However, there are alsomany differences. Database systems must contend with arbitrarily complex queries,whereas the vast majority of queries to search engines are lists of terms and phrases.In a database system, a match is a record that meets a speciﬁed logical condition; in asearch engine, a match is a document that is appropriate to the query according to sta-tistical heuristics and may not even contain all of the query terms. Database systemsreturn all matching records; search engines return a ﬁxed number of matches, which areranked by their statistical similarity. Database systems assign a unique access key to
each record and allow searching on that key; for querying on a Web collection, there maybe many millions of documents with nonzero similarity to a query. Thus, while searchengines do not have the costs associated with operations such as relational join, thereare signiﬁcant obstacles to fast response, that is, a query term may occur in a large num-ber of the documents, and each document typically contains a large number of terms.
The challenges presented by text search have led to the development of a wide range
of algorithms and data structures. These include representations for text indexes, indexconstruction techniques, and algorithms for evaluation of text queries. Indexes basedon these techniques are crucial to the rapid response provided by the major Web searchengines. Through the use of compression and careful organization, the space neededfor indexes and the time and disk trafﬁc required during query evaluation are reducedto a small fraction of previous requirements.
In this tutorial, we explain how to implement high-performance text indexing. Rather
than explore all the alternative approaches that have been described (some specula-tive, some ineffective, and some proven in practice), we describe a simple, effectivesolution that has been shown to work well in a range of contexts. This indexing core
includes algorithms for construction of a document-level index and for basic rankedquery evaluation.
Given the indexing core, we then sketch some of the principal reﬁnements that have
been devised. These include index reorganization, phrase querying, distribution, indexmaintenance, and, in particular, index compression. The most compelling applicationof the indexing techniques described in this tutorial is their use in Web search enginesand so we brieﬂy review search in the context of the Web. In the context of the differentapproaches, we identify signiﬁcant papers and indicate their contribution.
Other research topics in text search include innovations such as metasearch, com-
pression techniques for stored documents, and improvements to fundamental technolo-gies such as sorting, storing, and searching of sets of strings. Domains of applicabilitybeyond text include genomic string searching, pattern matching, and proprietary docu-ment management systems. These developments are of wide practical importance butare beyond the scope of this tutorial.
This article has a slightly unusual structure. The citations are collected into Sec-
tion 13 which is a critical survey of work in the area. The earlier sections are free ofcitations, and reﬂect our desire to present the material as a tutorial that might be use-ful for people new to the area. To allow the corresponding citations to be accessed, thestructure within Section 13 of the previous sections. That is, Section 13 can be used asa “further reading” overview for each topic.
2. TEXT SEARCH AND INFORMATION RETRIEVAL
Search engines are tools for ﬁnding the documents in a collection that are good matchesto user queries. Typical kinds of document collection include Web pages, newspaper ar-ticles, academic publications, company reports, research grant applications, manual
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 3
pages, encyclopedias, parliamentary proceedings, bibliographies, historical records,
electronic mail, and court transcripts.
These collections range dramatically in size. The plain text of a complete set of papers
written by a researcher over ten years might occupy 10 megabytes, and the same re-searcher’s (plain text, non-spam) 10-year email archive might occupy 100 megabytes. Athousand times bigger, the text of all the books held in a small university library mightoccupy around 100 gigabytes. In 2005, the complete text of the Web was probably someseveral tens of terabytes.
Collections also vary in the way they change over time. A newswire archive or digital
library might grow only slowly, perhaps by a few thousand documents a day; deletionsare rare. Web collections, in contrast, can be highly dynamic. Fortunately, many of thesame search and storage techniques are useful for these collections.
Text is not the only kind of content that is stored in document collections. Research
papers and newspaper articles include images, email includes attachments, and Webcollections include audio and video formats. The sizes discussed previously are for textonly; the indexing of media other than text is beyond the scope of this tutorial.
Query Modes. In traditional databases, the primary method of searching is by key or
record identiﬁer. Such searching is rare in text databases. Text in some kinds of col-lections does have structured attributes such as <author> tags and metadata such as
the subject labels used for categorizing books in libraries, but these are only occasion-ally useful for content-based search and are not as useful as are keys in a relationaldatabase.
The dominant mode of text search is by its content in order to satisfy an information
need . People search in a wide variety of ways. Perhaps the commonest mode of searching
is to issue an initial query, scan a list of suggested answers, and follow pointers tospeciﬁc documents. If this approach does not lead to discovery of useful documents, theuser reﬁnes or modiﬁes the query and may use advanced querying features such asrestricting the search domain or forcing inclusion or omission of speciﬁc query terms.In this model of searching, an information need is represented by a query , and the user
may issue several queries in pursuit of one information need. Users expect to be ableto match documents according to any of the terms they contain.
Both casual users and professionals make extensive use of search engines but their
typical strategies differ. Casual users generally examine only the ﬁrst page or so re-turned by their favorite search engine, while professionals may use a range of searchstrategies and tools and are often prepared to scrutinize hundreds of potential answers.However, the same kinds of retrieval technique works for both types of searcher.
Another contrast with traditional databases is the notion of matching . A record
matches an SQL query if the record satisﬁes a logical condition. A document matchesan information need if the user perceives it to be relevant . But relevance is inexact, and
a document may be relevant to an information need even though it contains none ofthe query terms or irrelevant even though it contains them all. Users are aware thatonly some of the matches returned by the system will be relevant and that differentsystems can return different matches for the same query. This inexactitude introducesthe notion of effectiveness : informally, a system is effective if a good proportion of the
ﬁrst rmatches returned are relevant. Also, different search mechanisms have different
computational requirements and so measurement of system performance must thusconsider both effectiveness and efﬁciency.
There are many ways in which effectiveness can be quantiﬁed. Two commonly used
measures are precision andrecall , respectively the fraction of the retrieved documents
that are relevant and the fraction of relevant documents that are retrieved. There aremany other metrics in use with differing virtues and differing areas of application. In
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.4 J. Zobel and A. Moffat
Fig. 1 . TheKeeper database. It consists of six one-line documents.
this tutorial, our focus is on describing indexing techniques that are efﬁcient, and we
do not review the topic of effectiveness. Worth noting, however, is that the researchthat led to these efﬁcient indexing techniques included demonstrations that they donot compromise effectiveness.
With typical search engines, the great majority of information needs are presented
asbag-of-word queries. Many bag-of-word queries are in fact phrases such as proper
names. Some queries have phrases marked up explicitly, in quotes. Another commonapproach is to use Boolean operators such as
AND, perhaps to restrict answers to a
speciﬁc language, or to require that all query terms must be present in an answer.
Example Collections. A sample collection, used as an example through this tutorial, is
shown in Figure 1. In this Keeper database, only document 2 is about a big old house.
But with a simple matching algorithm, the bag-of-words query big old house matches
documents 2 and 3, and perhaps also documents 1 and 4 which contain old, but not the
other terms. The phrase query "big old house" would match only document 2.
Another issue is the parsing method used to extract terms from text. For example,
when HTML documents are being indexed, should the markup tags be indexed? orterms within tags? And should hyphenated terms be considered as one word or two?An even more elementary issue is whether to stem andcasefold , that is, remove variant
endings from words, and convert to lowercase. Choice of parsing technique has littleimpact, however, on indexing. On the other hand, the issue of stopping does affect
the cost of indexing and removal of common words or function words such as theand
furthermore can have a signiﬁcant effect. Confusingly, in some information retrieval
literature, the task of parsing is known as index term extraction or simply indexing. Inthis article, indexing is the task of constructing an index.
Without stemming, but with casefolding, the vocabulary of Keeper is:
and big dark did gown had house in keep keeper keeps light
never night old sleep sleeps the town where
Stemming might reduce the vocabulary to:
and big dark did gown had house in keep light never night old
sleep the town where
with the exact result dependent on the stemming method used. Stopping might then
reduce the Keeper vocabulary to:
big dark gown house keep light night old sleep town
In addition to the example Keeper collection, two hypothetical collections are used to
illustrate efﬁciency issues. The characteristics of these collections are shown in Table I,and, while they are not actual data sets, they are based on experience with real text.Speciﬁcally, they are similar to two types of collections provided by the TREC projectrun by the United States National Institute for Standards and Technology (NIST) (seetrec.nist.gov ). TREC has been a catalyst for research in information retrieval since
1992, and without it, robust measurement of the techniques described in this tutorial
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 5
Table I. Characteristics of Two Hypothetical Text Databases, Used as
Examples in This Tutorial
NewsWire Web
Size (gigabytes) 1 100Documents 400,000 12,000,000Word occurrences (without markup) 180,000,000 11,000,000,000Distinct words (after stemming) ..., 400,000 16,000,000
per document, totaled 70,000,000 3,500,000,000
would have been difﬁcult or impossible. The last line in the table is the number of
distinct word-document pairs, that is, the number of word occurrences when duplicateswithin a document are not counted.
Most of the costs required for additional structures scale more or less linearly for col-
lections larger than a gigabyte. For example, in Web data, new distinct words continueto occur at a typical rates of about one per 500–1000 word occurrences. Typical queryterms occur in 0 .1%–1% of the indexed documents.
Taking all of these factors into account, implementors of search engines must design
their systems to balance a range of technical requirements:
—effective resolution of queries;
—use of features of conventional text, such as query term proximity, that improve
effectiveness;
—use of features of hyperlinked text, such as anchor strings and URL terms, that
improve effectiveness;
—fast resolution of queries;—minimal use of other resources (disk, memory, bandwidth);—scaling to large volumes of data;—change in the set of documents; and—provision of advanced features such as Boolean restriction and phrase querying.
This tutorial describes techniques for supporting all of these requirements.
Similarity Measures. All current search engines use ranking to identify potential an-
swers. In a ranked query, a statistical similarity heuristic or similarity measure is used
to assess the closeness of each document to the textual query. The underlying principleis that the higher the similarity score awarded to a document, the greater the estimatedlikelihood that a human would judge it to be relevant. The r“most similar according to
the heuristic” documents are returned to the user as suggested answers. To describe theimplementation of text retrieval, we ﬁrst consider evaluation of bag-of-words queriesin which similarity is determined by simple statistics. In Section 4, we extend thesetechniques to phrase queries.
Most similarity measures use some composition of a small number of fundamental
statistical values:
—f
d,t, the frequency of term tin document d;
—fq,t, the frequency of term tin the query;
—ft, the number of documents containing one or more occurrences of term t;
—Ft, the number of occurrences of term tin the collection;
—N, the number of documents in the collection; and
—n, the number of indexed terms in the collection.
These basic values are combined in a way that results in three monotonicity observa-
tions being enforced.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.6 J. Zobel and A. Moffat
(1) Less weight is given to terms that appear in many documents;
(2) More weight is given to terms that appear many times in a document; and(3) Less weight is given to documents that contain many terms.
The intention is to bias the score towards relevant documents by favoring terms that ap-
pear to be discriminatory and reducing the impact of terms that appear to be randomlydistributed.
A typical older formulation that is effective in practice calculates the cosine of the
angle in n-dimensional space between a query vector /angbracketleftw
q,t/angbracketrightand a document vector
/angbracketleftwd,t/angbracketright. There are many variations of the cosine formulation. An example is:
wq,t=ln/parenleftbigg
1+N
ft/parenrightbigg
wd,t=1+lnfd,t
Wd=/radicalbigg/summationdisplay
tw2
d,tWq=/radicalBig/summationtext
tw2
q,t
Sq,d=/summationtext
twd,t·wq,t
Wd·Wq.(1)
The term Wqcan be neglected as it is a constant for a given query and does not affect
the ordering of documents. Variations on this theme are to avoid use of logarithms, orreplace Nby max
t{ft}in the expression for wq,t, or multiply the query-term weights
wq,tby 1+lnfq,twhen queries are long, or use a different way of combining wq,tand
wd,t, or take Wdto be the length of the document in words or in bytes, and so on.
What all of these variants share is that the quantity wq,ttypically cap-
tures the property often described as the inverse document frequency of theterm, or IDF, while w
d,tcaptures the term frequency, or TF, hence the common
description of similarity measures as TF ×IDF formulations. Observing that the neg-
ative log of a probability is the information content, the score assigned to a documentcan very loosely be interpreted from an entropy-based perspective as being a sum ofinformation conveyed by the query terms in that document, which maps to the sameordering as the product of their respective probabilities.
Similarity formulations that are directly grounded in statistical principles have also
proven successful in TREC. The best known of these is the Okapi computation,
w
q,t=ln/parenleftbiggN−ft+0.5
ft+0.5/parenrightbigg
·(k3+1)·fq,t
k3+fq,t
wd,t=(k1+1)fd,t
Kd+fd,t
Kd=k1/parenleftbigg
(1−b)+bWd
WA/parenrightbigg
(2)
Sq,d=/summationdisplay
t∈qwq,t·wd,t,
in which the values k1andbare parameters, set to 1 .2 and 0 .75 respectively; k3is a
parameter that is set to ∞, so that the expression ( k3+1)·fq,t//parenleftbig
k3+fq,t/parenrightbig
is assumed to
be equivalent to fq,t; and WdandWAare the document length and average document
length, in any suitable units.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 7
Fig. 2 . Exhaustive computation of cosine similarity between a query qand
every document in a text collection. This approach is suitable only when thecollection is small or is highly dynamic relative to the query rate.
More recent probabilistic approaches are based on language models. There are many
variants; a straightforward language-model formulation is:
wd,t=log/parenleftbigg|d|
|d|+μ·fd,t
|d|+μ
|d|+μ·Ft
|C|/parenrightbigg
(3)
Sq,d=/summationdisplay
t∈qfq,t·wd,t,
where |d|(respectively, |C|) is the number of term occurrences in document d(respec-
tively, collection C) and μis a parameter, typically set to 2500. The left-hand side of
the sum is the observed likelihood of the term in the document, while the right-handside modiﬁes this (using Dirichlet smoothing) by combining it with the observed like-lihood of the term in the collection. Taking the smoothed value as an estimate of theprobability of the term in the document, this formulation is rank equivalent to orderingdocuments by the extent to which the query’s entropy in the document’s model differsfrom the query’s entropy in the collection as a whole.
In this language-model formulation, the value w
d,tis nonzero even if tis not in d,
presenting difﬁculties for the term-ordered query evaluation strategies we explain later.However, this problem can be addressed by transforming it into a rank-equivalentmeasure:
S
q,drank=|q|·log/parenleftbiggμ
|d|+μ/parenrightbigg
+/summationdisplay
t∈q∧d/parenleftbigg
fq,t·log/parenleftbiggfd,t
μ·|C|
Ft+1/parenrightbigg/parenrightbigg
, (4)
where the term-oriented component log(1 +(fd,t/μ)·(|C|/Ft)) is zero when tis not in d.
In all of these formulations, documents can score highly even if some of the query
terms are missing. This is a common attribute of similarity heuristics. We do not exploresimilarity formulations in detail and take as our brief the need to implement a systemin which any such computation can be efﬁciently computed.
Given a formulation, ranking a query against a collection of documents is in principle
straightforward: each document is fetched in turn, and the similarity between it andthe query calculated. The documents with the highest similarities can then be returnedto the user. An algorithm for exhaustive ranking using the cosine measure is shown inFigure 2.
The drawback of this approach is that every document is explicitly considered, but
for typical situations in which r/lessmuchN, only a tiny fraction of documents are re-
turned as answers. For most documents, the vast majority of similarity values are
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.8 J. Zobel and A. Moffat
insigniﬁcant. The exhaustive approach does, however, illustrate the main features of
computing a ranking, and, with a simple reorganization, a more efﬁcient computationcan be achieved based on the key observation that, to have a nonzero score, a documentmust contain at least one query term.
3. INDEXING AND QUERY EVALUATION
Fast query evaluation makes use of an index : a data structure that maps terms to the
documents that contain them. For example, the index of a book maps a set of selectedterms to page numbers. With an index, query processing can be restricted to documentsthat contain at least one of the query terms.
Many different types of index have been described. The most efﬁcient index structure
for text query evaluation is the inverted ﬁle : a collection of lists, one per term, recording
the identiﬁers of the documents containing that term. Other structures are brieﬂyconsidered in Section 11, but they are not useful for general-purpose querying.
Baseline Inverted File. An inverted ﬁle index consists of two major components. The
search structure orvocabulary stores for each distinct word t,
—a count ftof the documents containing t, and
—a pointer to the start of the corresponding inverted list .
Studies of retrieval effectiveness show that all terms should be indexed, even numbers.
In particular, experience with Web collections shows that any visible component ofa page might reasonably be used as a query term, including elements such as thetokens in the URL. Even stopwords—which are of questionable value for bag-of-wordsqueries—have an important role in phrase queries.
The second component of the index is a set of inverted lists where each list stores for
the corresponding word t,
—the identiﬁers dof documents containing t, represented as ordinal document num-
bers; and
—the associated set of frequencies f
d,tof terms tin document d.
The lists are represented as sequences of /angbracketleftd,fd,t/angbracketrightpairs. As described, this is a document-
level index in that word positions within documents are not recorded. Together with an
array of Wdvalues (stored separately), these components provide all the information
required for both Boolean and ranked query evaluation. A complete inverted ﬁle for theKeeper database is shown in Figure 3.
In a complete text database system, there are several other structures, including
the documents themselves and a table that maps ordinal document numbers to disklocations (or other forms of document locator such as a ﬁlename or other key). We donot explore these structures in this tutorial.
In a simple representation, for the NewsWire data, the total index size would be
approximately 435MB (megabytes) or around 40% of the size of the original data. Thisis comprised of 12MB for 400,000 words, pointers, and counts; 1 .6MB for 400,000 W
d
values; 280MB for 70,000,000 document identiﬁers (four bytes each); and 140MB for
70,000,000 document frequencies (two bytes each). For the Webdata, the total size is
about 21GB (gigabytes) or just over 20% of the original text. The difference betweenthese two collections is a consequence of Web pages tending to contain large volumesof unindexed markup.
An assumption made in these calculations is that each inverted list is stored contigu-
ously. The alternative is that lists are composed of a sequence of blocks that are linkedor indexed in some way. The assumption of contiguity has a range of implications. First,
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 9
Fig. 3 . Complete document-level inverted ﬁle for
theKeeper database. The entry for each term tis
composed of the frequency ftand a list of pairs, each
consisting of a document identiﬁer dand a document
frequency fd,t. Also shown are the Wdvalues as com-
puted for the cosine measure shown in Equation 1.
it means that a list can be read or written in a single operation. Accessing a sequence
of blocks scattered across a disk would impose signiﬁcant costs on query evaluationas the list for a typical query term on the Webdata would occupy 100kB (kilobytes) to
1MB, and the inverted list for a common term could be many times this size. Addingto the difﬁculties for the great majority of terms, the inverted list is much less thana kilobyte, placing a severe constraint on feasible size for a ﬁxed-size block. Second,no additional space is required for next-block pointers. Third, index update proceduresmust manage variable-length fragments that vary enormously in size, from tiny to vast;our experience, however, is that the beneﬁts of contiguity greatly outweigh these costs.
An issue that is considered in detail in Section 8 is how to represent each stored value
such as document numbers and in-document frequencies. The choice of any ﬁxed num-ber of bits or bytes to represent a value is clearly arbitrary and has potential implica-tions for scaling (ﬁxed-length values can overﬂow) and efﬁciency (inﬂation in the volumeof data to be managed). Using the methods described later in this article, large gains inperformance are available through the use of compressed representations of indexes.
To facilitate compression, d-gaps are stored rather than straight document identi-
ﬁers. For example, the sorted sequence of document numbers
7, 18, 19, 22, 23, 25, 63, ...
can be represented by gaps
7, 11, 1, 3, 1, 2, 38, ... .
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.10 J. Zobel and A. Moffat
Fig. 4 . Indexed computation of cosine similarity between a query qand a text
collection.
Fig. 5 . Using an inverted ﬁle and a set of accumulators to calculate document similarity scores.
While this transformation does not reduce the maximum magnitude of the stored num-
bers, it does reduce the average, providing leverage for the compression techniquesdiscussed later. Section 8 gives details of mechanisms that can exploit the advantagethat is created by gaps.
Baseline Query Evaluation. Ranking using an inverted ﬁle is described in Figure 4
and illustrated in Figure 5. In this algorithm, the query terms are processed one at atime. Initially each document has a similarity of zero to the query; this is representedby creating an array AofNpartial similarity scores referred to as accumulators , one
for each document d. Then, for each term t, the accumulator A
dfor each document d
mentioned in t’s inverted list is increased by the contribution of tto the similarity of d
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 11
to the query. Once all query terms have been processed, similarity scores Sdare calcu-
lated by dividing each accumulator value by the corresponding value of Wd. Finally, the
rlargest similarities are identiﬁed, and the corresponding documents returned to the
user.
The cost of ranking via an index is far less than with the exhaustive algorithm
outlined in Figure 2. Given a query of three terms, processing a query against the Web
data involves ﬁnding the three terms in the vocabulary; fetching and then processingthree inverted lists of perhaps 100kB to 1MB each; and making two linear passes overan array of 12,000,000 accumulators. The complete sequence requires well under asecond on current desktop machines.
Nonetheless, the costs are still signiﬁcant. Disk space is required for the index at
20%–60% of the size of the data for an index of the type shown in Figure 3; memory is
required for an accumulator for each document and for some or all of the vocabulary;CPU time is required for processing inverted lists and accumulators; and disk trafﬁc
is used to fetch inverted lists. Fortunately, compared to the implementation shown inFigure 4, all of these costs can be dramatically reduced.
Indexing Word Positions. We have described inverted lists as sequences of index entries,
each a /angbracketleftd,fd,t/angbracketrightpair. An index of this form is document-level since it indicates whether a
term occurs in a document but does not contain information about precisely where theterm appears. Given that the frequency f
d,trepresents the number of occurrences of t
ind, it is straightforward to modify each entry to include the fd,tordinal word positions
pat which toccurs in dand create a word-level inverted list containing pointers of the
form/angbracketleftd,fd,t,p1,...,pfd,t/angbracketright. Note that in this representation positions are word counts,
not byte counts, so that they can be used to determine adjacency.
Word positions can be used in a variety of ways during query evaluation. Section 4
discusses one of these, phrase queries in which the user can request documents witha sequence rather than bag-of-words. Word positions can also be used in bag-of-wordqueries, for example, to prefer documents where the terms are close together or areclose to the beginning of the document. Similarity measures that make use of suchproximity mechanisms have not been particularly successful in experimental settingsbut, for simple queries, adjacency and proximity do appear to be of value in Webretrieval.
If the source document has a hierarchical structure, that structure can be reﬂected
by a similar hierarchy in the inverted index. For example, a document with a structureof chapters, sections, and paragraphs might have word locations stored as ( c,s,p,w)
tuples coded as a sequence of nested runs of c-gaps, s-gaps, p-gaps, and w-gaps. Such
an index allows within-same-paragraph queries as well as phrase queries, for example,and with an appropriate representation, is only slightly more expensive to store thana nonhierarchical index.
Core Ideas. To end this section, we state several key implementation decisions.
—Documents have ordinal identiﬁers, numbered from one.
—Inverted lists are stored contiguously.—The vocabulary consists of every term occurring in the documents and is stored in a
simple extensible structure such as a B-tree.
—An inverted list consists of a sequence of pairs of document numbers and in-document
frequencies, potentially augmented by word positions.
—The vocabulary may be preprocessed, by stemming and stopping.—Ranking involves a set of accumulators and term-by-term processing of inverted lists.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.12 J. Zobel and A. Moffat
This set of choices constitutes a core implementation in that it provides an approach that
is simple to implement and has been used in several public-domain search systems and,we believe, many proprietary systems. In the following sections, we explore extensionsto the core implementation.
4. PHRASE QUERYING
A small but signiﬁcant fraction of the queries presented to Web search engines includean explicit phrase, such as "philip glass" opera or"the great flydini" . Users also
often enter phrases without explicit quotes, issuing queries such as Albert Einstein or
San Francisco hotel . Intuitively it is appealing to give high scores to pages in which
terms appear in the same order and pattern as they appear in the query, and low scoresto pages in which the terms are separated.
When phrases are used in Boolean queries, it is clear what is intended—the phrase
itself must exist in matching documents. For example, the Boolean query old "night
keeper" would be evaluated as if it contains two query terms, one of which is a phrase,
and both terms would be required for a document to match.
In a ranked query, a phrase can be treated as an ordinary term, that is, a lexical entity
that occurs in given documents with given frequencies, and contributes to the similarityscore for that document when it does appear. Similarity can therefore be computed inthe usual way, but it is ﬁrst necessary to use the inverted lists for the terms in thephrase to construct an inverted list for the phrase itself, using a Boolean intersectionalgorithm. A question for information retrieval research (and outside the scope of thistutorial) is whether this is the best way to use phrases in similarity estimation. A goodquestion for this tutorial is how to ﬁnd—in a strictly Boolean sense—the documents inwhich a given sequence of words occur together as a phrase since, regardless of howthey are eventually incorporated into a matching or ranking scheme, identiﬁcation ofphrases is the ﬁrst step.
An obvious possibility is to use a parser at index construction time that recognizes
phrases that might be queried and to index them as if they were ordinary documentterms. The set of identiﬁed phrases would be added to the vocabulary and have theirown inverted lists; users would then be able to query them without any alteration toquery evaluation procedures. However, such indexing is potentially expensive. Thereis no obvious mechanism for accurately identifying which phrases might be used inqueries, and the number of candidate phrases is enormous since even the number ofdistinct two-word phrases grows far more rapidly than the number of distinct terms.The hypothetical Webcollection shown in Table I could easily contain a billion distinct
two-word pairs.
Three main strategies for Boolean phrase query evaluation have been developed.
—Process phrase queries as Boolean bags-of-words so that the terms can occur any-
where in matching document, then postprocess the retrieved documents to eliminatefalse matches.
—Add word positions to some or all of the index entries so that the locations of terms
in documents can be checked during query evaluation.
—Use some form of partial phrase index or word-pair index so that phrase appearances
can be directly identiﬁed.
These three strategies can complement each other. However, a pure bag-of-words ap-
proach is unlikely to be satisfactory since the cost of fetching just a few nonmatchingdocuments could exceed all other costs combined, and, for many phrases, only a tinyfraction of the documents that contain the query words also contain them as a phrase.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 13
Phrase Query Evaluation. When only document-level querying is required, inclusion of
positional information in the index not only takes space, but also slows query processingbecause of the need to skip over the positional information in each pointer. And, asdiscussed in more detail in the following, if bag-of-words ranked queries are to besupported efﬁciently, then other index organizations, such as frequency- and impact-sorted arrangements, need to be considered.
Taken together, these considerations suggest that maintenance of two separate in-
dexes may be attractive, a word-level index for Boolean searching and phrase identiﬁ-cation, and a document-level impact- or frequency-sorted index for processing rankedqueries. Given that document-level indexes are small, the space overhead of havingmultiple indexes is low. Separating the indexes also brings ﬂexibility and allows con-sideration of index structures designed explicitly for phrases.
Many phrases include common words. The cost of phrase query processing using a
word-level inverted index is then dominated by the cost of fetching and decoding listsfor those words which typically occur at the start of or in the middle of a phrase—consider "the house in the town" , for example. One way of avoiding this problem
would be to neglect certain stop words and index them at the document-level only. Forexample, to evaluate the query "the house in the town" processing could proceed by
intersecting the lists for house , andtown , looking for positions pofhouse such that town
is at p+3. False matches could be eliminated by post-processing, that is, by fetching
candidate documents and examining them directly. The possibility of false matchescould also simply be ignored. However, in some phrase queries, the common words playan important semantic role and must be included.
Phrase Indexes. It is also possible to build a complete index of two-word phrases using
a hierarchical storage structure to avoid an overly large vocabulary. Experiments showthat such an index occupies around 50% of the size of the source data, that is, perhaps50GB for the Webcollection. The inverted lists for phrases are on average much shorter
than those of the individual words, but there are many more of them, and the vocabularyis also much bigger.
Using a two-word phrase index, evaluation of the phrase query "the house in the
town" (which matches line three of the Keeper collection) involves processing the in-
verted lists for, say, the phrases "the house" ,"house in" , and"the town" . The pair
"in the" is also a phrase but is covered by the others and—making an arbitrary choice
between this phrase and "house in" —its inverted list does not need to be processed.
For phrases composed of rare words, having a phrase index yields little advantage,
as processing savings are offset by the need to access a much larger vocabulary. Asuccessful strategy is to have an index for word pairs that begin with a common wordand combine it with a word-level inverted index. For example, the preceding query couldbe evaluated by intersecting the inverted lists for "the house" ,in, and"the town" .A n
index of all word pairs beginning with any one of the three commonest words is about 1%of the size of the Webdata but allows phrase querying time to be approximately halved.
5. INDEX CONSTRUCTION
The single key problem that makes index construction challenging is that the volume
of data involved cannot be held in main memory in a dynamic data structure of thekind typically used for cross-reference generation. The underlying task that needs to beperformed is essentially that of matrix transposition. But the documents–terms matrixis very sparse, and is far too large to be manipulated directly as an array. Instead, indexconstruction techniques make use of index compression methods and either distributiveor comparison-based sorting techniques.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.14 J. Zobel and A. Moffat
Fig. 6 . In-memory inversion.
In-Memory Inversion. A simple in-memory inversion algorithm is shown in Figure 6.
The key idea is that a ﬁrst pass through the documents collects term frequency infor-mation, sufﬁcient for the inverted index to be laid out in memory in template form. Asecond pass then places pointers into their correct positions in the template, makinguse of the random-access capabilities of main memory. The advantage of this approachis that almost no memory is wasted compared to the ﬁnal inverted ﬁle size since thereis negligible fragmentation. In addition, if compression is used, the index can be repre-sented compactly throughout the process. This technique is viable whenever the mainmemory available is about 10%–20% greater than the combined size of the index andvocabulary that are to be produced. It is straightforward to extend the in-memory al-gorithm to include word positions, but the correspondingly larger ﬁnal index will morequickly challenge the memory capacity of whatever hardware is being used since indi-vidual list entries may become many kilobytes long.
It is also possible to extend the in-memory technique to data collections where index
size exceeds memory size by laying out the index skeleton on disk, creating a sequenceof partial indexes in memory, and then transferring each in a skip-sequential mannerto a template that has been laid out as a disk ﬁle. With this extended method, andmaking use of compression, indexes can be built for multi-gigabyte collections usingaround 10–20MB of memory beyond the space required for a dynamic vocabulary.
Sort-Based Inversion. A shortcoming of two-pass techniques of the kind sketched in
Figure 6 is that document parsing and fetching is a signiﬁcant component of index con-struction costs, perhaps half to two-thirds of the total time for Web data. The documentscould be stored parsed during index construction, but doing so implies substantial diskoverheads, and the need to write the parsed text may outweigh the cost of the secondparsing.
Other index construction methods are based on explicit sorting . In a simple form of
this approach, an array or ﬁle of /angbracketleftt,d,f
d,t/angbracketrighttriples is created in document number order,
sorted into term order, and then used to generate the ﬁnal inverted ﬁle.
With careful sequencing and use of a multiway merge, the sort can be carried out in-
place on disk using compressed blocks. The disk space overhead is again about 10% ofthe ﬁnal compressed index size, and memory requirements and speed are also similarto partitioned inversion. As for partitioned inversion, the complete vocabulary must bekept in memory, limiting the volume of data that can be indexed on a single machine.
Merge-Based Inversion. As the volumes of disk and data grow, the cost of keeping the
complete vocabulary in memory is increasingly signiﬁcant. Eventually, the index mustbe created as an amalgam of smaller parts, each of which is constructed using one of the
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 15
Fig. 7 . Merge-based inversion.
Fig. 8 . Merge-build process.
previous techniques or using purely in-memory structures. Figures 7 and 8 illustrate
this process.
In merge-based inversion, documents are read and indexed in memory until a ﬁxed
capacity is reached. Each inverted list needs to be represented in a structure that cangrow as further information about the term is encountered, and dynamically resizablearrays are the best choice. When memory is full, the index (including its vocabulary) isﬂushed to disk as a single runwith the inverted lists in the run stored in lexicographic
order to facilitate subsequent merging. As runs are never queried, the vocabulary of arun does not need to be stored as an explicit structure; each term can, for example, bewritten at the head of its inverted list. Once the run is written, it is entirely deletedfrom memory so that construction of the next run begins with an initially emptyvocabulary.
When all documents have been processed, the runs are merged to give the ﬁnal index.
The merging process builds the ﬁnal vocabulary on the ﬂy and, if a large read bufferis allocated to each run, is highly efﬁcient in terms of disk accesses. If disk space isscarce, the ﬁnal index can be written back into the space occupied by the runs as theyare processed as the ﬁnal index is typically a little smaller than the runs—vocabulary
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.16 J. Zobel and A. Moffat
information is not duplicated, and the ﬁnal inverted lists can be represented more
efﬁciently.
Merge-based index construction is practical for collections of all sizes. In particular,
it scales well and operates effectively in as little as 100MB of memory. In addition, diskspace overheads can be restricted to a small fraction of the ﬁnal index; only one parsingpass is required over the data; and the method extends naturally to phrase indexing.Finally, the compression techniques described in Section 8 can further reduce the costof index construction by reducing the number of runs required.
6. INDEX MAINTENANCE
Inserting one document into a text databases involves, in principle, adding a few bytesto the end of every inverted list corresponding to a term in the document. For a documentof reasonable size, such an insertion involves fetching and slightly extending severalhundred inverted lists and is likely to require 10–20 seconds on current hardware.In contrast, with merge-based inversion, the same hardware can index around 1,000documents per second. That is, there is a 10,000-fold disparity in cost between thesetwo approaches.
For fast insertion, it is necessary to avoid accessing the disk-resident inverted lists of
each term. The only practical solution is to amortize the update costs over a sequence ofinsertions. The properties of text databases, fortunately, allow several strategies for costamortization. In particular, for ranking, it is not always necessary for new documents tobe immediately available for searches. If they are to be searchable, new documents canbe made available through a temporary in-memory index—in effect, the last subindexin the merging strategy.
Three broad categories of update strategies are available: rebuild from scratch, merge
an existing index with an index of new documents, and incremental update.
Rebuild. In some applications, the index may not to be updated online at all. Instead,
it can be periodically rebuilt from scratch. Consider, for example, a university Website. New documents are only discovered through crawling and immediate update isnot essential. For a gigabyte of data, rebuilding takes just a few minutes, a small costcompared to that of fetching the documents to index.
Intermittent Merge. The inverted lists for even large numbers of documents can easily
be maintained in the memory of a standard desktop computer. If the lists are in memory,it is cheap to insert new documents as they arrive; indeed, there is no difference betweenmaintaining such lists and the algorithm described in Figure 7.
If existing documents are indexed in a standard inverted ﬁle and new documents are
indexed in memory, the two indexes can share a common vocabulary, and all documentscan be made available to queries via a straightforward adaptation of the methods de-scribed earlier. Then when memory is full, or some other criterion is met, the in-memoryindex is merged with the on-disk index. The old index can be used until the merge iscomplete, at the cost of maintaining two complete copies of the inverted lists. During themerge either a new in-memory index must be created or insertions must temporarily beblocked, and thus, during the merge, new documents are only available via exhaustivesearch.
It was argued earlier that inverted lists should be stored contiguously as accessing a
large number of blocks would be a dominant cost of query evaluation. However, if thenumber of blocks is constrained (for instance, an average of three per term), the timeto evaluate queries can similarly be controlled. In addition, if the index is arranged asa sequence of subindexes, each one no greater than a given fraction of the size of thenext (that is, the sizes form a geometric sequence), then only a small part of the indexis involved in most merge operations. This combination of techniques allow an index to
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 17
be built incrementally, and be simultaneously available for querying, in just twice the
time required by an ofﬂine merge-based build.
Incremental Update. A ﬁnal alternative is to update the main index term by term, as
and when opportunity arises, with some terms’ in-memory lists covering more docu-ments than others’. This process is similar to the mechanisms used for maintainingvariable-length records in a conventional database system. In such an asynchronousmerge, a list is fetched from disk, the new information is integrated into the list, andthe list is then written back. Using standard free-space management, the list can eitherbe written back in place or, if there is insufﬁcient space, written to a new location.
The per-list updates should be deferred for as long as possible to minimize the number
of times each list is accessed. The simplest approach is to process as for the mergingstrategy and, when a memory limit is reached, then proceed through the whole index,amending each list in turn. Other possibilities are to update a list only when it is fetchedin response to a query or to employ a background process that slowly cycles through thein-memory index, continuously updating entries. In practice, these methods are not asefﬁcient as intermittent merge, which processes data on disk sequentially.
Choosing an Update Strategy. For reasonable collection sizes, merging is the most efﬁ-
cient strategy for update but has the drawback of requiring signiﬁcant disk overheads.It allows relatively simple recovery as reconstruction requires only a copy of the indexand the new documents. In contrast, incremental update proceeds in place with somespace lost due to fragmentation. But recovery in an incremental index may be complexdue to the need to track which inverted lists have been modiﬁed.
For smaller, relatively static collections, the cost of rebuild may exceed that of other
methods, but still be of little consequence compared to the other costs of maintainingthe database. And if the collection is highly dynamic, such as a Web site in whichdocuments are edited as well as inserted, then inserting or deleting a single word in adocument may affect all the word positions, for example, and rebuild may be the onlyplausible option.
7. DISTRIBUTED INFORMATION RETRIEVAL
When large volumes of data are involved or when high query volumes must be sup-ported, one machine may be inadequate to support the load even when the variousenhancements surveyed earlier are incorporated. For example, in mid-2004, the Googlesearch engine processed more than 200 million queries a day against more than 20TBof crawled data, using more than 20,000 computers.
To handle the load, a combination of distribution and replication is required. Dis-
tribution refers to the fact that the document collection and its index are split across
multiple machines and that answers to the query as a whole must be synthesized fromthe various collection components. Replication (ormirroring ) then involves making
enough identical copies of the system so that the required query load can be handled.
Document-Distributed Architectures. The simplest distribution regime is to partition the
collection and allocate one subcollection to each of the processors. A local index isbuilt for each subcollection; when queries arrive, they are passed to every subcollec-tion and evaluated against every local index. The sets of subcollection answers arethen combined in some way to provide an overall set of answers. The advantages ofsuch a document partitioned system are several; collection growth is accommodated
by designating one of the hosts as the dynamic collection so that only it needs torebuild its index; and the computationally expensive parts of the process are dis-tributed equally across all of the hosts in the computer cluster. The dashed region
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.18 J. Zobel and A. Moffat
Fig. 9 . Two ways in which the index of Figure 3 might be partitioned and distributed across a cluster of
machines.
in Figure 9 shows one component of a document-distributed retrieval system with
this one processor indexing all terms that appear in the ﬁrst two documents of thecollection.
Term-Distributed Architectures. An alternative strategy is term partitioning . In a term-
partitioned index, the index is split into components by partitioning the vocabulary,with one possible partition shown by the dotted horizontal split in Figure 9. Eachprocessor has full information about a subset of the terms, meaning that to handle aquery, only the relevant subset of the processors need to respond. Term partitioninghas the advantage of requiring fewer disk seek and transfer operations during queryevaluation than document-partitioning because each term’s inverted list is still storedcontiguously on a single machine rather than in fragments across multiple machines.On the other hand, those disk transfer operations each involve more data. More sig-niﬁcantly, in a term-partitioned arrangement, the majority of the processing load fallsto the coordinating machine, and experiments have shown that it can easily become abottleneck and starve the other processors of work.
Choosing a Distribution Strategy. Document distribution typically results in a better
balance of workload than does term partitioning and achieves superior query through-put. It also allows more naturally for index construction and for document insertion.On the other hand, index construction in a term-partitioned index involves ﬁrst of alldistributing the documents and building a document-partitioned index, and then ex-changing index fragments between all pairs of processors after the vocabulary splithas been negotiated. Document distribution also has the pragmatic advantage of stillallowing a search service to be provided even when one of the hosts is ofﬂine for somereason since any answers not resident on that machine remain available to the system.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 19
On the other hand, in a term-distributed system, having one machine ofﬂine is likely
to be immediately noticeable.
The Google implementation uses a document-partitioned index with massive repli-
cation and redundancy at all levels: the machine, the processor cluster, and the site.
It is also worth noting that document partitioning remains effective even if the collab-
orating systems are independent and unable to exchange their index data. A distributedsystem in which a ﬁnal result answer list is synthesized from the possibly-overlappinganswer sets provided by a range of different services is called a metasearcher .
8. EFFICIENT INDEX REPRESENTATIONS
A central idea underpinning several aspects of efﬁcient indexing and query processing
is the use of compression. With appropriate compression techniques, it is possible tosimultaneously reduce both space consumption and disk trafﬁc. Compression also re-duces overall query evaluation time. This section introduces a range of integer codingtechniques, and describes their use in inverted ﬁle compression.
Compact Storage of Integers. In a simple implementation of an inverted ﬁle index, 32-bit
and 16-bit integers might be used respectively for document identiﬁers and term fre-quencies since these sizes are universally supported by compilers and are large enoughto hold the likely values. However, ﬁxed-width integers are not particularly space-efﬁcient, and large savings can be obtained using quite simple compression techniques.
An efﬁcient representation for an inverted list requires a method for coding integers
in a variable number of bits. Using a ﬁxed number of bits for each number, whether 32or 20, is inconvenient: it limits the maximum value that can be stored, and is wasteful ifmost numbers are small. Variable-length codes can be inﬁnite, avoiding the problem ofhaving a ﬁxed upper bound; and can be constructed to favor small values at the expenseof large.
Parameterless Codes. The simplest variable-bit inﬁnite code is unary which represents
the value x>0a s x−1“1” bits followed by a terminating “ 0” bit.
Unary is an example of a ﬁxed code corresponding to a ﬁxed distribution and is
unparameterized. Other unparameterized codes for integers are Elias’ gamma and
delta codes. In the gamma code, integer x>0 is factored into 2e+dwhere e=⌊log2x⌋,
and 0 ≤d<2e. The codeword is formed as the concatenation of e+1 represented in
unary and drepresented in binary in ebits. In the delta code, the value of e+1i s
represented using the gamma code and is followed by din binary, as for gamma.
In both codes, each codeword has two parts, a preﬁx and a sufﬁx. The preﬁx indicates
the binary magnitude of the value and tells the decoder how many bits there are in thesufﬁx part. The sufﬁx indicates the value of the number within the corresponding binaryrange. Table II gives some example codewords for each of these three unparameterizedcodes. The colons used in the codewords to separate the preﬁx and sufﬁx parts arepurely illustrative.
Which code is preferable depends on the probability distribution Pr( x) governing the
values xthat are being coded. Using Shannon’s relationship between the probability of
a symbol and its ideal codeword length, len( x)=−log
2Pr(x), it can be seen that unary
corresponds to the probability distribution Pr( x)=2−x. That is, when half of all values
are the number 1, a quarter are 2, an eighth are 3, and so on, then unary is the mostefﬁcient coding mechanism. When approximately half of all values are the number 1, aquarter are (equally one of) 2 or 3, an eighth are (equally one of) 4, 5, 6, or 7, and so on,and in general Pr( x)≈1/(2x
2), then gamma is the most efﬁcient coding mechanism.
However, inspecting a sequence of bits one by one is relatively costly on machines for
which the basic unit of access is multiples of eight bits. If each code occupies a sequence
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.20 J. Zobel and A. Moffat
Table II. Example Codewords Using the Unary, Gamma, and Delta Codes
value unary gamma delta
10 0: 0::
210 10:0 10:0:0
3110 10:1 10:0:1
41110 110:00 10:1:00
101111111110 1110:010 110:00:010
100 1111110:100100 110:11:100100
1,000 1111111110:111101000 1110:010:111101000
Colons are used as a guide to show the preﬁx and sufﬁx components in
each codeword. All three codes can represent arbitrarily large numbers;the unary codewords for 100 and 1,000 are omitted only because of theirlength.
Fig. 10 . Encoding and decoding variable-length
byte-aligned codes. Input values to the encoder mustsatisfy x≥1.
of whole bytes, the bit operations can be eliminated. With this in mind, another simple
unparameterized code is to use a sequence of bytes to code a value x≥1, shown in
Figure 10. The idea is very simple: if x≤128, then a single byte is used to represent
x−1 in binary, with a leading “ 0” bit; otherwise, the low-order seven bits of x−1 are
packed into a byte with a leading “ 1” bit, and the quantity ( xdiv 128) is recursively
coded the same way.
Thus the byte 2, with the bit-pattern 0000 0010 , represents the integer 3; the byte
9, with the bit-pattern 0000 1001 , represents the (decimal) integer 10; and the double-
byte 147:7, with the bit-pattern 1110 0111 :0000 0111 , represents 1044 since 1044 =
128×(7+1)+(147−127). This approach is a form of gamma code in which the sufﬁx
length is a multiple of seven instead of a multiple of one. Several studies have exploredbytewise coding and found it to be more efﬁcient than bitwise alternatives. An enhancedversion in which the split between continuing and terminating bytes is signaled by adifferent value than 128 has also been described and offers the possibility of improvedcompression effectiveness.
As well as offering economical decoding, the bytewise coding mechanism facilitates
fast stepping through a compressed stream looking for the kth subsequent code. Since
each codeword ends with a byte in which the top bit is a “ 0”, it is easy to step through a
compressed sequence and skip over exactly kcoded integers without having to decode
each of them in full.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 21
Fig. 11 . Encoding using a Golomb code with parameter b. Input values must satisfy
x≥1.
Table III. Example Codewords Using Three Different Golomb Codes
value b=3 b=5 b=16
1 0:0 0:00 0:0000
2 0:01 0:01 0:0001
3 0:11 0:10 0:0010
4 10:0 0:110 0:0010
10 1110:0 10:110 0:1001
Colons are used as a guide to show the preﬁx and sufﬁx components in
each codeword. All three codes can represent arbitrarily large numbers.
Golomb and Rice Codes. The Elias codes just described have the property that the
integer 1 is always encoded in one bit. However, d-gaps of 1 are not particularly common
in inverted lists. More pertinently, within the context of a single inverted list withknown length, the likely size of the numbers can be accurately estimated. It is thereforedesirable to consider schemes that can be parameterized in terms of the average sizeof the values to be coded.
Golomb codes, described in Figure 11, have this property. Integer x≥1 is coded
in two parts—a unary bucket selector, and a binary offset within that bucket. Thedifference between this and the Elias codes is that, in Golomb codes, all buckets arethe same size. The use of a variable-length binary code for the remainder rmeans that
no bit combinations are wasted even when the parameter bis not an exact power of
two. Table III gives some examples of the codewords generated for different values ofb. When bis a power of two, b=2
k, the sufﬁx part always contains exactly kbits.
These are known as Rice codes and allow simpler encoding and decoding procedures.An example Rice code appears in the last column of Table III.
Matching Code to Distribution. The implied probability distribution associated with
the Elias gamma code was described earlier; Golomb codes are similarly minimum-redundancy when
Pr(x)≈(1−p)
x−1p,
provided that
b=/ceilingleftbigglog(2−p)
−log(1−p)/ceilingrightbigg
≈0.69×1
p,
where pis the parameter of the geometric distribution (the probability of success in
a sequence of independent trials). As we now explain, an inverted list can be repre-sented as a sequence of integers that are, under a reasonable assumption, a sequenceof independent (or Bernoulli) trials.
Binary Codes. Other coding mechanisms can also perform well and even binary codes
can realize compact representations if the data is locally homogeneous. At the sametime, they can provide decoding speeds as good as bytewise codes. In the simplest
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.22 J. Zobel and A. Moffat
example of this approach, a sequence of values is represented by ﬁtting as many binary
codes as possible into the next 32-bit output word. For example, if all of the next sevensequence values are smaller than 17, then a set of 4-bit codewords can be packed intoa single output word. Similarly, if all of the next nine values are smaller than 9, anoutput word containing 3-bit codewords can be constructed. To allow decoding, eachword of packed codes is preﬁxed by a short binary selector that indicates how that wordshould be interpreted.
As with the bytewise coding method, this approach supports fast identiﬁcation of the
kth subsequent codeword since all that is required is that the selector of each word be
examined to know how many codewords it contains.
Compressing Inverted Lists. The representation of inverted lists introduced earlier de-
scribed each inverted list as a sequence of /angbracketleftd,fd,t/angbracketrightvalues with the restriction that each
document identiﬁer dbe an ordinal number. From a database perspective, imposing
an ordinal identiﬁer appears to be a poor design decision because it has implicationsfor maintenance. However, text databases are not manipulated and updated in theways that relational databases are, and, in practice, the use of a simple mapping tableobviates the difﬁculties.
The frequencies f
d,tare usually small (with a typical median of 1 or 2) and can be
efﬁciently represented using unary or gamma. But representing raw document iden-tiﬁers using these codes gives no saving since the median value in each inverted listisN/2.
On the other hand, if document identiﬁers are sorted and ﬁrst-order differences ( d-
gaps ) are stored, signiﬁcant savings are possible. If a term appears in a random subset
off
tof the Ndocuments in the collection, the d-gaps conform to a geometric distribution
with probability parameter p=ft/Nand can thus be coded effectively using a Golomb
code or one of the other codes. For example, a Golomb-gamma-coded index of all wordsand numbers occurring in the documents for the NewsWire collection would occupy about
7% of the text size. In this approach, the representation for each inverted list consists ofalternating d-gap values and f
d,tvalues, each occupying a variable number of bits. The
d-gap values are represented as Golomb codes, using a parameter bdetermined from
the number of /angbracketleftd,fd,t/angbracketrightpairs in that inverted list, and the fd,tvalues are represented
using the gamma code.
Use of Golomb codes does, however, present problems for the update strategy of in-
termittent merge. If Golomb codes are used for representing document identiﬁers, themerge process involves decoding the existing list and recoding with new parameters,but processing the existing list will then be the dominant cost of update, and shouldbe avoided. One solution is that the old Golomb parameter could continue to be usedto compress the added material at some small risk of gradual compression degrada-tion. Alternatively, if static codes are used and lists are document-ordered, new /angbracketleftd,f
d,t/angbracketright
values can be directly appended to the end of the inverted lists. For other list order-ings, such as those described in Section 9, there may be no alternative to completereconstruction.
Compression Effectiveness. The effectiveness of compression regimes is particularly ev-
ident for inverted lists representing common words. To take an extreme case, the wordtheis likely to occur in almost every document (in an English-language collection), and
the vast majority of d-gaps in its inverted list will be 1 and represented in just a single
bit. Allowing for the corresponding f
d,tvalue to be stored in perhaps (at most) 10–11
bits, around 12 bits is required per /angbracketleftd,fd,t/angbracketrightpointer for common words, or one-quarter
of the 48 bits that would be required if the pointer was stored uncompressed. The ad-ditional space savings that can be achieved with stopping are, for this reason, small.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 23
However, stopping does yield signiﬁcant advantages during index maintenance because
stopping means that updates to the longest lists (those of common words) are avoided.
Less frequent words require longer codes for their d-gaps but, in general, shorter
codes for their fd,tvalues. As a general rule-of-thumb, each /angbracketleftd,fd,t/angbracketrightpointer in a com-
plete document-level inverted index requires about 8 bits when compressed using acombination of Golomb and Elias codes. Use of the less-precise bytewise code for oneof the two components adds around 4 bits per pointer and, for both components, addsaround 8 bits per pointer. The word-aligned code has similar performance to the byte-wise code for large d-gaps but obtains better compression when the d-gaps are small.
For example, a bytewise-gamma-coded index for the NewsWire data (with the d-gaps
represented in a bytewise code and the f
d,tvalues coded using gamma) would occupy
about 70 ×106×12 bits or approximately 10% of the source collection. In this index, the
document identiﬁers are byte aligned, but the fd,tvalues are not, so the list is organized
as a vector of document numbers and a separate vector of frequencies with the two listsdecoded in parallel when both components are required. While the compression savingsare not as great as those attained by Golomb codes, the bytewise and word-aligned codesbring other beneﬁts.
Compression of Word Positions. Uncompressed, at, for instance, two bytes each (so no
document can exceed 65,536 words), word positions immediately account for the bulkof index size: 360MB for NewsWire , and 22GB for Web. However, these costs can be re-
duced by taking differences, just as for document identiﬁers, and Golomb codes canbe used to represent the differences in either a localized within-this-document sense,or, more usefully, in an average-across-all-documents manner. In the latter case, thevocabulary stores two bvalues, one used to code the d-gaps in the way that was de-
scribed earlier, and a second to code the w-gaps counting the word intervals between
appearances of that term. Static codes—gamma, delta, bytewise, or word-aligned—also give acceptable compression efﬁciency and may be attractive because of theirsimplicity.
The choice of coding scheme also affects total fetch-and-decode times with the byte-
wise and word-aligned codes enjoying a clear advantage in this regard. Bitwise codescannot be easily stepped through, and queries that require only bag-of-words processingcan be considerably slower with an interleaved word-level index than with a document-level index.
An aspect of inverted indexes that is dramatically altered by the introduction of word
positions is the cost of processing common words. In a document-level index, commonwords such as theare relatively cheap to store. In a word-level index, the average per-
document requirement for common words is much larger because of the comparativelylarge number of f
d,tword-gap codes that must be stored. In the case of the Webdata, just
a handful of inverted lists account for more than 10% of the total index size. Processing(or even storage) of such lists should be avoided whenever possible.
Nonrandom Term Appearances. If documents are chronological, terms tend to cluster.
For example, in the 242,918 documents of the Associated Press component of TREC,there are two deﬁnite clusters for hurricane , one due to hurricane Gilbert in September
1988, and a second resulting from hurricane Hugo in September 1989. Similar clus-tering arises with web crawls. Some sites are topic-speciﬁc so that words that are rareoverall may be common within a group of pages. A particular cause of this effect isindexing of documents that are written in a variety of languages.
The nonuniform distribution can be exploited by an interpolative code which trans-
mits the mid-point of the list of document numbers in binary, then recursively handlesthe two sublists in the resulting narrowed ranges. For typical collections, this code
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.24 J. Zobel and A. Moffat
results in an average of 0 .5t o1 .5 bits saved per /angbracketleftd,fd,t/angbracketrightpointer compared to a Golomb
code. The drawback of the interpolative code is that it is more complex to implementand slower in decoding.
The word-aligned binary coding method is also sensitive to localized clustering, a run
of consistently small d-gaps is packed more tightly into output words than is a sequence
containing occasional larger ones.
Pros and Cons of Compression. Compression has immediately obvious beneﬁts. It re-
duces the disk space needed to store the index; and during query evaluation, it reducestransfer costs (the lists are shorter) and seek times (the index is smaller). Compressionalso reduces the costs of index construction and maintenance.
A less obvious beneﬁt of index compression is that it improves caching. If a typical
inverted list is compressed by a factor of six, then the number of inverted lists that canbe retained in memory is increased by that same factor. In a retrieval system, queriesarrive with a skew distribution with some queries and query terms much more commonthan others. Queries for Chicago weather forecast far exceed those for Kalgoolie
weather forecast , for example. There can also be marked temporal effects. People
use Web search engines to check questions on broadcast quiz shows, for example, sothe same unusual query might arrive thousands of times in a short space of time.Increasing the effectiveness of caching can dramatically cut the cost of resolving astream of queries.
The principal disadvantage of compression is that inverted lists must be decoded
before they are used. A related problem is that they may need to be recoded when theyare updated, for example, if parameters change. For some of the codes considered, theaddition of new information can require complex recoding.
On current desktop machines, the decoding cost is more than offset by the reduction
in disk seek costs. More importantly, as the ratio of the speed between processors anddisk continues to diverge, the performance beneﬁt available through compression isincreasing. For byte- and word-aligned codes, which allow each document identiﬁer tobe decoded in just a few instruction cycles, the processing cost is more than offset bythe reduction in memory-to-cache transfer costs.
Thus, if the index is larger than the available main memory or cannot be buffered
for some other reason, there is no disadvantage to compression. And even if the indexis in memory, processing can be faster than for uncompressed data. Use of appropriateindex compression techniques is an important facet of the design of an efﬁcient retrievalsystem.
9. LIMITING MEMORY REQUIREMENTS
If the standard query evaluation algorithm is used for queries that involve commonwords, most accumulators are nonzero, and an array of Nentries A
dis the most space-
and time-efﬁcient structure. But the majority of those accumulator values are triviallysmall, as the only matching terms are one or more common words. Analysis of searchengine logs has demonstrated that common terms are not the norm in queries, andanalysis of relevance has demonstrated that common terms are of low importance. Itthus makes sense to ask if there are better structures for the accumulators, requiringfewer than Nelements.
Accumulator Limiting. If only documents with low ft(i.e., rare) query terms are al-
lowed to have an accumulator, the number of accumulators can be greatly reduced.This strategy is most readily implemented by imposing a limit Lon the number of
accumulators as shown in Figure 12.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 25
Fig. 12 . The limiting method for restricting the number of accumulators during
ranked query evaluation. The accumulator limit Lmust be set in advance. The
thresholding method involves a similar computation, but with a different test atstep 2(b)i.
In ranking, using the models described earlier, a document can have a high similarity
score even if several query terms are missing. In the limiting approach, as each /angbracketleftd,fd,t/angbracketright
value is processed, a check is made to determine whether there is space in the setof accumulators to consider additional documents. Thus the algorithm enforces thepresence of the query terms that are weighted highly because of their frequency ofoccurrence in the query or because of their rareness in the collection. While the behaviorof the ranking is altered, it is arguably for the better since a document that is missingthe most selective of the query terms is less likely to be relevant. Some of the Web searchengines only return matches in which all of the query terms are present, a strategy thatappears to be effective in practice for short queries but, in experimental settings, hasbeen found to be less compelling.
Accumulator Thresholding. Another approach of a similar type is to use partial
similarities—the contribution made by a term to a document’s similarity, or wq,t×wd,t—
to determine whether an accumulator should be created. In this approach, accumulatorsare created if it seems likely that the document will ultimately have a sufﬁciently highsimilarity, with the test |A|<Lin Figure 12 replaced by a test w
q,t×wd,t>S, for some
value S. The threshold Sis initially small but is increased during query processing
so that it becomes harder for documents to create an accumulator as the computationproceeds.
For a set of accumulators that is limited to approximately 1%–5% of the number
of documents, in the context of TREC-style long queries and evaluation, there is nonegative impact on retrieval effectiveness.
However, with Web-style queries, both the limiting and the thresholding methods
can be poor. In the limiting method, the limit tends to be reached part way through theprocessing of a query term, and thus the method favors documents with low ordinalidentiﬁers; but if the limit is only tested between lists, then the memory requirementsare highly unpredictable. Similar problems affect thresholding. A solution is to modifythe thresholding approach so that, not only are accumulators created when the newcontribution is signiﬁcantly large, but existing accumulators are discarded when theyare too small. With this approach, the number of accumulators can be ﬁxed at less than1% of the number of documents for large Web-like collections.
Data Structures. Comparing the two approaches, the limit method gives precise con-
trol over memory usage, whereas the threshold method is less rigid and allows evencommon terms to create accumulators for particular documents if they are sufﬁciently
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.26 J. Zobel and A. Moffat
frequent in those documents. Both methods reduce the number of nonzero accumula-
tors, saving memory space without affecting retrieval effectiveness. And, as examplesof more general query pruning methods , they can also reduce disk trafﬁc and CPU time,
using methods that are discussed shortly.
To maintain the set of accumulators in either of these two approaches, a data struc-
ture is required. An obvious solution is to store the accumulators as a list ordered bydocument number and successively merge it with each term’s inverted list.
Representing Document Lengths. Storage of the set of document lengths Wdis another
demand on memory during ranking. Figures 2, 4, and 12 suggest that the Wdvalues
be stored in a ﬁle on disk, but execution is faster if they can be retained in memory.
There are two aspects of their use that make memory residence possible. First, they
are an attribute of the document collection rather than of any particular query. Thismeans that the array of Wvalues can be initialized at system startup time rather than
for every query and that, in a multithreaded evaluation system, all active queries canaccess the same shared array.
The second aspect that allows memory-residence is that, like many other numeric
quantities associated with ranked query evaluation, they are imprecise numbers andresult from a heuristic rather than an exact process. Representing them to 64 or 32 bitsof precision is, therefore, unnecessary. Experiments have shown that use of 8- or 16-bitapproximate weights has negligible effect on retrieval effectiveness.
Storage for the Vocabulary. Except for the document mapping table and assorted buffers,
the only remaining demand on main memory is the term lookup dictionary or vocabu-lary. For collections such as NewsWire andWeb, retaining the vocabulary in main memory
is expensive since each entry includes a word, ancillary ﬁelds such as the weight of thatterm, and the address of the corresponding inverted list.
Fortunately, access to the vocabulary is only a small component of query processing;
if a B-tree-like structure is used with the leaf nodes on disk and internal nodes inmemory, then a term’s information can be accessed using just a single disk access,and only a relatively small amount of main memory is permanently consumed. Forexample, consider the Webcollection described in Table I. The 16 million distinct terms
in that collection correspond to a vocabulary ﬁle of more than 320MB but if each leafnode contains (say) 8kB of data, around 400 vocabulary entries, then the in-memorypart of the structure contains only 40,000 words, occupying less than 1MB. As for thedocument weights, this memory is shared between active queries and is initialized atstartup rather than once per query.
10. REDUCING RETRIEVAL COSTS
The core implementation, together with simple strategies for reducing memory con-sumption, provides a functional query evaluation system. For example, in the contextof a desktop machine and a gigabyte-scale text collection, typical queries of a few termscan be resolved using these techniques in well under a second. In addition, with ac-cumulator limiting, compact document weights, and a B-tree for the vocabulary, thememory footprint can be limited to a dozen or so megabytes. However, substantial fur-ther savings can be made, and, with careful attention to detail, a single standard PC caneasily provide text search for a large organization such as a university or corporation.
In the core implementation (Figure 4), the principal cost is retrieval and decoding
of inverted lists. That is, every /angbracketleftd,f
d,t/angbracketrightpair contributes to a valid accumulator. With
limited-accumulator query evaluation (Figure 12), however, most /angbracketleftd,fd,t/angbracketrightpairs do not
correspond to a valid accumulator, and processing time spent decoding these pairsis wasted. We also argued earlier that to facilitate compression and the gains that
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 27
compression brings, the document numbers in each list should be sorted. However, use
of compression means that each number is stored in a variable number of bits or bytesso random access (e.g., to support binary search) into inverted lists is not possible.
Skipping. A proposal from the mid-1990s is that decoding costs be reduced by the
insertion of additional structure into inverted lists. In this skipping approach, descrip-
tors are periodically embedded in each compressed inverted list, dividing the list intochunks. The descriptor can be used to determine whether any /angbracketleftd,f
d,t/angbracketrightvalue in the
chunk corresponds to a valid accumulator; if not, that chunk does not need to be de-coded, and processing can immediately move to the next chunk. However, all chunksstill need to be fetched. Note also that, if the chunks are as large as disk blocks, thegreat majority will need to be decoded, and, if they are smaller, more chunks can beskipped but most disk blocks will still contain a valid chunk. In experiments at the time,we found that skipping yielded worthwhile performance gains. Since then, processorshave become much faster, while disk access times have not greatly improved, and thebeneﬁts provided by skipping have eroded.
To reduce disk transfer costs, it is necessary to avoid fetching the inverted lists in
their entirety. One obvious method is to only fetch inverted lists for rare terms, butexperiments consistently show that all terms should be processed if effectiveness is tobe maintained. The more attractive option is to rearrange inverted lists so that, in atypical query, only part of each relevant list need be fetched. The schemes describedearlier for accumulator limitation provide criteria for deciding whether a /angbracketleftd,f
d,t/angbracketrightvalue
will be used; we now explain how these criteria can be used to restructure inverted listswithout seriously degrading compression effectiveness.
Frequency-Ordered Inverted Lists. The principle of accumulator limitation is that large
values of wq,t×wd,tshould be processed ﬁrst. The default heuristic for identifying these
values is to process the low- ftterms ﬁrst as their lists are likely to contain more large
wq,t×wd,tvalues than would the lists of high- ftterms. However, in a typical inverted
list, most fd,tvalues are small, while only a few are large. If only the large fd,tvalues
are interesting, that is, can contribute to a useful wq,t×wd,tvalue, then they should be
stored at the beginning of their inverted list rather than somewhere in the middle ofthe document-based ordering. For a given threshold Sand term t, allw
q,t×wd,t>S
values (see Equation (1)) will then be stored before any smaller ones.
To make use of this idea, the index can be reorganized. A standard inverted list is
sorted by document number, for example,
/angbracketleft12, 2/angbracketright/angbracketleft17, 2/angbracketright/angbracketleft29, 1/angbracketright/angbracketleft32, 1/angbracketright/angbracketleft40, 6/angbracketright/angbracketleft78, 1/angbracketright/angbracketleft101, 3 /angbracketright/angbracketleft106, 1 /angbracketright.
When the list is reordered by fd,t, the example list is transformed into
/angbracketleft40, 6/angbracketright/angbracketleft101, 3 /angbracketright/angbracketleft12, 2/angbracketright/angbracketleft17, 2/angbracketright/angbracketleft29, 1/angbracketright/angbracketleft32, 1/angbracketright/angbracketleft78, 1/angbracketright/angbracketleft106, 1 /angbracketright.
The repeated frequency information can then be factored out into a preﬁx component
with a counter inserted to indicate how many documents there are with this fd,tvalue:
/angbracketleft6:1:4 0 /angbracketright/angbracketleft3:1:1 0 1 /angbracketright/angbracketleft2:2:1 2 ,1 7 /angbracketright/angbracketleft1:4:2 9 ,3 2 ,7 8 ,1 0 6 /angbracketright.
Finally, if differences are taken in order to allow compression, we get
/angbracketleft6:1:4 0 /angbracketright/angbracketleft3:1:1 0 1 /angbracketright/angbracketleft2:2:1 2 ,5 /angbracketright/angbracketleft1:4:2 9 ,3 ,4 6 ,2 8 /angbracketright.
Repeated frequencies fd,tare not stored, giving a considerable saving. But within each
equal-frequency segment of the list, the d-gaps are now on average larger when the
document identiﬁers are sorted, and so the document number part of each pointer
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.28 J. Zobel and A. Moffat
Fig. 13 . Interleaved processing of inverted lists using a frequency- or impact-sorted index.
Blocks from the front of each list are applied to the set of accumulators in decreasing scoreorder until some stopping condition has been met. At the instant shown, 11 blocks have beenprocessed, and, if processing continues, the next block to be processed would be for the termold.
increases in cost. In combination, these two effects typically result in frequency-sorted
indexes that are slightly smaller than document-sorted indexes.
Using a frequency-sorted index, a simple query evaluation algorithm is to fetch each
list in turn, processing /angbracketleftd,fd,t/angbracketrightvalues only while wq,t×wd,t≥S, where Sis the
threshold. If disk reads are performed one disk block at a time rather than on a whole-of-inverted-list basis, this strategy signiﬁcantly reduces the volume of index data to befetched without degrading effectiveness.
A practical alternative is for the ﬁrst disk block of each list to be used to hold the
/angbracketleftd,f
d,t/angbracketrightvalues with high fd,t. These important blocks could then all be processed before
the remainder of any lists, ensuring that all terms are given the opportunity to createaccumulators. The remainder of the list is then stored in document order.
A more principled method of achieving the same aim is to interleave the processing of
the inverted lists. In particular, once the ﬁrst block of each list has been fetched and isavailable in memory, the list with the highest value of w
q,t×wd,tcan be selected, and its
ﬁrst run of pointers processed. Attention then switches to the list with the next-highestw
q,t×wd,trun which might be in a different list or might be in the same list.
During query processing, each list could be visited zero, one, or multiple times, de-
pending only on the perceived contribution of that term to the query. The interleavedprocessing strategy also raises the possibility that query evaluation can be terminatedby a time-bound rather than a threshold since the most signiﬁcant index information isprocessed ﬁrst. Figure 13 shows the interleaved evaluation strategy with list sectionspresumed to be applied to the set of accumulators in decreasing order of numeric score.The shaded sections of each list are never applied.
Impact-Ordered Inverted Lists. An issue that remains even in the frequency-sorted ap-
proach is that wq,t×wd,t/Wdis the true contribution of term tto the similarity score
Sq,d, rather than wq,t×wd,t. If it makes sense to frequency-sort the inverted lists into
decreasing wd,torder, then it makes even better sense to order them in decreasing im-
pact order using wd,t/Wdas a sort key. Then all that remains is to multiply each stored
value by wq,tand add it to the corresponding accumulator. That is, an impact value
incorporates the division by Wdinto the index.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 29
Fig. 14 . Impact-ordered query evaluation.
If the inverted lists are then sorted by decreasing impact, the same interleaved pro-
cessing strategy can be employed. Now the blocks in the inverted list must be cre-ated artiﬁcially rather than occurring naturally, since w
d,t/Wdis not integer-valued,
and exact sorting would destroy the d-gap compression. Hence, to retain compres-
sion, the impact values are quantized so that each stored value is one of a small num-ber of distinct values, and integer surrogates are stored in the inverted lists in placeof exact w
d,t/Wdvalues. Experiments with this technique have shown that approx-
imately 10–30 distinct values sufﬁce to give unaltered retrieval effectiveness com-pared to full evaluation. And, unlike frequency-based methods, impact-sorted listsare just as efﬁcient for evaluation of the Okapi similarity heuristic described inEquation (2).
With this change, each list is a document-sorted sequence of blocks of approxim-
ately-equal-impact pointers, and no f
d,tvalues are stored. Compared to document- and
frequency-sorted indexes, the compressed size grows slightly because the average d-
gaps are bigger. Nevertheless, the index is still a small fraction of the size of the textbeing indexed.
Query evaluation with an impact-ordered index becomes a matter of processing as
many blocks as can be handled in the time that is available. To process a block, aninteger contribution score that incorporates the impact score associated with that blockand the query term weight w
q,t(which might be unity) is added to the accumulator of
every document recorded in the block. All query-time operations are on integers, alsomaking the ﬁnal extraction phase signiﬁcantly easier to manage. Impact-ordered queryevaluation is shown in Figure 14.
With an impact-sorted inverted ﬁle and integer surrogate weights, query processing is
extremely fast. Just as important is that time consumed by each query can be bounded,independent of the number of terms in the query. When query load is light or when apremium service has been purchased, a greater fraction of the blocks in each query canbe used to inﬂuence the result ranking.
Impacts provide another illustration of the ﬂexible constraints on design of algo-
rithms for information retrieval. Information can be selectively thrown away or ap-proximated without detriment to the output of the algorithm, although there may bea beneﬁcial change to efﬁciency. While the set of documents returned by impact-basedprocessing will not be the same as the set returned by the underlying computation inEquation (1), the quality of the set (proportion of documents that are relevant) may beunchanged. In practice, the effect is likely to be that one method gives better results
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.30 J. Zobel and A. Moffat
than the other for some queries and worse results than the other for other queries. Such
change-but-no-difference effects are commonly observed in development of algorithmsfor text query evaluation.
Other Considerations. When the inverted lists are impact- or frequency-sorted, they
are read in blocks rather than in their entirety, and contiguous storage is no longera necessity. Blocks with high-impact information could be clustered on disk, furtheraccelerating query processing. The lists for common terms—the ones with many doc-ument pointers—will never be fully read, and a great deal of disk trafﬁc is avoided.Experiments with these techniques, using collections such as NewsWire , show that disk
trafﬁc and processing time are reduced by a factor of up to three compared to previ-ous techniques involving limited accumulators. The likely gain is even greater for thelargerWebcollection. As a ﬁnal advantage, the impact-sorted index dispenses with the
need for an array or ﬁle of W
dvalues.
The disadvantage of both frequency- and impact-sorted indexes is that Boolean
queries and index updates are more complex. To handle Boolean queries efﬁciently,other index structures have been proposed. One approach is to use a blocked index.
Rather than use d-gaps that are relative to the previous document number, it is feasi-
ble to code d-gaps relative to the start of a block. This allows use of a form of binary
search at some loss of compression efﬁciency. Conjunctive Boolean queries can then beprocessed extremely quickly.
However, updates remain complex. With document-ordered list organizations, new
/angbracketleftd,f
d,t/angbracketrightvalues can be appended to the list. In the enhanced organizations, the whole
of each list must be fetched and decoded. Whether this is a signiﬁcant disadvantagedepends on the application.
Summary. We have described compression-based indexing and query evaluation tech-
niques for bag-of-word queries on a text database. Compared to the uncompressed,document-sorted implementation described in Figure 4,
—disk space for a document-level index requires about 7%–9% of the size of the data
and has been reduced by a factor of around ﬁve;
—memory space for accumulators requires a dozen bytes for 5% of the documents in a
small collection or less than 1% of the documents in a large collection and has beenreduced by a factor of around twenty;
—CPU time for processing inverted lists and updating accumulators is reduced by a
factor of three or more;
—disk trafﬁc to fetch inverted lists is reduced by a factor of ﬁve in volume and of two
or more in time (The relative savings increase with collection size);
—throughput of queries is reduced by making better use of memory, allowing more
effective caching of vocabulary entries, lists, and answers;
—construction time for indexes is cut by a factor of more than two, through reduction
in the disk-trafﬁc bottleneck and reduction in the number of runs required to buildan index.
11. OTHER APPROACHES TO INDEXING
Querying can also be carried out without an index. For typical data and queries, buildingan index requires about 10–50 times the cost of a string search. If queries are rare, orthe data is extremely volatile, it is reasonable to use a document-oriented queryingstrategy of the type shown in Figure 2. An example is searching of a personal emaildirectory or search within a small collection of ﬁles.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 31
Fig. 15 . Example of a sufﬁx array.
For querying of larger collections, inverted ﬁles are not the only technology that has
been proposed. The two principal alternatives are sufﬁx arrays and signature ﬁles. Inthis section, we brieﬂy outline these approaches and explain why they are not compet-itive with inverted ﬁles for the applications considered in this article.
Sufﬁx Arrays. A sufﬁx array stores pointers into a source string, ordered according to
the strings they point at. The index can be of every character position or, for typicalretrieval applications, every word position. The structure provides access via a binarysearch-like process which is fast if it can be assumed that both the array and theunderlying source string are available in memory.
Consider the ﬁrst line of the Keeper collection annotated with byte offsets in the
string, commencing at zero, as shown in part A of Figure 15. In a word-level sufﬁxarray, a list is made of the byte addresses at which words start, shown in the ﬁrst rowof part B of Figure 15. The second row of part B shows the initial two characters of thesemi-inﬁnite string that is the target of each pointer. To form the sufﬁx array, the bytepointers are reordered so that the underlying strings are sorted, using as many charac-ters of the semi-inﬁnite strings as are necessary to break ties, as shown in part C. Notethat the second of these two lines is provided only to allow the destinations of the point-ers to be visualized by the reader. All that is actually stored is the original string, and anarrayAcontaining one pointer for each word in the string, with A[0]=36 ,A[1]=31 , and
so on.
One way of interpreting the resultant array of byte pointers is that they represent
a combined vocabulary and inverted index of every sufﬁx string in the original textwith access provided directly to the bytes rather than via ordinal document identiﬁers.To use the sufﬁx array, the sorted byte pointers are binary searched, again using theunderlying strings to drive the comparisons. The output of each search is a pair ofindices into the sufﬁx array, describing the ﬁrst and last locations whose strings areconsistent with the supplied pattern. For example, to locate occurrences of keep in the
example array, the binary search would return 1 and 3 since all of A[1] ,A[2] , andA[3]
contain byte addresses (31, 14, and 21, respectively) pointing at semi-inﬁnite stringsin the original text that commence with the preﬁx keep . (If exactly the word keep was
required rather than as a preﬁx, a trailing delimiter could be added to the search key,and then only A[1]=31 would be returned.)
It is straightforward to extend sufﬁx arrays to phrase searching, and a range of sim-
ple techniques, such as conﬂating all nonalphabetic characters to a single separatorcharacter for the purposes of string comparison, allow the same binary-searching pro-cess to be applied regardless of the length or frequency of the phrase or words in it.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.32 J. Zobel and A. Moffat
Case-folding can also be achieved by making the string comparison function case-
insensitive as has been presumed in the example.
For large-scale applications, sufﬁx arrays have signiﬁcant drawbacks. The pointer
array is accessed via binary search so compression is not an option. For a word-alignedsufﬁx array, a 4-byte pointer is needed for each 6 bytes or so of text, and the underlyingtext must also be retained. In total, the indexing system requires around 170% of thespace required by the input, all of it memory-resident. A sufﬁx array-based retrievalsystem for 1GB of text demands a computer with 2GB or more of memory, a require-ment that scales linearly as the source message grows. Sufﬁx array indexes are largecompared to inverted ﬁles because the repeated information cannot be usefully factoredout and because byte addresses are used rather than word-offset addresses. If the basetext is large, the sufﬁx array itself can be indexed and partial strings stored in index toavoid needing to access the base text. For very large texts, the pointers can be managedhierarchically. However, these techniques add considerable complexity to the buildingand searching processes.
Another drawback is that there is no equivalent of ranked querying. All but simple
stemming regimes are also problematic. On the other hand, sufﬁx arrays offer increasedstring searching functionality compared to inverted ﬁles—complex patterns, such aswild-characters, can be handled. The principal strength of sufﬁx arrays is that theygreatly accelerate grep -style pattern matching, swapping decreased time for increased
space.
Worth noting is that much of the functionality offered by a sufﬁx array can be achieved
in the context of an inverted ﬁle by indexing the vocabulary either with a sufﬁx arrayspanning the vocabulary strings themselves or by a secondary inverted index makinguse of the character bigrams or trigrams that comprise the vocabulary terms.
Signature Files. Signature ﬁles are a probabilistic indexing method. For each term,
sbits are set in a signature ofwbits. The term descriptors for the terms that appear in
each document are superimposed (i.e., OR’ed together) to obtain a document descriptor,
and the document descriptors are then stored in a signature ﬁle of size wN bits for
Ndocuments.
To query on a term, the query descriptor for that term is formed; all of the documents
whose document descriptors are a superset of the query descriptor are fetched; and thefalse matches are separated from the true matches with only the latter returned to the
user as answers.
Assuming that all records are the same length, that is, then contain the same number
of distinct terms; all terms occurring in over 5% of records are stopped; and there is onaverage just one false match per single-term query, then the index size is about 20% ofthe text. With an unstopped index, signatures must be much wider, giving a 40%-of-textindex.
Variability in document length signiﬁcantly complicates these calculations. With a
ﬁxed-length signature, more bits are set for long documents than short. These docu-ments are then more likely to be selected as false matches, and because they are long,the cost of false-match checking is further increased. To get a false-match volume of oneaverage document-length, a signature ﬁle needs to be much larger than the indicativesizes given here.
The simplest organization for a signature ﬁle is a sequence of signatures, which im-
plies that the whole index is processed in response to each query. A range of alternativeorganizations of two kinds have been proposed. One is bitslicing in which the signatureﬁle, viewed as a matrix, is transposed in which case it is only necessary to fetch a smallnumber of slices—perhaps 10 to 15—in response to a query. Each slice has one bit perstored record, and so, for the Webcollection, would contain 1 .5MB of data.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 33
Another alternative organization is the use of descriptors in which signatures are
partitioned according to a small number of selected bits and only matching partitionsare fetched for each query. We are unaware of any practical demonstration of the mer-its of such descriptor schemes. Bitslicing, however, has been explored experimentally,including a range of variations designed to reduce costs. For example, slice length canbe dramatically reduced with a small increase in the number of slices fetched, althoughcosts remain linear in the number of stored documents.
Even for the relatively unsophisticated task of Boolean retrieval, signature ﬁles have
several crucial defects. One is the need to eliminate false matches. For a given signaturewidth, the number of false matches is linear in the collection size and hence, as thenumber of indexed documents grows, the number of documents unnecessarily fetchedincreases. For any reasonable parameter settings, this cost must dominate. And thelonger a document, the higher the likelihood that it will be retrieved as a false match.Second, signature ﬁle indexes are large compared to compressed inverted ﬁles and areno easier to construct or maintain. Third, they require more disk accesses for shortqueries—exactly the kind that is commonplace in Web searching. And fourth, they areeven more inefﬁcient if Boolean
ORand NOToperators are permitted in addition to AND.
More critically, there is no sensible way of using signature ﬁles for handling ranked
queries or for identifying phrases. That is, there are no situations in which signatureﬁles are the method of choice for text indexing even for exact-match Boolean stylesearching.
12. BEYOND AN ELEMENTARY SEARCH ENGINE
We have outlined indexing and query evaluation algorithms that can be used in apractical search engine. These algorithms can be used to index large volumes of dataand provide rapid response to user queries. However, in speciﬁc searching applications,further improvements in performance are available. In this section, we brieﬂy reviewsome of these options.
Crawling. Data acquisition is a key activity in dynamic systems. In unusual cases,
the revised content will be delivered as it is generated, and we need do no more thanindex it. For example, a commercial arrangement might result in the daily delivery ofupdated catalog entries for an online store.
More usually, however, the owners of data change it without regard for whether or not
it is indexed. Crawling is the process of seeking out changed data and feeding it back
to the retrieval system for incorporation into updated indexes. In principle, crawling iseasy, a set of seed URLs is used as the basis for the search, and those pages are fetchedone by one. Each hyperlink within those pages is extracted and, if it has not beenexplored yet, appended to a queue of pending pages. Eventually, all pages reachablefrom the seed set will have been accessed, and the process can be repeated.
However, there are many subtle issues that require attention if a crawler is to be
efﬁcient. First, not all pages are of the same importance, and, while crawling the CNNWeb site at hourly intervals might be appropriate, crawling a set of University pagesprobably is not. Indeed, the volume of data available might mean that the crawl simplydoes not ﬁnish before it is necessary to start it again. In this case, a strategy for prior-itizing page visits and aborting the crawl when only low-priority pages remain may berequired.
Second, not all pages are edited at the same rate, and editing may follow a regular
pattern. An adaptive crawler might be able to signiﬁcantly reduce crawl volume byidentifying the update strategy that applies to pages and learning which pages arealmost never modiﬁed.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.34 J. Zobel and A. Moffat
Third, there are crawling traps that need to be anticipated and avoided—
unintentional traps such as recursive script-based Web pages that implement calendarswith a “next month” link are just one example. Fourth, the crawler needs to be sensitiveto the requirements of the site it is visiting and must stagger its requests so as to avoidﬂooding it over a short period of time. Fifth, the crawler must be alert to the prob-lem of duplicate pages and mirrored sites. And, ﬁnally, crawling is expensive becauseit involves either payment per gigabyte of data fetched (for some connection modes)whether it is useful or not, or paying for a high-capacity connection to the Internet sothat the necessary bandwidth can be achieved.
Caching. In many contexts, the same queries and query terms recur. For example,
many queries to the Web search engines are topical, and queries to a site-speciﬁc searchengine may also be clustered. (Many of the queries on the Web site of one of our uni-versities contain the query term results . Over half of these queries are posed on the
two single days after ﬁrst and second semester on which student grades are released.)A search engine can take advantage of this behavior by caching.
There are several kinds of information that can be cached. The inverted lists that
are fetched in response to a query can be explicitly kept in memory. Alternatively, ifthese lists are maintained in disk blocks, the operating system is likely to cache themautomatically on the basis of most-recently-used. As was noted earlier, compressionhelps by increasing the impact of this caching.
It is tempting to store the vocabulary in memory because doing so means that a disk
access is avoided for every query term. However, if the vocabulary is large, keeping itin memory reduces the space available for caching of other information and may notbe beneﬁcial overall. Relying on the operating system swapping pages of vocabularyinformation is almost certainly a poor decision, as the distribution of hot query termsamong pages is unlikely to be clustered in a useful way. An alternative is to managethe vocabulary in a B-tree as discussed earlier and to explicitly cache recently-accessedor frequently-accessed query terms in a separate small table.
Perhaps the most effective caching is of answer lists. If queries recur, it makes sense
to store their answer lists rather than recompute them. Even keeping them on disk iseffective as one short answer set can be fetched much more rapidly than can multipleinverted lists. For a typical search engine, most users will only view the ﬁrst ranswers,
but it may be effective to keep the next ranswers handy for the small percentage of
cases in which they are requested.
Another form of caching is phrase indexing. Indexing all phrases is impractical, but
using term-based inverted lists to identify which documents contain a phrase is ex-pensive. The cost of phrase query processing could be signiﬁcantly reduced if invertedlists are explicitly maintained for common term combinations. That is, the users them-selves, via their querying behavior, can guide the evaluation as to which phrases mightbe worth explicitly storing when the index is next rebuilt.
One of the major bottlenecks of query evaluation is the need to fetch the documents
that are presented in the answer lists; most search engines return not only a documentidentiﬁer but a corresponding document summary or snippet . Typically these sum-
maries are based on the query and thus cannot be computed ahead of time. Saving com-plete answer pages, including all of the required snippets, can thus be a dramatic saving.
Pre-Ordering. In the context of Web retrieval, techniques such as Google’s PageRank
can be used to determine a static score for each page to complement the dynamic scorecalculated by whatever similarity function is being used. The ﬁnal rank ordering is thena blend of the static score which can be regarded as an a priori probability orderingthat a page is relevant to queries in general, and a dynamic score which reﬂects theprobability that a page is relevant to this particular query.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 35
Static rankings are only useful in contexts where additional nontextual information
can be used such as (in the case of PageRank) the link structure. The PageRank of aWeb page is based on the link structure of the Web. Each page is assigned a score thatsimulates the actions of a random Web surfer, someone who either with probability p
is equally likely to follow any of the links out of the page they are currently on, or withprobability 1 −pjumps to a new page chosen at random. An iterative computation can
be used to compute the long-term probability that such a user is visiting any particularpage and that probability is then used to set the PageRank. The effect is that pages withmany in-links tend to be assigned high PageRank values, especially if the pages thathost those links themselves have a high PageRank; pages with low in-link counts, or in-links from only relatively improbable pages, are themselves deemed to be improbableas answers.
HITS is a similar technique which scores pages as both authorities andhubs , again
using a matrix computation based on the connectivity graph established by the Web’shyperlinks. Loosely, a good hub is one that contains links to many good authorities,and a good authority is one that is linked to from many good hubs. Hubs are usefulinformation aggregations and often provide some broad categorization of a whole topic,whereas authorities tend to provide detailed information about a narrower facet of atopic. Both may be useful to queriers.
Pages might also be assigned static scores contributions based on how similar they
are to an amalgam of previous queries, or how often users of the search service haveclicked through them to read their underlying content, or how deep they are in thedirectory structure of that particular site.
Where static weights are available from some source such as PageRank or HITS, they
can potentially be used to eliminate some of the cost of ranking. For example, supposethat inverted lists are maintained in decreasing PageRank order. Then a top- rranking
could be rapidly computed by taking the Boolean intersection of the inverted listscorresponding to the query terms, terminating as soon as rdocuments containing all of
the query terms have been found. These would be presented in decreasing PageRankorder. If the user then requests more documents, presumably because the top rare
unsatisfactory, then the system simply computes the top 2 r, and discards the ﬁrst rof
them.
User Feedback. Relevance feedback has been widely explored in the context of infor-
mation retrieval research. In explicit feedback systems, users identify the answers thatare of value (and perhaps others that are not), and this information is incorporated intoa revised query, to improve the overall quality of the ranking. Much of this researchassumes that queries are independent, and, in practical systems, it has proven difﬁcultto gather relevance assessments from users.
However, in a system processing large numbers of queries, it is straightforward to
identify which answers users choose to view. The action of a user clicking on a link can beinterpreted as a vote for a document. Such voting can be used to alter the static weightsof documents and thus their ordering in the ranking generated for subsequent querieseven if the subsequent queries differ from the one that triggered the click though.
Index Terms. In structured documents, such as those stored as HTML, different em-
phasis can be placed on terms that appear in different parts of the document. Forexample, greater weight might be placed on terms that appear in a document’s <title>
tags or as part of an <h1> heading.
Another important difference between Web searching and more general document
retrieval is that the anchor text associated with a link in one page is in many casesan accurate summary of what the target page is about. Links are usually manually
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.36 J. Zobel and A. Moffat
inserted, and unless they say “click here”,1represent a succinct assessment to a human
author as to the content of the target page. Indexing the anchor text as if it were partof the target page—perhaps even as if it were a title, or heading—can signiﬁcantlyimprove retrieval effectiveness in Web search applications.
Another useful technique in Web searching is indexing the URL string itself. For
example, the page at www.qantas.com shows the word Qantas as an image rather than a
textual title and unless the URL were parsed into terms and indexed with the document,would risk not being searchable. Page importance can also be biased according to thelength of the URL that accesses it on the assumption that URLs with fewer slasheslead to more important pages.
Finally, it is worth noting that the <alt> text associated with images is a useful
indication of what the image content is, and indexing of <alt> text is part of the Google
image search mechanism.
Manual Intervention. If some queries are particularly common, then a reasonable strat-
egy for improving perceived performance is to manually alter the behavior of thesequeries. For example, it might make sense for the term Quantas to be manually associ-
ated with the Qantas page, given the high incidence of confusion over the exact name. Bythe same token, if the query CNNdoes not lead directly to www.cnn.com as a result of the
ranking heuristic, then direct manipulation to make it so could well be appropriate. Oneof the most common queries in the search engine of one of our institutions is the singlewordlibrary ; sadly, the home page of the library is only the fourteenth highest ranked
answer.
13. BIBLIOGRAPHY
The material presented in the previous sections is based on an extensive literaturespanning more than 40 years. This section provides a high-level critical overview ofthat literature and can be regarded as further reading that augments the tutorial.
Our examination of past work is through the prism of current interests rather than
a complete historical study. For example, in the ﬁrst decades of work on informationretrieval, both Boolean and ranked queries were widely investigated but, in the lasttwenty years, most work on search has focused on ranking; the research on Booleanquerying is increasingly of historical interest only and is largely outside our scope. Note,too, that terminology has changed since the 1980s. In many older papers, retrieval was
taken to mean Boolean matching. Scoring and ranking of matches was often describedasnearest neighbor searching . Some retrieval papers focused on cluster retrieval, an
activity that now receives relatively little attention.
Within the narrow area of inverted ﬁle indexing for text, this bibliography is reason-
ably complete. However, some minor papers have been omitted on grounds such as lackof availability (in particular, technical reports and theses); and, where a preliminarypaper has later been expanded and republished, the preliminary paper is not cited. Inthe noncore areas, such as signature ﬁles, the bibliography is far from exhaustive. Inthese cases, we have focused on papers with innovations in index structures or queryevaluation algorithms.
Some related topics are not considered. We do not explore vocabulary representations
such as hash tables and B-trees or in-memory text search structures such as sufﬁxarrays; and we do not discuss use of text indexes in other applications or special-purpose
1In late 2005, for the query click here Google returns the Adobe Acrobat Reader home page, the Macromedia
Flash player download page, and the Apple QuickTime download page as the three top-ranked answersbecause of the hundreds of thousands of sites that point at the these pages using the anchor text “to obtaina copy, click here”.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 37
text indexes such as those used for plagiarism detection. Nor do we discuss structured
document retrieval, or use of inverted ﬁles for relations or other data. The purpose ofthis bibliography is to review and categorize the literature on free-text indexing andranked query evaluation.
Books and Overviews. In contrast to areas such as database systems, there have been
relatively few textbooks on information retrieval or text search. Only three recent bookshave substantial coverage of algorithms and data structures for information retrieval,those by Frakes and Baeza-Yates [1992], Grossman and Frieder [2004], and, in par-ticular, Witten et al. [1999]. The implementation described in the tutorial is similar tothe methods presented by Witten et al. [1999] and, more brieﬂy, in a chapter of Bertinoet al. [1997]. However, several of the extensions and methods summarized here weredeveloped since those texts were written.
Baeza-Yates et al. [2002] include an overview of index representation and query
evaluation as well as topics such as string searching, sufﬁx arrays, and issues for dis-tributed processing. Frakes and Baeza-Yates [1992] and Salton [1968] provide usefulbackground, but they do not consider current approaches. Faloutsos and Oard [1995]give an introduction to the ﬁeld of text searching in a technical report. Arusu et al.[2001] review text retrieval in the wider context of Web search, including issues suchas distribution and crawling.
There are several older textbooks on information retrieval and retrieval systems
(but with only limited material on indexes and indexing) including Salton [1971, 1981];Lancaster and Fayen [1973]; van Rijsbergen [1979]; and Salton and McGill [1983]. Foran overview of information retrieval research through approximately 1995, see SparckJones and Willett [1997], an extensive, annotated compilation of many classic infor-mation retrieval papers. A text from this same era that does consider indexing andcompression—but not ranking—is Heaps [1978] which discusses topics such as im-plementation issues for search of bibliographic records; in this context, Heaps [1978]reports that index size is expected to be about 70% of data size. For a general intro-duction to information retrieval including an overview of indexing, see Baeza-Yatesand Ribeiro-Neto [1999]. Kobayashi and Takeda [2000] review information retrievaland search on the Web. Voorhees and Harman [2005] is an overview and history of theTREC project. Zobel et al. [1996] discuss criteria against which an indexing methodmight be assessed.
Books that consider relevant compression techniques include Witten et al. [1999],
Moffat and Turpin [2002], Salomon [2000], and Sayood [2000]. Only the ﬁrst of thesediscusses the application of compression to indexing.
Text Search and Information Retrieval. Segesta and Reid-Green [2002] brieﬂy review
a 1953–8 implementation of associative text indexing using punch cards and mag-netic tape. The indexes were, in modern terms, inverted lists represented as bitmaps;manual searching was reportedly easier than search via the computer. Ivie [1966] de-scribes a range of ways similarity computations might be performed, and Matthew andThomson [1967] describe a successful implementation of a tape-based inverted index inwhich answers are ranked according to user-supplied term importance. Salton [1968]describes a rich system that makes use of syntactic analysis, thesauri, dictionaries,and the vector space model to search tapes for matches. Salton [1972] gives reasonswhy—with the machines, algorithms, and collections of the time—inverted ﬁles are notalways practical. Haskin [1980] reports that “space estimates for storing [an inverted]index range from 50% to 300% of the space needed to store the text itself”, a quotationthat continues to be used to justify research into alternative indexing methods despitethe fact that it refers to a primitive form of inverted ﬁle with storage of redundant
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.38 J. Zobel and A. Moffat
information and no compression. The 50%–300% ﬁgure is originally due to Bird et al.
[1978] who report that the inverted ﬁle sizes of a range of then current systems “rangein size from .5 to 3 times the size” of the indexed data. The exact structure of the in-
verted indexes in these systems is not given, but each posting appears to contain asearch key. Thus this widely-cited ﬁgure is based on structures quite different frominverted ﬁles as understood today.
Bird et al. [1978] also report the cost of a search on a full-text database: typically
$20 to $30 per query, and sometimes as high as $100. Assuming 2005 commodity hard-ware pricing; a cost multiple of ten to allow for data gathering, software purchases, andmaintenance; and (very conservatively) one second per search; then a typical querytoday might cost 0 .03 cents, around 100,000 times less. That is, on average the cost has
halved every eighteen months, not even taking into account that the volume of databeing searched has probably grown by a factor of 1,000 or more during the same pe-riod, while the cost of accessing disk, then as now a key bottleneck in query processing,has fallen by a factor of no more than 100. Bird et al. [1977] state that “it has becomeobvious to many [researchers in the] text retrieval disciplines that new hardware de-vices are needed; continued reliance on software ingenuity will probably not producea spectacular breakthrough”. The gains of the last three decades have not conﬁrmedtheir pessimistic assessment.
Harper [1982] tested four commercial systems (ASSASSIN, BASIS, STAIRS, and
STATUS) and notes that all use a form of inverted ﬁle; for the 62MB collectionused in the experiments, the block-oriented index of STATUS was estimated to re-quire around 45MB. A categorization and partial bibliography of pre-1983 paperson indexing and search is given by Eastman [1983]; this paper demonstrates thata wide range of indexing methods were under consideration at the time. A corre-sponding survey by Faloutsos [1985a] also considers a range of techniques. Faloutsos[1985a] reports that inversion is “adopted in most of the commercial systems”, buthas signiﬁcant disadvantages, and that, “for the ofﬁce environment”, the signaturemethod is the most promising. These conclusions have been invalidated by subsequentwork.
Cluster retrieval was another alternative that is now little investigated. In some older
textbooks, cluster searching is regarded as the most promising technique for search.However, Voorhees [1986] compared cluster and inverted ﬁle search and found thatinverted ﬁle search is more efﬁcient. Salton [1989] wrote that “inverted-ﬁle search issubstantially faster ...it is likely that inverted ﬁle searches will always remain faster
than cluster searches, no matter how reﬁned a cluster organization is available”. Can[1994] proposed a combination of cluster search and inverted ﬁle search, arguing that itis advantageous to organize inverted list entries by cluster, but interest in cluster-basedsearching has greatly declined since the 1980s; there is little evidence that clusteringprovides a viable alternative to inverted indexes.
Early work on inverted ﬁles for text used methods developed for databases such as
that of Bayer and McCreight [1972], Cardenas [1975], and McDonell [1977]. In theseapproaches, the cost of update was a key concern, leading to representations of invertedlists in sequences of blocks. The focus on reducing update costs thus led to increasedspace consumption and slower query evaluation. Stellhorn [1977] considered invertedﬁles designed for text, arguing for the use of special-purpose hardware to allow rapidmerging; the arguments do not apply to current systems.
Much of the work on inverted indexes assumes that lists are directly managed via
a ﬁle system, an approach that allows control over fragmentation and use of special-purpose free-space management algorithms. Zobel et al. [1993b] consider layout of listson disk and management of short lists with blocks, showing that their hybrid approachcan lead to low fragmentation.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 39
Alternatively, relational database systems can be used as ﬁle systems, for example,
an inverted list can be stored as a contiguous blob in a record. Such an approach isexplored by, among others, Brown et al. [1994], Melnik et al. [2001], and Vasanthakumaret al. [1996], who show that it simpliﬁes implementation. There are costs, however; inaddition to the extra layer of management that is introduced by use of a database systemfor ﬁle management, this organization removes ﬂexibility such as the ability to retrievelists in stages and to ensure contiguous storage. Grabs et al. [2001] consider whether adistributed relational database provides advantages for information retrieval comparedto a monolithic relational database, but the generality of the results is unclear due touse of a collection that ﬁts in memory and lack of explanation of query evaluationtechniques. The potential advantages during update are considered by Brown et al.[1994], but this method assumes segmentation of lists into 8-kilobyte blocks and doesnot allow efﬁcient query processing.
Standard relational indexing techniques are an alternative to indexes designed for
text. Numerous approaches of this kind have been described in which an inverted listfor a term is represented typically by a series of tuples, one per document containing theterm. Such implementations are orders of magnitude slower than text-speciﬁc designs,and we do not explore this literature of unsuccessful methods. Also, there have beenmany descriptions of special-purpose implementations; most of these are of at bestlimited interest.
Similarity Measures. Improvement in similarity measurement is a key aim of informa-
tion retrieval research and, over the years, has been the subject of hundreds of papersin the annual SIGIR Information Retrieval Conference. A survey of even the principalcontributions is beyond the scope of this article, and we simply note a small number ofkey papers.
The most effective similarity formulations have been based on models of documents,
queries, and the retrieval process. One such approach is the vector space model, formallyexplained by Salton et al. [1975] but in use much earlier. The ﬁrst reference to the cosinemeasure that we know of is by Salton [1962] who considers “the vectors of documentproperties as vectors in m-space, and [takes] as a distance function the cosine of the
angle between each vector pair”.
2Other early work is by Ivie [1966] who also considered
similarity functions.
The cosine measure—which has consistently been the most successful similarity mea-
sure described under the vector space model—has undergone continuing reﬁnement,in particular with regard to term weighting. Arguably, the most recent signiﬁcant in-novation was the introduction of document-length pivoting [Singhal et al. 1996] whichaddresses the issue that document length and likelihood of relevance are correlated. Arange of other extensions of this type, for instance, introduction of a tunable constantthrough the use of training data, have followed.
For much of the history of information retrieval, the principal alternative to the
vector space model has been probabilistic models. Statistical approaches to informationretrieval were articulated during the early days of document computing; for example,Luhn [1957] wrote that
a standard program could serve to direct the machine to compare the question [with] the documents
of the collection. Since an identical match is highly improbable, this process would be carried out on astatistical basis by asking for a given degree of similarity.
2We thank Michael Lesk for locating and forwarding to us this key early information. Also worth noting
is that the Salton Award, presented every three years for research in the area of information retrieval, isnamed after Gerard Salton [1927–1995], the pioneering researcher who penned this statement.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.40 J. Zobel and A. Moffat
The probabilistic model’s basis is the probability ranking principle, explored by Maron
and Kuhns [1960] and later formalized by Robertson [1977]. Similarly, Edmundson andWyllys [1961] wrote:
In preparation for the widespread use of automatic scanners which will read documents and transmit
their contents to other machines for analysis, this report presents a new concept in automatic analysis:the relative-frequency approach to measuring the signiﬁcance of words, word groups, and sentences.
Many of the underpinnings of probabilistic information retrieval are summarized by
Sparck Jones et al. [2000] who give a detailed derivation of the probabilistic similaritymeasure often referred to as the Okapi measure or BM25 [Robertson et al. 1994].
A recent innovation is the use of language models, introduced by Ponte and Croft
[1998], where similarity is based on the kinds of word probability estimates used instatistical modeling [Manning and Sch ¨utze 1999] and text compression [Bell et al.
1990]. Many of the key issues in language models are examined in the papers collectedby Croft and Lafferty [2003]. Language modeling is an active area of research.
We are aware of no recent surveys or overviews of similarity measurement. Harman
[1992] lists a range of similarity measures. Salton and Buckley [1988b] surveyed differ-ent retrieval mechanisms and introduced notation to describe them; Zobel and Moffat[1998] combined a range of measures into an orthogonal framework and compared themon several different test collections.
Phrase Querying. An aspect of query evaluation that has attracted only a little pub-
lished research is the algorithmic problem of ranking with phrases. Lee et al. [1996]compare inverted ﬁles and signature ﬁles for keyword-based retrieval of structureddocuments. Williams et al. [1999] describe an index organization for word pairs, allow-ing phrase queries of arbitrary length. Williams et al. [2004] show that a small, partialphrase index can be used in conjunction with a conventional index and a phrase cacheto achieve most of the speed gains attained by explicit word-pair indexes at much lowerspace overhead.
Index Construction. Although the problem of index construction for text search has
similarities to both standard index construction and external sorting, there are partic-ular features of text indexes that mean that special-purpose algorithms can be moreefﬁcient than a general-purpose algorithm.
There are several alternative approaches [Witten et al. 1999, Chapter 5]. Fox and Lee
[1991] proposes a two-pass method in which the index is structured during one passthrough the data and constructed during multiple second passes. This method requireslittle overhead space but substantial overhead time for the repeated passes over thedata.
Many authors, well into the 1990s, appear to have assumed that indexes would be
constructed with the methods used for relational databases. Others assumed that anindex should be built by generating tuples representing list entries in occurrence or-der and sorting them into term order. Harman and Candela [1990] and Rogers et al.[1995] explored a method based on writing temporary list entries to disk which, whilefaster than the simplistic sorting methods, is still impractical. Moffat [1992] describes ascheme that assumes that the entire compressed index can ﬁt into main memory. Moffatand Bell [1995] describe a process that makes use of all of compression, in-place on-disksorting, and one-pass processing to build a compressed index within only a moderateamount of memory in excess of that required by the vocabulary. Heinz and Zobel [2003]experimentally examine several techniques and demonstrate that a straightforward ap-proach based on building and merging runs in limited memory is, in practice, the mostefﬁcient.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 41
Index Maintenance. Cutting and Pedersen’s [1990] work was one of the ﬁrst exami-
nations of the particular problems posed by update of text indexes, including sequen-tial management of list entries, and makes practical recommendations that are stillrelevant such as the need to make updates in batches rather than term-at-a-time ordocument-at-a-time. Brown et al. [1994], as noted earlier, use a relational system tomanage list entries as they are incrementally modiﬁed. Motzkin [1994] describes amethod based on storing list entries in a B-tree, giving analytical results, but thesmall blocks of list entries that result are likely to lead to inefﬁcient query evaluation.Burkowski [1990] considers the problem of free-space management in the context of anindex organized for fast updates; while the issues raised are interesting, the solutionis inapplicable to current implementations of indexing.
Lester et al. [2006] experimentally compare different approaches to update, ﬁnding
that, for large numbers of new documents, in-place update is costly compared to mergingold and new indexes. Tomasic et al. [1994] and Shoens et al. [1994] evaluate incrementalupdate strategies on synthetic data, considering a range of approaches to managementof space allocation and free lists. Clarke et al. [1994] and Clarke and Cormack [1995]consider the costs of batch update strategies in the context of a method for updating instages. Lester et al. [2005] and, in a case of independent discovery, B ¨uttcher and Clarke
[2005] describe the intermittent merging approach in which the index is partitioned intoa sequence of fragments of increasing size. This strategy reduces both the underlyingcomplexity and the in-practice costs.
Barbar ´a et al. [1996] consider caching strategies for reducing the costs of updates and
queries, arguing afresh that buffering of updates is likely to signiﬁcantly reduce costs.Much of the paper considers locking strategies, an operation that is neglected (or viewedas unnecessary) in many text retrieval applications. Shieh and Chung [2005] proposean over-allocation strategy designed to balance space wastage against the cost of too-frequent list relocation. The results in this paper and others indicate that some formof over-allocation is essential. Lim et al. [2003] reconsider an assumption widely madein older work, that document update or deletion is rare, noting that this assumption isfalse for Web data. Using a simple index representation, they show that update costscan be reduced through use of structured rather than ordinal word positions.
Distributed Information Retrieval. There is a wide literature on distributed information
retrieval. Many of the papers in this area concern topics such as database selection andresult fusion rather than index structures or algorithms for query evaluation. However,there are numerous exceptions. Most of the algorithm-oriented papers on distributedinformation retrieval concern proposals for speciﬁc architectures and measurement orestimation of efﬁciency under the architecture.
Stanﬁll et al. [1989, 1999] describe how an index might be distributed among a
large number of tightly coupled low-power parallel processors. The underlying indexdesign is relatively simplistic, and it is not clear that the predicted speedup, based onextrapolating to collections thousands of times larger than those tested, could havebeen achieved in practice. Cringean et al. [1990] explore similar issues with simi-lar limitations in a transputer network. A related design was explored by Reddaway[1991]. Salton and Buckley [1988a] critically evaluate these approaches. Couvreur et al.[1994] compare the suitability of different index types (inverted ﬁles, signature ﬁles,and special-purpose hardware) for parallel text search for both Boolean and wildcardqueries.
Harman et al. [1991] describe an implementation based on document distribution
across servers with separate collections, used as a library information system. Thissystem was successfully used in practice. Macleod et al. [1987] use simulation to com-pare approaches to distribution, including having documents on one server and the
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.42 J. Zobel and A. Moffat
index on another, as well as the more usual approaches to division of workload via
partitioning and replication. They found distribution to be advantageous but under as-sumptions that do not correspond to current systems such as low workload and Booleanquerying. Martin et al. [1990] found via simulation that caching of material at clientor server can improve performance. Again, many of the assumptions are not applica-ble to current systems, but one key ﬁnding—explicit caching is superior to relying onthe operating system’s caching—remains valid. Martin and Russell [1991], however,question whether client-side caching is of value.
Cahoon and McKinley [1996] and Cahoon et al. [2000] describe a distributed system
built on the Inquery server, showing (primarily by simulation) that distributing doc-uments among servers can improve response until the client becomes choked. Largegains in performance were obtained by reducing the numbers of answers required. Luand McKinley [2003] report substantial further gains with carefully targeted replica-tion, an alternative or enhancement to caching in distributed systems.
Riberto-Neto et al. [1999] explore alternative ways of building a term-distributed
static index in a distributed environment, showing that it is best to distribute invertedlists during construction of runs. This means that the vocabulary distribution must beknown in advance.
Barroso et al. [2003] provide an overview of the Google architecture. In this system,
the index is distributed document-wise among several servers, giving a server clus-ter. Documents are stored on separate machines. An alternative document-distributedarchitecture is explored by Hawking [1997] with experiments showing that it scaleswell. Another document-distributed architecture is explored by Melnik et al. [2001].de Kretser et al. [1998] outline how queries on a document-distributed system mightbe evaluated, considering communication costs and correspondence to a monolithic sys-tem, arguing that a key optimization is to minimize the number of handshakes betweenclients and servers.
Xi et al. [2002a, 2002b] describe an approach in which each node contains a ﬁxed frac-
tion of each inverted list. Whether this approach is in practice signiﬁcantly different todocument distribution is unclear; their experiments indicated small improvements overa short sequence of queries and used the assumption that lists have to be completelyprocessed during query evaluation.
Jeong and Omiecinski [1995] compare document distribution to term distribution,
ﬁnding experimentally (but on artiﬁcial data) that document distribution is likely to besuperior in practice. MacFarlane et al. [2000], using a large data set, a small numberof real queries, and a single serialized client, fount that document partitioning is supe-rior. Tomasic and Garc ´ıa-Molina [1993] compare distributed index organizations, using
simulation, and found that document distribution is superior to term distribution forBoolean queries. Tomasic and Garc ´ıa-Molina [1996] undertook a similar investigation,
using bibliographic records instead of full-text documents, and found that distributionwithout replication is unhelpful. Ribeiro-Neto and Barbosa [1998] compare term anddocument distribution with simulations and found that term distribution is likely tooutperform document distribution. Badue et al. [2001] compare the same approaches,ﬁnding experimentally with artiﬁcial queries that term distribution is clearly superior.Cacheda et al. [2004] compare distribution with replication, ﬁnding the latter to bemore efﬁcient, using simulation, artiﬁcial queries, and extrapolation; due to simplify-ing assumptions such as that the servers are memoryless, the results are unrealistic.However, this is an active area of research; at the moment there is no clear best de-sign, and choices between approaches depend on a range of machine and applicationspeciﬁcs.
More recently, Moffa et al. [2005] describe a term-oriented system in which partial
answers are transferred between servers rather than inverted lists. Their results show
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 43
that the revised method is competitive with document distribution in terms of query
throughput but has problems with load balancing and is thus not as scalable.
The contrasts between these many papers highlight the difﬁculties in experimental
or simulated work of this kind: high throughput can be achieved at the expense ofpoor response time to individual queries; caching of inverted lists and answer setsaffects different architectures in different ways; if indexes are smaller than availablememory, timings may be highly unrealistic; the relative importance of the componentcosts changes dramatically with the volume of data to be indexed; and artiﬁcial queriesare likely to be unrealistic. These kinds of problems lead to question marks over muchof this work. In some papers, for example, it is assumed that the distribution of queryterms is the same as that of document terms, leading to the conclusion that long listsmust be processed in full for typical queries. Failure to model caching effects leads todrastic inaccuracies; experiments with small numbers of queries, even if realistic, saylittle about behavior with large numbers of queries where repetition is observed.
Comparisons are meaningful only if both implementations are of high quality or if,
improbably, in our view, simulations are fully realistic without simplifying assumptions.Moffat and Zobel [2004] comment on some of these issues.
Efﬁcient Index Representations. The majority of the representations used in index com-
pression are based on integer coding methods, in particular those of Golomb [1966],Gallager and Van Voorhis [1975], Elias [1975], and Rice [1979].
Early approaches to index compression were based on interpreting inverted lists as
bitmaps. (Most of these schemes did not consider in-document frequencies but, in hind-sight, incorporation of these frequencies would be straightforward.) Jakobsson [1978]gives a compression method based on interpreting bit-vectors as sequences of k-bit
symbols each of which can be allocated a Huffman code. Fraenkel and Klein [1985]explore variants of this scheme. Bookstein and Klein [1992] and Choueka et al. [1986]describe a reﬁnement in which an initial index is used to eliminate blocks in whichall bits are zero. All of these schemes, at best, simply approximate the Golomb codeand its excellent behavior when the appearances of each term are random in the setof documents. Other reﬁnements are described by Bookstein and Klein [1991a, 1991b,1991c].
Schuegraf [1976] described another variant based on bitmap compression, using anal-
ysis, to demonstrate that, in principle, large savings were available. However, it is notclear that this method is signiﬁcantly different from the other bitmap-based approachesdiscussed previously.
Choueka et al. [1987] extended the bitmap approach to allow determination of
whether words occur in proximity to each other. Compression of a word-level indexis explored by Choueka et al. [1988], using a range of purpose-designed representa-tions for tuples representing word positions. Some of the later methods can be viewedas generalizations, with greater compression effectiveness, of this approach. Klein et al.[1989] brieﬂy outline an organization for an inverted index based on these tuples inwhich word positions are described as coordinates of document, paragraph, and sen-tence number in a static database, allowing space savings compared to an uncompressedrepresentation.
Prior to much of this work, Teuhola [1978] proposed use of Golomb-like codes for
compressing bit vectors, a principled approach that achieves better compression thanmany of the alternatives described since.
The compressed index representation outlined in Section 8 was developed in a se-
quence of papers in the early 1990s [Witten et al. 1991, Moffat and Zobel 1992a, 1992b;Zobal et al. 1992; Bell et al. 1993]. Reﬁnements cover including additional structureto accelerate processing [Moffat and Zobel 1996; Anh and Moffat 1998]; exploiting any
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.44 J. Zobel and A. Moffat
clustering that may be available [Moffat and Stuiver 2000; Blandford and Blelloch 2002;
Silvestri et al. 2004]; exploration of bytewise codes [Williams and Zobel 1999; Scholeret al. 2002; Brisaboa et al. 2003; Culpepper and Moffat 2005]; exploration of ﬁxed binarycodes [Anh and Moffat 2005]; suppression of unimportant index information [Carmelet al. 2001]; and experimental comparison of alternative representations [Scholer et al.2002; Trotman 2003]. Much of the current research in the area of efﬁcient indexing andquery evaluation is based on these papers.
Linoff and Stanﬁll [1993] describe an approach based on bitwise codes that, in the best
case, are equivalent to an Elias gamma code. The compression achieved is poor. Shiehet al. [2003] propose reorganization of lists into trees to allow fast Boolean and rankedquerying. It seems unlikely that this approach is practical as the reorganization appearsto introduce large numbers of pointers. Use of Bayesian models is explored by Booksteinet al. [2000]; the results, on common terms in small collections, are not comparable tothose in other work. Shieh et al. [2003] describe a similarity-based reordering of thestored documents to reduce median gap values and thus improve compression withElias codes. Such techniques may be of value for static collections.
Faloutsos and Jagadish [1992] analyze search and construction times for an uncom-
pressed index that is a mix of inverted lists and bitmaps (without word frequencies), andconsider practical issues such as bitmap update. Such methods are superseded by theimplementation described in the tutorial, as a posting list with Elias or Golomb codingis almost always shorter than the corresponding bitmap regardless of term frequency.
Limiting Memory Requirements. Early implementations of ranked query evaluation
assumed an array of accumulators, one for each document in the collection, as ex-plained, for example, by Buckley and Lewit [1985]. Perry and Willett [1983] surveyranking methods based on inverted ﬁles. They report that, prior to about 1980, whilesome papers described systems that directly ranked documents, the “great majorityof...interactive document retrieval services are based on partial match, Boolean search
procedures” [Perry and Willett 1983]. Noreault et al. [1977] showed that inverted ﬁlescan be used to support ranking with only slightly increased costs compared to Booleanquerying.
For a query of many terms, a key optimization to standard ranking methods is to
avoid processing of inverted lists corresponding to words of low weight. Smeaton andvan Rijsbergen [1981] and Buckley and Lewit [1985] describe early schemes of this kind,using term statistics to determine when the set of top documents cannot be altered byfurther index processing (though their order might change). Lucarella [1988] and Wongand Lee [1993] describe further variants to these schemes. For short queries, however,these approaches cannot be effective, and the overhead of dynamically maintainingthe necessary statistics during query evaluation is high. Perhaps most seriously, ascollection size grows, the difference in score between highly-ranked documents becomessmall, and the termination condition is unlikely to be met until it is too late to achievesigniﬁcant savings.
An alternative stopping condition was described by Moffat and Zobel [1996]. In this
approach, the total number of accumulators was ﬁxed. Only the document identiﬁerscorresponding to the ﬁrst inverted lists processed could be included. Once the limit inthe number of accumulators is reached, query processing can stop—giving the ﬁnal setof documents, but possibly in a poor order—or can continue, updating existing accumu-lators but not adding new ones. Persin et al. [1996] described a thresholding methodfor throttling the number of accumulators created, without specifying a precise limit.The impact-sorted indexes of Anh et al. [2001] and Anh and Moffat [2002] also sup-port early query termination, trading effectiveness for efﬁciency. Lester et al. [2005]described a thresholding method designed for Web-style queries where accumulators
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 45
are both created and discarded as each list is processed. With the growth in the size
of typical collections, all practical implementations now use some method for limitingnumbers of accumulators.
In uncompressed inverted lists, a common assumption in work on query evaluation
prior to 1993 or so, the document weights could be incorporated into the inverted lists.With the compression methods described in the early 1990s, it was much cheaper tostore frequencies (which are small integers, whereas normalized frequencies are ﬂoat-ing point numbers drawn from a large domain). Moffat et al. [1994] showed that doc-ument weights could be stored in a few bits each; the accuracy of, for instance, 32 bitsis unnecessary given the existing approximations inherent in ranking. As the array ofdocument weights needs to be randomly accessed, this can greatly reduce the memoryrequired for a search engine.
Turtle and Flood [1995] argue that document-ordered query processing in which
lists are merged rather than processed in turn in term-ordered query processing, maybe more efﬁcient in practical multiuser environments. Kaszkiel et al. [1999] compareterm-ordered and document-ordered processing for whole documents and for passagesand ﬁnd that document-ordered processing can be effective if some query terms arerare. However, the distinction between the methods is unclear in the context of limitednumbers of accumulators. Strohman et al. [2005] carry out further experiments with adocument-ordered processing regime.
A space-saving approach is to trade off index-processing cost against document-
retrieval cost. Signature ﬁles exemplify this technique. As the amount of informationheld about each document is reduced, the likelihood of fetching a document by mistakegrows. In such an approach, it is necessary to postprocess documents to ensure thatthey do in fact match the query—a cost that in a large collection must easily dominateall other components of query processing. Other approaches of this kind were proposedby Manber and Wu [1994], Baeza-Yates and Navarro [2000], and Navarro et al. [2000]in which words are indexed by approximate location, such as a group of documents,which, after index processing, could then be exhaustively processed.
A radically different approach to query evaluation is described by de Kretser and
Moffat [1999], Clarke and Cormack [2000], and Clarke et al. [2000]. In this approach,word positions are stored in inverted lists and documents are ranked according tothe proximity of the query terms: a document that has a region that is dense withquery terms is highly ranked. This approach can be very effective, particularly on longor poorly deﬁned documents. Passage retrieval, in which the document collection isbroken into ﬁxed-size passages for the purpose of similarity checking, has also hadsome success [Kaszkiel et al. 1999; Zobel et al. 1995].
Reducing Retrieval Costs. Perhaps the single most effective heuristic for reducing query
evaluation costs is to reorder inverted lists according to frequency or contribution.Until the mid-1990s, most of the query evaluation schemes were based either on theassumption that inverted lists were sorted by document identiﬁer, or made no use of anordering assumption at all. Wong and Lee [1993] describe a scheme in which lists aresorted by decreasing frequency. This initial description of the approach was marred bythe assumption that inverted lists would consist of short blocks of document identiﬁers(leading to high retrieval costs) but allowed interleaved processing of inverted lists. Itis the ﬁrst description of this sorting principle which gives substantial savings.
Persin et al. [1996] proposed that inverted lists be sorted by in-document frequency.
As in the method described by Wong and Lee [1993], query evaluation then processesthe front part of each inverted list; how much is processed is determined by parametersreﬂecting system load and memory availability. A practical reﬁnement to this approachwas proposed by Brown [1995] who suggested that, for each list of sufﬁcient length,
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.46 J. Zobel and A. Moffat
the list begin with a ﬁxed-length block of document identiﬁers in which the term is
frequent. An alternative is to store normalized frequencies in the inverted lists asdescribed by Hawking [1998], Anh et al. [2001], and Anh and Moffat [2002]. To avoidloss of compression efﬁciency in this impact-ordering approach, the resulting absoluteterm weights are quantized. Large efﬁciency gains can be obtained through this methodwhich is also suitable for evaluating queries within a ﬁxed time bound.
Carmel et al. [2001] propose the static pruning of inverted lists, discarding at index
construction time entries that are heuristically judged to be unlikely to affect rank-ing. While successful at reducing index size, the method is less effective and less ef-ﬁcient than the dynamic pruning methods. Garcia et al. [2004] describe another or-dering variant where, within each inverted list, documents are ordered according tothe number of times the document is highly ranked by a training query. The savingsyielded are not as high as for impact-ordering and large numbers of training queries arerequired.
Caching reduces the cost of accessing disk. The impact of answer and list caches is
explored by Saraiva et al. [2001] who use a large collection and a query log to showthat both kinds of cache contribute to dramatically improved throughput. Lempel andMoran [2005] give theoretical bounds for the beneﬁts of caching. Technical aspects ofcache implementation are considered by Shieh et al. [2003] who show that, unsurpris-ingly, the costs of running a retrieval system can be signiﬁcantly reduced by the useof caches; experiments with simulated queries are used to compare caching schemes,but the results (which depend on query distribution, a small collection, and speciﬁchardware) seem unlikely to generalize. J ´onsson et al. [1998] show that cache replace-
ment policy has a signiﬁcant effect on performance, while Lempel and Moran [2004]demonstrate efﬁciency gains (in the context of a distributed system) by prefetching andanticipating events such as users proceeding to the next page of answers. In this con-text, as illustrated by the work of Spink et al. [2001] and Spink and Xu [2000] on querylogs, even though query evaluation can in principle focus on the rarest of the queryterms provided, terms in typical queries occur in up to 1% of the indexed documents.Thus the inverted lists of query terms can be expected to be at least a megabyte ina large text collection and caching is likely to lead to signiﬁcant savings. Lempel andMoran [2003] consider answer caching strategies in practice, using a trace of sevenmillion real-life queries from a search engine log.
Web Searching. Brin and Page [1998] describe the PageRank mechanism, in effect a
query-independent similarity measure, that led them to develop the ﬁrst version ofthe Google search engine. Other aspects of the Google search engine are presented byBarroso et al. [2003]. The HITS algorithm is due to Kleinberg [1999].
Other simpler metrics for assigning static weights to pages include counting the in-
degree and the out-degree of pages and various techniques based on statistics of thepage, for example, the ratio of normal text to other content. Many of the weighting fac-tors used by commercial search engines are proprietary and the subject of considerablespeculation on the part of both consumers of the services they provide and also thespammers who seek to manipulate those services.
Other Approaches to Indexing. There are many papers on exhaustive string search but
only de Kretser and Moffat [2004] consider how to rank exhaustively. Sufﬁx arrays canbe used for a wide range of searching tasks, including the Boolean retrieval more usuallyundertaken using inverted ﬁles. Baeza-Yates and Ribeiro-Neto [1999] and Baeza-Yateset al. [2002] provide an introduction to the literature in the area. Note that sufﬁx arraysprovide exact-match searching; there is no concept of ranking or of similarity scoring.On the other hand, some of the ﬂexibility of string searching can be achieved if the
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 47
vocabulary, rather than the underlying set of documents, is searched for possible query
terms [Zobel et al. 1993a]
There is a wide literature on signature ﬁles, dating back to the 1970s. Many of the
papers in the area are principally concerned with the organization of the ﬁles anddo not consider (at least, not in signiﬁcant detail) how they would be applied to theproblem of Boolean or ranked text search. Only a few papers concern the problem ofranking using signature ﬁle indexes, in particular Croft and Savino [1988] and Leeet al. [1995]. The schemes described in these papers are not competitive with invertedﬁle implementations.
Zobel et al. [1998] give a detailed comparison of inverted ﬁles and signature ﬁles.
Using analysis and experiments with data sets of under a gigabyte, it was concludedthat signature ﬁles were highly inefﬁcient as a Boolean retrieval mechanism for text.Since that time, the size of typical collections has greatly increased; extrapolation of thecost components of those experiments suggests that, for today’s collections, signatureﬁles are relatively even less efﬁcient. When inverted ﬁles can ﬁnd matches in 100GB inless than a tenth of a second, there is little reason to use a signature ﬁle that requiresseconds to search a gigabyte. Prior to the investigation of Zobel et al. [1998], Couvreuret al. [1994] compared inverted ﬁles to signature ﬁles in the context of a parallel systemand found signature ﬁles to be lacking.
A focus of signature ﬁle research has been methods for rearranging signatures to
reduce costs. Most of these methods propose, in effect, division of the ﬁle to reduce thelength of bit vectors by a ﬁxed ratio. Under these schemes, typically, the cost of queryresolution remains linear to collection size, and there is no amelioration of the problemof false matches. Examples include work by Bookstein and Klein [1990], Ciaccia et al.[1996], Kocberbera and Can [1997], Kent et al. [1990], and Zezula et al. [1991]. It is notclear that any of these schemes are of value in practice. For example, Kocberbera andCan [1997] note a problem with scaling and removed the longest documents in order toreduce false matches to predicted levels.
A problem in much of the signature ﬁle work is the assumption of the independent
probability of a bit being set. See, for example, Faloutsos [1985a, 1985b] who analyzesfalse drop probabilities on this assumption for different signature approaches; see alsoCiaccia and Zezula [1993] and Lee and Leng [1989]. Sacks-Davis et al. [1987], in con-trast, explicitly relate the probability of a bit being set to word probabilities, whilecontinuing to assume that documents contain a ﬁxed number of words.
Nothing Is Truly New. We close our article with a salutary quote, drawn from an article
also published in ACM Computing Surveys [Severance and Carlis 1977]:
When compared to a sequentially organized database, all [of] the preceding [variant index] organizations
have several disadvantages: the software required for retrieval is much more complex; ﬁle retrievalgenerally requires at least one secondary memory access for each record retrieved; the space occupied bypointers constitutes a storage overhead (typically, 10% to 70% of total space requirements); and ﬁnally,the management and maintenance of data for a large set of lists represent a second-order databasedesign problem whose solution will critically affect the total system’s performance. Nevertheless, whenrapid retrieval of small subsets of records from a large database is an essential system requirement, oneof these ﬁle structures must be employed. The inverted list structure is generally preferred.
Current research directions in inverted ﬁles often relate to evaluation methods for
the innovative similarity metrics that continue to appear. However, the core principleshave become well established. Efﬁcient ranking requires compact inverted lists, lim-ited accumulators, effective pruning strategies, and distribution. In combination, thesetechniques allow ranking to be applied to collections of any likely size or characteristics.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.48 J. Zobel and A. Moffat
ACKNOWLEDGMENTS
We thank the many collaborators, assistants, and students who have contributed to our work on indexing.
Jamie Callan, Bruce Croft, Donna Harman, Mike Lesk, and Ellen Voorhees helped us identify some of theearly work in the area.
REFERENCES
ANH,V .N . , DEKRETSER ,O . , ANDMOFFAT , A. 2001. Vector-space ranking with effective early termination. In
Proceedings of the 24th Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval . New Orleans, LA. 35–42.
A
NH,V .N . ANDMOFFAT , A. 1998. Compressed inverted ﬁles with reduced decoding overheads. In Proceedings
of the 21st Annual International ACM SIGIR Conference on Research and Development in InformationRetrieval . Melbourne, Australia. 291–298.
A
NH,V .N . ANDMOFFAT , A. 2002. Impact transformation: Effective and efﬁcient web retrieval. In Proceedings
of the 25th Annual International ACM SIGIR Conference on Research and Development in InformationRetrieval . Tampere, Finland. 3–10.
A
NH,V .N . ANDMOFFAT , A. 2005. Inverted index compression using word-aligned binary codes. Kluwer
International Journal of Information Retrieval 8 , 1, 151–166.
ARUSU, A., C HO, J., G ARCIA -MOLINA , H., P AEPCKE , A., ANDRAGHAVAN , S. 2001. Searching the Web. ACM Trans.
Internet Technol. 1 , 1, 2–43.
BADUE , C., B AEZA-YATES, R., R IBEIRO -NETO,B . , ANDZIVIANI , N. 2001. Distributed query processing using
partitioned inverted ﬁles. In Proceedings of String Processing and Information Retrieval Symposium ,
Laguna de San Rafael, Chile. G. Navarro, Ed. IEEE Computer Society, 10–20.
BAEZA-YATES, R., M OFFAT , A., ANDNAVARRO , G. 2002. Searching large text collections. In Handbook of Massive
Data Sets , J. Abello, P. Pardalos, and M. Resende, Eds. Kluwer Academic Publishers, Boston, MA. 195–
244.
BAEZA-YATES,R . ANDRIBEIRO -NETO, B. 1999. Modern Information Retrieval . ACM Press, New York, NY.
BAEZA-YATES,R .A . ANDNAVARRO , G. 2000. Block addressing indices for approximate text retrieval. J. Amer.
Soc. Inform. Science 51 , 1, 69–82.
BARBAR ´A, D., M EHROTRA ,S . , ANDVALLABHANENI , P. 1996. The Gold text indexing engine. In Proceedings of
IEEE International Conference on Data Engineering , New Orleans, LA. S. Y. W. Su, Ed. IEEE Computer
Society Press, Los Alamitos, CA. 172–179.
BARROSO , L. A., D EAN,J . , ANDH¨OLZLE , U. 2003. Web search for a planet: The Google cluster architecture.
IEEE Micro 23 , 2 (April), 22–28.
BAYER,R . ANDMCCREIGHT , R. 1972. Organization and maintenance of large ordered indexes. Acta Informat-
ica 1 , 173–189.
BEAULIEU , M., B AEZA-YATES, R., M YAENG , S. H., ANDJ¨ARVELIN , K., E DS. 2002. Proceedings of the 25th An-
nual International ACM SIGIR Conf. on Research and Development in Information Retrieval . Tampere,
Finland, ACM Press.
BELL,T .C . ,C LEARY ,J .G . , ANDWITTEN , I. H. 1990. Text Compression . Prentice-Hall, Englewood Cliffs, NJ.
BELL, T. C., M OFFAT , A., N EVILL -MANNING , C. G., W ITTEN , I. H., ANDZOBEL, J. 1993. Data compression in
full-text retrieval systems. J. Amer. Soc. Inform. Science 44 , 9 (Oct.), 508–531.
BERTINO , E., O OI, B. C., S ACKS-DAVIS, R., T AN, K.-L., Z OBEL, J., S HIDLOVSKY ,B . , ANDCATANIA , B. 1997. Indexing
Techniques for Advanced Database Systems . Kluwer Academic Publishers, Boston, MA.
BIRD, R. M., N EWSBAUM ,J .B . , ANDTREFFTZS , J. L. 1978. Text ﬁle inversion: An evaluation. In Proceedings
of the 4th Workshop on Computer Architecture for Non-Numeric Processing . Blue Mountain Lake, NY,
ACM Press, 42–50.
BIRD, R. M., T U,J .C . , ANDWORTHY , R. M. 1977. Associative/parallel processors for searching very large
textual data bases. In Proceedings of the 3rd Non-Numeric Workshop . Syracuse, NY, ACM Press, 8–
16.
BLANDFORD ,D . ANDBLELLOCH , G. 2002. Index compression through document reordering. In Proceedings of
the IEEE Data Compression Conference , Snowbird, UT, J. A. Storer and M. Cohn, Eds. IEEE Computer
Society Press, Los Alamitos, CA. 342–351.
BOOKSTEIN ,A . ANDKLEIN, S. T. 1990. Using bitmaps for medium sized information retrieval systems. Inform.
Proces. Manag. 26 , 525–533.
BOOKSTEIN ,A . ANDKLEIN, S. T. 1991a. Compression of correlated bit-vectors. Inform. Syst. 16 , 4, 387–
400.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 49
BOOKSTEIN ,A . ANDKLEIN, S. T. 1991b. Flexible compression for bitmap sets. In Proceedings of the IEEE Data
Compression Conference , Snowbird, UT, J. Storer and M. Cohn, Eds. IEEE Computer Society Press, Los
Alamitos, CA. 402–410.
BOOKSTEIN ,A . ANDKLEIN, S. T. 1991c. Generative models for bitmap sets with compression applications. In
Proceedings of the 14th Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval , Chicago, IL. A. Bookstein, Y. Chiaramella, G. Salton, and V. V. Raghavan, Eds.
ACM Press, 63–71.
B
OOKSTEIN ,A . ANDKLEIN, S. T. 1992. Models of bitmap generation: A systematic approach to bitmap com-
pression. Inform. Proc. Manag. 28 , 6, 735–748.
BOOKSTEIN , A., K LEIN,S .T . , ANDRAITA, T. 2000. Simple Bayesian model for bitmap compression. Kluwer Int.
J. Inform. Retriev. 1 , 4, 315–328.
BRIN,S . ANDPAGE, L. 1998. The anatomy of a large-scale hypertextual Web search engine. Comput. Netw.
ISDN Syst. 30 , 1–7, 107–117.
BRISABOA , N. R., F ARI˜NA, A., N AVARRO ,G . , ANDESTELLER , M. F. 2003. ( S,C)-dense coding: An optimized com-
pression code for natural language text databases. In Proceedings of String Processing and Information
Retrieval Symposium , Manaus, Brazil, M. A. Nascimento, Ed. Springer, 122–136.
BROWN , E. W. 1995. Fast evaluation of structured queries for information retrieval. In Proceedings of the
18th Annual International ACM SIGIR Conference on Research and Development in Information Re-trieval , Seattle, WA, E. A. Fox, P. Ingwersen, and R. Fidel, Eds. ACM Press, 30–38.
B
ROWN ,E .W . ,C ALLAN ,J .P . , ANDCROFT, W. B. 1994. Fast incremental indexing for full-text information
retrieval. In Proceedings of the International Conference on Very Large Databases , Santiago, Chile, J. B.
Bocca, M. Jarke, and C. Zaniolo, Eds. Morgan Kaufmann, 192–202.
BROWN , E. W., C ALLAN , J. P., C ROFT, W. B., E LIOT,J . , ANDMOSS, B. 1994. Supporting full-text information
retrieval with a persistent object store. In Proceedings of the International Conference on Advances in
Database Technology (EDBT) , Cambridge, UK, M. Jarke, J. A. B. Jr., and K. G. Jeffery, Eds. Springer,
365–378.
BUCKLEY ,C . ANDLEWIT, A. F. 1985. Optimisation of inverted vector searches. In Proceedings of the 8th
Annual International ACM SIGIR Conference on Research and Development in Information Retrieval .
Montreal, Canada, 97–110.
BURKOWSKI , F. J. 1990. Surrogate subsets: a free space management strategy for the index of a text re-
trieval system. In Proceedings of the 13th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval . Brussels, Belgium, 211–226.
B¨UTTCHER ,S . ANDCLARKE , C. L. A. 2005. Indexing time vs. query time trade-offs in dynamic information
retrieval systems. In Proceedings of the International Conference on Information and Knowledge Man-
agement , Bremen, Germany, A. Chowdhury, N. Fuhr, M. Ronthaler, H.-J. Schek, and W. Teiken, Eds.
ACM Press, 317–318.
CACHEDA , F., P LACHOURAS ,V . , ANDOUNIS, I. 2004. Performance analysis of distributed architectures to in-
dex one terabyte of text. In Proceedings of the European Conference on IR Research , Sunderland, UK,
S. McDonald and J. Tait, Eds. 395–408. Lecture Notes in Computer Science, Springer, vol. 2997.
CAHOON ,B . ANDMCKINLEY , K. S. 1996. Performance evaluation of a distributed architecture for information
retrieval. In Proceedings of the 19th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval . Zurich, Switzerland, 110–118.
CAHOON , B., M CKINLEY ,K .S . , ANDLU, Z. 2000. Evaluating the performance of distributed architectures for
information retrieval using a variety of workloads. ACM Trans. Inform. Syst. 18 , 1 (Jan.) 1–43.
CAN, F. 1994. On the efﬁciency of best-match cluster searches. Inform. Proc. Manag. 30 , 3, 343–361.
CARDENAS , A. 1975. Analysis and performance of inverted data base structures. Comm. ACM 18 , 5, 253–
263.
CARMEL , D., C OHEN , D., F AGIN, R., F ARCHI , E., H ERSCOVICI , M., M AAREK ,Y .S . , ANDSOFFER , A. 2001. Static index
pruning for information retrieval systems. In Proceedings of the 24th Annual International Conference
on Research and Development in Information Retrieval . New Orleans, LA. 43–50.
CHOUEKA , Y., F RAENKEL , A., K LEIN,S . , ANDSEGAL, E. 1987. Improved techniques for processing queries in
full-text systems. In Proceedings of the 10th Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval , New Orleans, LA, C. T. Yu and C. J. V. Rijsbergen, Eds. ACM
Press, 306–315.
CHOUEKA , Y., F RAENKEL ,A .S . , ANDKLEIN, S. T. 1988. Compression of concordances in full-text retrieval
systems. In Proceedings of the 11th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval , Grenoble, France, Y. Chiaramella, Ed. ACM Press, 597–612.
CHOUEKA , Y., F RAENKEL ,A .S . ,K LEIN,S .T . , AND SEGAL, E. 1986. Improved hierarchical bit-vector
compression in document retrieval systems. In Proceedings of the 9th Annual International
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.50 J. Zobel and A. Moffat
ACM SIGIR Conference on Research and Development in Information Retrieval . Pisa, Italy, 88–
97.
CIACCIA , P., T IBERIO ,P . , ANDZEZULA , P. 1996. Declustering of key-based partitioned signature ﬁles. ACM
Trans. Datab. Syst. 21 , 3 (Sept.), 295–338.
CIACCIA ,P .ANDZEZULA , P. 1993. Estimating accesses in partitioned signature ﬁle organizations. ACM Trans.
Inform. Syst. 11 , 2, 133–142.
CLARKE ,C .L .A . ANDCORMACK , G. V. 1995. Dynamic inverted indexes for a distributed full-text retrieval
system. Tech. rep. MT-95-01, Department of Computer Science, University of Waterloo, Waterloo,Canada.
C
LARKE ,C .L .A . ANDCORMACK , G. V. 2000. Shortest-substring retrieval and ranking. ACM Trans. Inform.
Syst. 18 , 1, 44–78.
CLARKE , C. L. A., C ORMACK ,G .V . , ANDBURKOWSKI , F. J. 1994. Fast inverted indexes with on-line update.
Tech. rep. CS-94-40, Department of Computer Science, University of Waterloo, Waterloo, Canada.
CLARKE , C. L. A., C ORMACK ,G .V . , ANDTUDHOPE , E. A. 2000. Relevance ranking for one to three term queries.
Inform. Proc. Manage. 36 , 2, 291–311.
COUVREUR , T. R., B ENZEL , R. N., M ILLER , S. F., Z EITLER ,D .N . ,L EE, D. L., S INGHAL , M., S HIVARATRI ,N . , ANDWONG,
W. Y. P. 1994. An analysis of performance and cost factors in searching large text databases using
parallel search systems. J. Amer. Soc. Inform. Science 45 , 7, 443–464.
CRINGEAN , J. K., E NGLAND , R., M ANSON ,G .A . , ANDWILLETT , P. 1990. Parallel text searching in serial ﬁles
using a processor farm. In Proceedings of the 13th Annual International ACM SIGIR Conference on
Research and Development in Information Retrieval , Brussels, Belgium, 429–453.
CROFT, W. B., H ARPER , D. J., K RAFT, D. H., ANDZOBEL, J., E DS. 2001. Proceedings of the 24th Annual Inter-
national ACM SIGIR Conference on Research and Development in Information Retrieval , New Orleans,
LA. ACM Press.
CROFT,W .B . ANDLAFFERTY , J. 2003. Language Modeling for Information Retrieval . Kluwer Academic Pub-
lishers, Dordrecht, The Netherlands.
CROFT,W .B . ,M OFFAT , A., VANRIJSBERGEN ,C .J . ,W ILKINSON , R., ANDZOBEL, J., Eds. 1998. Proceedings of
the 21th Annual International ACM SIGIR Conference on Research and Development in InformationRetrieval , Melbourne, Australia. ACM Press.
C
ROFT,W .B . ANDSAVINO , P. 1988. Implementing ranking strategies using text signatures. ACM Trans.
Ofﬁce Inform. Syst. 6 , 1, 42–62.
CULPEPPER ,J .S . ANDMOFFAT , A. 2005. Enhanced byte codes with restricted preﬁx properties. In Proceedings
of the 12th International Symposium on String Processing and Information Retrieval . Buenos Aires,
Argentina, M. P. Consens and G. Navarro, Eds. Lecture Notes in Computer Science, vol. 3772, Springer,1–12.
C
UTTING ,D . ANDPEDERSEN , J. 1990. Optimisations for dynamic inverted index maintenance. In Proceedings
of the ACM-SIGIR International Conference on Research and Development in Information Retrieval .
Brussels, Belgium, J.-L. Vidick, Ed. ACM Press, 405–411.
DEKRETSER ,O . ANDMOFFAT , A. 1999. Effective document presentation with a locality-based similarity
heuristic. In Proceedings of the 22nd Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval . San Francisco, CA. 113–120.
DEKRETSER ,O . ANDMOFFAT , A. 2004. Seft: A search engine for text. Softw.—Prac. Exper. 34 , 10 (Aug.),
1011–1023.
DEKRETSER , O., M OFFAT , A., S HIMMIN ,T . , ANDZOBEL, J. 1998. Methodologies for distributed information
retrieval. In Proceedings of the IEEE International Conference on Distributed Computing Systems . Am-
sterdam, The Netherlands. M. P. Papazoglou, M. Takizawa, B. Kr ¨amer, and S. Chanson, Eds. IEEE
Computer Society Press, Los Alamitos, CA. 66–73.
EASTMAN , C. 1983. Current practice in the evaluation of multikey search algorithms. In Proceedings of
the 6th International ACM SIGIR Conference on Research and Development in Information Retrieval .
Washington DC. J. J. Kuehn, Ed. ACM Press. 197–204.
EDMUNDSON ,H .P . ANDWYLLYS , R. E. 1961. Automatic abstracting and indexing—survey and recommenda-
tions. Comm. ACM 4 , 5 (May), 226–234.
ELIAS, P. 1975. Universal codeword sets and representations of the integers. IEEE Trans. Inform. The-
ory IT-21 , 2 (March), 194–203.
FALOUTSOS , C. 1985a. Access methods for text. Comput. Surv. 17 , 1, 49–74.
FALOUTSOS , C. 1985b. Signature ﬁles: Design and performance comparison of some signature extraction
methods. In Proceedings of the 8th Annual International ACM SIGIR Conference on Research and De-
velopment in Information Retrieval , Montreal, Canada, 63–82.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 51
FALOUTSOS ,C . ANDJAGADISH , H. V. 1992. Hybrid index organizations for text databases. In Proceedings of
the International Conference on Extending Database Technology , Vienna, Austria, A. Pirotte, C. Delobel,
and G. Gottlob, Eds. Lecture Notes in Computer Science, vol. 580, Springer, 310–327.
FALOUTSOS ,C . ANDOARD, D. W. 1995. A survey of information retrieval and ﬁltering methods. Tech. rep.,
University of Maryland Institute for Advanced Computer Studies Report, University of Maryland atCollege Park, MD.
F
OX,E .A . ANDLEE, W. C. 1991. FAST-INV: A fast algorithm for building large inverted ﬁles. Tech. rep. TR
91–10, Virginia Polytechnic Institute and State University, Blacksburg, VA.
FRAENKEL ,A .S . ANDKLEIN, S. T. 1985. Novel compression of sparse bit-strings—Preliminary report. In
Combinatorial Algorithms on Words, Volume 12 , A. Apostolico and Z. Galil, Eds. NATO ASI Series F.
Springer, Berlin, Germany, 169–183.
FRAKES ,W .B . ANDBAEZA-YATES, R., E DS. 1992. Information Retrieval: Data Structures and Algorithms .
Prentice-Hall, Englewood Cliffs, NJ.
FREI, H.-P., H ARMAN , D., S CH¨AUBLE ,P . , ANDWILKINSON , R., E DS. 1996. Proceedings of the 19th Annual In-
ternational ACM SIGIR Conference on Research and Development in Information Retrieval , Zurich,
Switzerland. ACM Press.
GALLAGER ,R .G . ANDVANVOORHIS , D. C. 1975. Optimal source codes for geometrically distributed integer
alphabets. IEEE Trans. Inform. Theory IT–21 , 2 (March), 228–230.
GARCIA , S., W ILLIAMS ,H .E . , ANDCANNANE , A. 2004. Access-ordered indexes. In Proceedings of the Aus-
tralasian Computer Science Conference , Dunedin, New Zealand. V. Estivill-Castro, Ed. Australian Com-
puter Society, 7–14.
GOLOMB , S. W. 1966. Run-length encodings. IEEE Trans. Inform. Theory IT–12 , 3 (July), 399–401.
GRABS, T., B ¨OHM, K., ANDSCHEK , H.-J. 2001. PowerDB-IR: Information retrieval on top of a database clus-
ter. In Proceedings of the CIKM International Conference on Information and Knowledge Management ,
Atlanta, GA. H. Paques, L. Liu, and D. Grossman, Eds. ACM Press, 411–418.
GROSSMAN ,D .A . ANDFRIEDER , O. 2004. Information Retrieval: Algorithms and Heuristics , 2nd Ed. Kluwer
Academic Publishers, Dordrecht, The Netherlands.
HARMAN , D., M CCOY, W., T OENSE , R., ANDCANDELA , G. 1991. Prototyping a distributed information retrieval
system using statistical ranking. Inform. Proc. Manag. 27 , 5, 449–460.
HARMAN , D. K. 1992. Ranking algorithms. In Information Retrieval: Data Structures and Algorithms .W .
B. Frakes and R. Baeza-Yates, Eds. Prentice Hall, Englewood Cliffs, NJ. 362–392.
HARMAN ,D .K . ANDCANDELA , G. 1990. Retrieving records from a gigabyte of text on a minicomputer using
statistical ranking. J. Amer. Soc. Inform. Science 41 , 8 (Aug.), 581–589.
HARPER , D. J. 1982. An evaluation of four information storage and retrieval packages. Tech. rep. 7, CSIRO
Division of Computing Research, Canberra, Australia.
HASKIN , R. L. 1980. Hardware for searching very large text databases. In Proceedings of the Workshop on
Computer Architecture for Non-Numeric Processing , Paciﬁc Grove, CA, ACM Press, 49–56.
HAWKING , D. 1997. Scalable text retrieval for large digital libraries. In Proceedings of the European Con-
ference on Research and Advanced Technology for Digital Libraries , Pisa, Italy. C. Thanos, Ed. Lecture
Notes in Computer Science, vol. 1324. Springer, 127–145.
HAWKING , D. 1998. Efﬁciency/effectiveness trade-offs in query processing. ACM SIGIR Forum 32 , 2, 16–22.
HEAPS, H. S. 1978. Information Retrieval, Computational and Theoretical Aspects . Academic Press, New
York, NY.
HEARST , M., G EY,F . , ANDTONG, R., E DS. 1999. Proceedings of the 22nd Annual International ACM SIGIR
Conference on Research and Development in Information Retrieval , San Francisco. CA, ACM Press.
HEINZ,S . ANDZOBEL, J. 2003. Efﬁcient single-pass index construction for text databases. J. Amer. Soc.
Inform. Science Techn. 54 , 8, 713–729.
IVIE, E. L. 1966. Search procedure based on measures of relatedness between documents. Ph.D. thesis.
MIT, Cambridge, MA.
JAKOBSSON , M. 1978. Huffman coding in bit-vector compression. Inform. Pro. Let. 7 , 6 (Oct.) 304–307.
JEONG ,B .S . ANDOMIECINSKI , E. 1995. Inverted ﬁle partitioning schemes in multiple disk systems. IEEE
Tran. Parall. Distrib. Syst. 6 , 2, 142–153.
J´ONSSON ,B .T . ,F RANKLIN ,M .J . , ANDSRIVASTAVA , D. 1998. Interaction of query evaluation and buffer man-
agement for information retrieval. In Proceedings of the ACM-SIGMOD International Conference on the
Management of Data , Seattle, WA. ACM Press, 118–129.
KASZKIEL , M., Z OBEL,J . , ANDSACKS-DAVIS, R. 1999. Efﬁcient passage ranking for document databases. ACM
Trans. Inform. Syst. 17 , 4 (Oct.), 406–439.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.52 J. Zobel and A. Moffat
KENT, A. J., S ACKS-DAVIS, R., ANDRAMAMOHANARAO , K. 1990. A signature ﬁle scheme based on multiple or-
ganisations for indexing very large text databases. J. Amer. Soc. Inform. Science 41 , 7, 508–534.
KLEIN, S. T., B OOKSTEIN , A., ANDDEERWESTER , S. 1989. Storing text retrieval systems on CD-ROM: Compres-
sion and encryption considerations. ACM Trans. Ofﬁce Inform. Syst. 7 , 3, 230–245.
KLEINBERG , J. M. 1999. Authoritative sources in a hyper-linked environment. J. ACM 46 , 5, 604–632.
KOBAYASHI ,M . ANDTAKEDA , K. 2000. Information retrieval on the web. Comput. Surv. 32 , 2, 144–173.
KOCBERBERA ,S . ANDCAN, F. 1997. Vertical framing of superimposed signature ﬁles using partial evaluation
of queries. Inform. Proc. Manag. 33 , 3, 353–376.
LANCASTER ,F .W . ANDFAYEN, E. G. 1973. Information Retrieval OnLine . Melville, Los Angeles, CA.
LEE, D. L., K IM, Y. M., ANDPATEL, G. 1995. Efﬁcient signature ﬁle methods for text retrieval. IEEE Tran.
Knowl. Data Eng. 7 , 3 (June) 423–435.
LEE,D .L . ANDLENG, C.-W. 1989. Partitioned signature ﬁles: Design issues and performance evaluation.
ACM Trans. Inform. Syst. 7 , 2, 158–180.
LEE, Y. K., Y OO, S. J., Y OON, K., ANDBERRA, P. B. 1996. Index structures for structured documents. In
Proceedings of the ACM Digital Libraries , Bethesda, MD, E. A. Fox and G. Marchionini, Eds. ACM Press,
91–99.
LEMPEL ,R . ANDMORAN, S. 2003. Predictive caching and prefetching of query results in search engines. In
Proceedings of the World Wide Web Conference . Budapest, Hungary. ACM Press, 19–28.
LEMPEL ,R . ANDMORAN, S. 2004. Optimal result prefetching in web search engines with segmented indices.
ACM Trans. Internet Techn. 4 , 1, 31–59.
LEMPEL ,R . ANDMORAN, S. 2005. Competitive caching of query results in search engines. Theoret. Comput.
Science 324 , 253–271.
LESTER , N., M OFFAT , A., W EBBER ,W . , ANDZOBEL, J. 2005. Space-limited ranked query evaluation using adap-
tive pruning. In Proceedings of the 6th International Conference on Web Informations Systems . Lecture
Notes in Computer Science, vol. 3806, Springer, 470–477.
LESTER , N., M OFFAT , A., ANDZOBEL, J. 2005. Fast on-line index construction by geometric partitioning. In
Proceedings of the CIKM International Conference on Information and Knowledge Management , Bremen,
Germany, A. Chowdhury, N. Fuhr, M. Ronthaler, H.-J. Schek, and W. Teiken, Eds. ACM Press, 776–783.
LESTER , N., Z OBEL,J . , ANDWILLIAMS , H. E. 2006. Efﬁcient online index maintenance for text retrieval sys-
tems. Inform. Proce. Manag. To appear.
LIM, L., W ANG, M., P ADMANABHAN , S., V ITTER ,J .S . , ANDAGARWAL , R. 2003. Dynamic maintenance of web
indexes using landmarks. In Proceedings of the World-Wide Web Conference , Budapest, Hungary. Y.-F. R.
Chen, L. Kov ´acs, and S. Lawrence, Eds. ACM Press, 102–111.
LINOFF ,G . ANDSTANFILL , C. 1993. Compression of indexes with full positional information in very large text
databases. In Proceedings of the 16th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval , Pittsburg, PA. R. Korfhage, E. Rasmussen, and P. Willett, Eds.
ACM Press, 88–97.
LU,Z . ANDMCKINLEY , K. S. 2003. Partial collection replication for information retrieval. Kluwer Int. J.
Inform. Retrie. 6 , 2, 159–198.
LUCARELLA , D. 1988. A document retrieval system based upon nearest neighbour searching. J. Inform.
Science 14 , 25–33.
LUHN, H. P. 1957. A statistical approach to mechanised encoding and searching of library information.
IBM J. Resear. Develop. 1 , 309–317.
MACFARLANE , A., M CCANN, J. A., AND ROBERTSON , S. E. 2000. Parallel search using partitioned in-
verted ﬁles. In Proceedings of the String Processing and Information Retrieval Symposium .A
Coru ˜na, Spain. P. de la Fuente, Ed. IEEE Computer Society Press, Los Alamitos, CA. 209–
220.
MACLEOD , I. A., M ARTIN , T. P., N ORDIN ,B . , ANDPHILLIPS , J. R. 1987. Strategies for building distributed infor-
mation retrieval systems. Inform. Proc. Manag. 23 , 6, 511–528.
MANBER ,U . ANDWU, S. 1994. GLIMPSE: a tool to search through entire ﬁle systems. In USENIX Winter
Technical Conference . San Francisco CA. USENIX Association, Berkeley, CA. 23–32.
MANNING ,C .D . ANDSCH¨UTZE, H. 1999. Foundations of Statistical Natural Language Processing . MIT Press
Cambridge, MA.
MARON,M .E . ANDKUHNS , J. L. 1960. On relevance, probabilistic indexing and information retrieval. J.
ACM 7 , 3, 216–244.
MARTIN ,T .P . ,M ACLEOD , I. A., R USSELL , J. I., L EESE, K., ANDFOSTER , B. 1990. A case study of caching strategies
for a distributed full text retrieval system. Inform. Proc. Manag. 26 , 2, 227–247.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 53
MARTIN ,T .P . ANDRUSSELL , J. I. 1991. Data caching strategies for distributed full text retrieval systems.
Inform. Syst. 16 , 1, 1–11.
MATTHEW ,F .W . ANDTHOMSON , L. 1967. Weighted term search: a computer program for an inverted coordi-
nate search on magnetic tape. J. Chem. Document. 7 , 1, 49–56.
MCDONELL , K. J. 1977. An inverted index implementation. Comput. J. 20 , 1, 116–123.
MELNIK , S., R AGHAVAN , S., Y ANG,B . , ANDGARCIA -MOLINA , H. 2001. Building a distributed full-text index for
the web. ACM Trans. Inform. Syst. 19 , 3, 217–241.
MOFFAT , A. 1992. Economical inversion of large text ﬁles. Comput. Syst. 5 , 2, 125–139.
MOFFAT ,A . ANDBELL, T. A. H. 1995. In-situ generation of compressed inverted ﬁles. J. Ame. Soci. Inform.
Science 46 , 7 (Aug.) 537–550.
MOFFAT ,A . ANDSTUIVER , L. 2000. Binary interpolative coding for effective index compression. Kluwer Int.
J. Inform. Retriev. 3 , 1 (July) 25–47.
MOFFAT ,A . AND TURPIN , A. 2002. Compression and Coding Algorithms . Kluwer Academic Publishers,
Boston, MA.
MOFFAT , A., W EBBER , W., Z OBEL,J . , ANDBAEZA-YATES, R. 2005. A pipelined architecture for distributed text
query evaluation. Submitted for publication.
MOFFAT ,A . ANDZOBEL, J. 1992a. Coding for compression in full-text retrieval systems. In Proceedings of
the IEEE Data Compression Conference , Snowbird, UT, J. A. Storer and M. Cohn, Eds. IEEE Computer
Society Press, Los Alamitos, CA, 72–81.
MOFFAT ,A . ANDZOBEL, J. 1992b. Parameterised compression for sparse bitmaps. In Proceedings of the 5th
Annual International ACM SIGIR Conference on Research and Development in Information Retrieval ,
Copenhagen, Denmaaank, N. J. Belkin, P. Ingwersen, and A. M. Pejtersen, Eds. ACM Press, 274–285.
MOFFAT ,A . ANDZOBEL, J. 1996. Self-indexing inverted ﬁles for fast text retrieval. ACM Trans. Informa.
Syst. 14 , 4 (Oct.) 349–379.
MOFFAT ,A . ANDZOBEL, J. 2004. What does it mean to “measure performance”? In Proceedings of the 5th
International Conference on Web Informations Systems , Brisbane, Australia. X. Zhou, S. Su, M. P. Papa-
zoglou, M. E. Owlowska, and K. Jeffrey, Eds. Lecture Notes in Computer Science, vol. 3306. Springer,1–12.
M
OFFAT , A., Z OBEL,J . , ANDSACKS-DAVIS, R. 1994. Memory efﬁcient ranking. Inform. Proc. Manag. 30 , 6 (Nov.)
733–744.
MOTZKIN , D. 1994. On high performance of updates within an efﬁcient document retrieval system. Inform.
Proc. Manag. 30 , 1, 93–118.
NAVARRO ,G . , DEMOURA , E., N EUBERT , M., Z IVIANI ,N . , ANDBAEZA-YATES, R. 2000. Adding compression to block
addressing inverted indexes. Kluwer Int. J. Inform. Retriev. 3 , 1, 49–77.
NOREAULT , T., K OLL, M., ANDMCGILL, M. J. 1977. Automatic ranked output from Boolean searches in SIRE.
J. Amer, Soc. Inform. Science 28 , 333–339.
PERRY,S .A . ANDWILLETT , P. 1983. A review of the use of inverted ﬁles for best match searching in informa-
tion retrieval systems. J. Inform. Science 6 , 59–66.
PERSIN , M., Z OBEL,J . , ANDSACKS-DAVIS, R. 1996. Filtered document retrieval with frequency-sorted indexes.
J. Amer. Soc. Inform. Science 47 , 10, 749–764.
PONTE ,J .M . ANDCROFT, W. B. 1998. A language modelling approach to information retrieval. In Proceedings
of the 21st Annual International ACM SIGIR Conference on Research and Development in InformationRetrieval . Melbourne, Australia, 275–281.
R
ABITTI , F., Ed. 1986. In Proceedings of the 9th Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval . Pisa, Italy, ACM Press.
REDDAWAY , S. F. 1991. High speed text retrieval from large databases on a massively parallel processor.
Inform. Proc. Manag. 27 , 4, 311–316.
RIBEIRO -NETO,B . ANDBARBOSA , R. 1998. Query performance for tightly coupled distributed digital libraries.
InProceedings of the ACM Digital Libraries , Pittsburgh, PA, I. Witten, R. Akscyn, and F. M. S. III, Eds.
ACM Press, 182–190.
RIBERTO -NETO,B . , DEMOURA , E. S., N EUBERT ,M .S . , ANDZIVIANI , N. 1999. Efﬁcient distributed algorithms to
build inverted ﬁles. In Proceedings of the 22nd Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval . San Francisco, CA, 105–112.
RICE, R. F. 1979. Some practical universal noiseless coding techniques. Tech. Rep. 79–22, Jet Propulsion
Laboratory, Pasadena, CA.
ROBERTSON , S. E. 1977. The probability ranking principle in IR. J. Document. 33 , 4 (Dec.) 294–304.
ROBERTSON , S. E., W ALKER , S., J ONES, S., H ANCOCK -BEAULIEU ,M .M . , ANDGATFORD , M. 1994. Okapi at TREC-3.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.54 J. Zobel and A. Moffat
InOverview of the 3rd TREC Text REtrieval Conference , Gaithersburg, MD, D. Harman, Ed. NIST, NIST
Special Publication 500-226.
ROGERS , W., C ANDELA ,G . , ANDHARMAN , D. 1995. Space and time improvements for indexing in information
retrieval. In Proceedings of the Annual Symposium on Document Analysis and Information Retrieval ,
Las Vegas, NV, L. Spitz and D. D. Lewis, Eds.
SACKS-DAVIS, R., K ENT,A .J . , ANDRAMAMOHANARAO , K. 1987. Multi-key access methods based on superim-
posed coding techniques. ACM Trans. Datab. Syst. 12 , 4, 655–696.
SALOMON , D. 2000. Data Compression: The Complete Reference , 2nd Ed. Springer, Berlin, Germany.
SALTON , G. 1962. The use of citations as an aid to automatic content analysis. Tech. Rep. ISR-2, Section
III, Harvard Computation Laboratory, Cambridge, MA.
SALTON , G. 1968. Automatic Index Organization and Retrieval . McGraw-Hill, New York, NY.
SALTON , G., Ed. 1971. The SMART Retrieval System: Experiments in Automatic Document Processing .
Prentice-Hall, Englewood Cliffs, NJ.
SALTON , G. 1972. Dynamic document processing. Comm. ACM 15 , 7, 658–668.
SALTON , G. 1989. Automatic Text Processing: The Transformation, Analysis, and Retrieval of Information
by Computer . Addison-Wesley, Reading, MA.
SALTON ,G . ANDBUCKLEY , C. 1988a. Parallel text search methods. Comm. ACM 31 , 2 (Feb.) 202–215.
SALTON ,G . ANDBUCKLEY , C. 1988b. Term-weighting approaches in automatic text retrieval. Inform. Proc.
Manag. 24 , 5, 513–523.
SALTON ,G . ANDMCGILL, M. J. 1983. Introduction to Modern Information Retrieval . McGraw-Hill, New York,
NY.
SALTON , G., W ONG, A., ANDWANG, C. S. 1975. A vector space model for automatic indexing. Comm. ACM 18 ,1 1
(Nov.) 613–620.
SARAIVA ,P .C . , DEMOURA ,E .S . ,Z IVIANI , N., F ONSECA , R., M EIRA, W., M URTA,C . , ANDRIBEIRO -NETO, B. 2001.
Rank-preserving two-level caching for scalable search engines. In Proceedings of the 24th Annual Inter-
national ACM SIGIR Conference on Research and Development in Information Retrieval . New Orleans,
LA. 51–58.
SAYOOD , K. 2000. Introduction to Data Compression 2nd Ed. Morgan Kaufmann, San Francisco, CA.
SCHOLER , F., W ILLIAMS , H. E., Y IANNIS ,J . , ANDZOBEL, J. 2002. Compression of inverted indexes for fast query
evaluation. In Proceedings of the 25th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval . Tampere, Finland. 222–229.
SCHUEGRAF , E. J. 1976. Compression of large inverted ﬁles with hyperbolic term distribution. Inform. Proc.
Manag. 12 , 377–384.
SEGESTA ,J .ANDREID-GREEN, K. 2002. Harley Tillitt and computerized library searching. IEEE Ann. History
Comput. 24 , 3 (Sept.) 23–34.
SEVERANCE ,D .G . ANDCARLIS , J. V. 1977. A practical approach to selecting record access paths. Comput.
Surv. 9 , 4, 259–272.
SHIEH, W.-Y., C HEN, T.-F., ANDCHUNG , C.-P. 2003. A tree-based inverted ﬁle for fast ranked-document re-
trieval. In Proceedings of the International Conference on Information and Knowledge Engineering . Las
Vegas, NV. H. R. Arabnia, Ed. CSREA Press, 64–69.
SHIEH, W.-Y., C HEN, T.-F., S HANN , J. J.-J., ANDCHUNG , C.-P. 2003. Inverted ﬁle compression through document
identiﬁer reassignment. Inform. Proc. Manag. 39 , 1, 117–131.
SHIEH, W.-Y. ANDCHUNG , C.-P. 2005. A statistics-based approach to incrementally update inverted ﬁles.
Inform. Proc. Manag. 41 , 2, 275–288.
SHIEH, W.-Y., S HANN , J. J.-J., ANDCHUNG , C.-P. 2003. An inverted ﬁle cache for fast information retrieval. J.
Inform. Science Eng. 19 , 4, 681–695.
SHOENS , K., T OMASIC , A., ANDGARC´ıA-MOLINA , H. 1994. Synthetic workload performance analysis of incre-
mental updates. In Proceedings of the 17th Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval . Dublin, Ireland, W. B. Croft and C. J. van Rijsbergen, Eds.
ACM Press, 329–338.
SILVESTRI , F., O RLANDO ,S . , ANDPEREGO , R. 2004. Assigning identiﬁers to documents to enhance the clustering
property of fulltext indexes. In Proceedings of the 27th Annual International ACM SIGIR Conference on
Research and Development in Information Retrieval . Shefﬁeld, England, M. Sanderson, K. J ¨arvelin,
J. Allan, and P. Bruza, Eds. ACM Press, 305–312.
SINGHAL , A., B UCKLEY ,C . , ANDMITRA, M. 1996. Pivoted document length normalization. In Proceedings of
the 19th Annual International ACM SIGIR Conference on Research and Development in InformationRetrieval . Zurich, Switzerland, 21–29.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.Inverted Files for Text Search Engines 55
SMEATON ,A . AND VAN RIJSBERGEN , C. J. 1981. The nearest neighbour problem in information retrieval. In
Proceedings of the 4th Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval . Oakland, CA, C. J. Crouch, Ed. ACM Press, 83–87.
S
PARCK JONES, K., W ALKER ,S . , ANDROBERTSON , S. E. 2000. A probabilistic model of information retrieval:
development and comparative experiments. parts 1&2. Inform. Proc. Manag. 36 , 6, 779–840.
SPARCK JONES,K . ANDWILLETT , P., Eds. 1997. Readings in Information Retrieval . Academic Press/Morgan
Kaufmann, San Francisco, CA.
SPINK, A., W OLFRAM , D., J ANSEN ,B .J . , ANDSARACEVIC , T. 2001. Searching the Web: The public and their
queries. J. Amer. Soci. Inform. Science 52 , 3, 226–234.
SPINK,A . ANDXU, J. L. 2000. Selected results from a large study of web searching: The Excite study. Inform.
Resear.—Int. Electron. J. 6 ,1 .
STANFILL , C. 1990. Partitioned posting ﬁles: a parallel inverted ﬁle structure for information retrieval. In
Proceedings of the 13th Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval . Brussels, Belgium. 413–428.
S
TANFILL , C., T HAU, R., ANDWALTZ, D. 1989. A parallel indexed algorithm for information retrieval. In Pro-
ceedings of the 12th Annual International ACM SIGIR Conference on Research and Development inInformation Retrieval . Cambridge, MA, , N. J. Belkin and C. J. van Rijsbergen, Eds. ACM Press, 88–97.
S
TELLHORN , W. H. 1977. An inverted ﬁle processor for information retrieval. IEEE Trans. Comput. 26 , 12,
1258–1267.
STROHMAN , T., T URTLE , H., ANDCROFT, W. B. 2005. Optimization strategies for complex queries. In Proceed-
ings of the 28th Annual International ACM SIGIR Conference on Research and Development in Infor-mation Retrieval . Salvador, Brazil, G. Marchionini, A. Moffat, J. Tate, R. Baeza-Yates, and N. Ziviani,
Eds. ACM Press, 219–225.
T
AGUE , J., Ed. 1985. Proceedings of the 8th Annual International ACM SIGIR Conference on Research and
Development in Information Retrieval . Montreal, Canada, ACM Press.
TEUHOLA , J. 1978. A compression method for clustered bit-vectors. Inform. Proc. Lett. 7 , 6 (Oct.) 308–311.
TOMASIC ,A . ANDGARC´ıA-MOLINA , H. 1993. Performance of inverted indices in shared-nothing distributed
text document information retrieval systems. In Proceedings of the International Conference on Parallel
and Distributed Information Systems. San Diego, CA, M. J. Carey and P. Valduriez, Eds. IEEE Computer
Society Press, 8–17.
TOMASIC ,A . ANDGARC´ıA-MOLINA , H. 1996. Performance issues in distributed shared-nothing information-
retrieval systems. Inform. Proc. Manag. 32 , 6, 647–665.
TOMASIC , A., G ARC´ıA-MOLINA , H., ANDSHOENS , K. 1994. Incremental updates of inverted lists for text doc-
ument retrieval. In Proceedings of the ACM-SIGMOD International Conference on the Management of
Data . Minneapolis, MA, R. T. Snodgrass and M. Winslett, Eds. ACM Press, 289–300.
TROTMAN , A. 2003. Compressing inverted ﬁles. Kluwer Int. J. Inform. Retriev. 6 , 5–19.
TURTLE ,H . ANDFLOOD, J. 1995. Query evaluation: strategies and optimizations. Inform. Proc. Manag. 31 ,1
(Nov.), 831–850.
VANRIJSBERGEN , C. J. 1979. Informat. Retriev. , 2nd Ed. Butterworths, London, UK.
VASANTHAKUMAR , S. R., C ALLAN ,J .P . , ANDCROFT, W. B. 1996. Integrating INQUERY with an RDBMS to
support text retrieval. Bull. Techn. Comm. Data Eng. 19 , 1, 24–33.
VIDICK , J. L., Ed. 1990. Proceedings of the 13th Annual International ACM SIGIR Conference on Research
and Development in Information Retrieval . Brussels, Belgium. ACM Press,
VOORHEES , E. M. 1986. The efﬁciency of inverted index and cluster searches. In Proceedings of the 9th
Annual ACM SIGIR Conference on Research and Development in Information Retrieval . Pisa, Italy. 164–
174.
VOORHEES ,E .M . ANDHARMAN , D. K. 2005. TREC: Experiment and evaluation in information retrieval .M I T
Press, Cambridge, MA.
WILLIAMS ,H .E . ANDZOBEL, J. 1999. Compressing integers for fast ﬁle access. Comput. J. 42 , 3, 193–201.
WILLIAMS , H. E., Z OBEL,J . , ANDANDERSON , P. 1999. What’s next? Index structures for efﬁcient phrase query-
ing. In Proceedings of the Australasian Database Conference. Auckland, New Zealand. M. Orlowska, Ed.
Australian Computer Society, 141–152.
WILLIAMS , H. E., Z OBEL,J . , ANDBAHLE, D. 2004. Fast phrase querying with combined indexes. ACM Trans.
Inform. Syst. 22 , 4, 573–594.
WITTEN , I. H., B ELL,T .C . , ANDNEVILL , C. G. 1991. Models for compression in full-text retrieval systems. In
Proceedings of the IEEE Data Compression Conference . Snowbird, UT, J. A. Storer and J. H. Reif, Eds.
IEEE Computer Society Press, Los Alamitos, CA. 23–32.
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.56 J. Zobel and A. Moffat
WITTEN , I. H., M OFFAT , A., ANDBELL, T. C. 1999. Managing Gigabytes: Compressing and Indexing Documents
and Images , 2nd Ed. Morgan Kaufmann, San Francisco, CA.
WONG,W .Y .P . ANDLEE, D. K. 1993. Implementations of partial document ranking using inverted ﬁles. Inform.
Proc. Manag. 29 , 5 (Sept.), 647–669.
XI, W., S ORNIL ,O . , ANDFOX, E. A. 2002a. Hybrid partition inverted ﬁles for large-scale digital libraries. In
Proceedings of the Digital Library: IT Opportunities and Challenges in the New Millennium . Beijing
Library Press, Beijing, China, 404–418.
XI, W., S ORNIL , O., L UO, M., ANDFOX, E. A. 2002b. Hybrid partition inverted ﬁles: Experimental validation.
InProceedings of the European Conference on Research and Advanced Technology for Digital Libraries .
Rome, Italy, M. Agosti and C. Thanos, Eds. Lecture Notes in Computer Science, vol. 2458, Springer,422–413.
Z
EZULA , P., R ABITTI ,F . , ANDTIBERIO , P. 1991. Dynamic partitioning of signature ﬁles. ACM Tran. Inform.
Syst. 9 , 4 (Oct.), 336–369.
ZOBEL,J . ANDMOFFAT , A. 1998. Exploring the similarity space. SIGIR Forum 32 , 1, 18–34.
ZOBEL, J., M OFFAT , A., ANDRAMAMOHANARAO , K. 1996. Guidelines for presentation and comparison of indexing
techniques. SIGMOD Record 25 , 3 (Oct.), 10–15.
ZOBEL, J., M OFFAT , A., ANDRAMAMOHANARAO , K. 1998. Inverted ﬁles versus signature ﬁles for text indexing.
ACM Trans. Datab. Syst. 23 , 4 (Dec.), 453–490.
ZOBEL, J., M OFFAT , A., ANDSACKS-DAVIS, R. 1992. An efﬁcient indexing technique for full-text database sys-
tems. In Proc. VLDB Int. Conf. on Very Large Databases , L.-Y. Yuan, Ed. Morgan Kaufmann, Vancouver,
352–362.
ZOBEL, J., M OFFAT , A., ANDSACKS-DAVIS, R. 1993a. Searching large lexicons for partially speciﬁed terms
using compressed inverted ﬁles. In Proceedings of the International Conference on Very Large Databases .
Dublin, Ireland, R. Agrawal, S. Baker, and D. Bell, Eds. Morgan Kaufmann, 290–301.
ZOBEL, J., M OFFAT , A., ANDSACKS-DAVIS, R. 1993b. Storage management for ﬁles of dynamic records. In
Proceedings of the Australasian Database Conference. Brisbane, Australia, 26–38.
ZOBEL, J., M OFFAT , A., W ILKINSON , R., ANDSACKS-DAVIS, R. 1995. Efﬁcient retrieval of partial documents.
Inform. Proc. Manag. 31, 3, 361–377.
Received September 2004; revised November 2005; accepted March 2006
ACM Computing Surveys, Vol. 38, No. 2, Article 6, Publication date: July 2006.